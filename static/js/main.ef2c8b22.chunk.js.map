{"version":3,"sources":["images/help.png","Header.tsx","Search.tsx","DataCardHandler.ts","EntityGraph.jsx","DataCards.tsx","App.tsx","serviceWorker.ts","index.tsx","images/arrow.svg","images/logo.svg"],"names":["module","exports","Header","src","require","alt","style","width","Search","props","pageRedirect","state","redirect","to","targetID","handleSearch","bind","handleSearchKeyDown","getDescriptors","id","this","hasKey","entities","alternatives","ReactGA","event","category","action","currentInput","document","getElementById","value","split","currentInputName","trim","setState","which","keyCode","obj","key","Fragment","margin","textAlign","placeholder","list","onKeyDown","fontSize","maxHeight","Object","values","map","entity","arrow","onClick","className","React","Component","getGender","checkNoRelations","relationships","MOTHERS","length","FATHERS","SIBLINGS","TWIN","SPOUSES","CHILDREN","getNameString","parameter","stringSoFar","s","getName","entityRow","possibleNames","i","undefined","EntityGraph","getRandomPoints","edge","allShapes","forEach","shape","push","attrs","x","y","getDepthNodes","entityData","depthNegOne","depthZero","depthPosOne","m","f","CREATORS","c","BORNFROM","b","t","d","child","checkForDuplicates","otherParentIDs","p","splice","Math","ceil","arr","e","includes","getConnectionsList","console","log","allConnections","connection","parents","children","pNodeDepth","concat","cp","isSpouseRepeated","geAllLinePoints","depthNodes","connections","allLinePoints","graphAttr","nodeWidth","height","nodeHeight","initX","spaceX","linePoints","PM_Y","PM_X","depth","NegOneY","ZeroY","pX","indexOf","pIndex","pY","sID","j","handleMouseOverNode","body","cursor","target","strokeWidth","handleMouseOutNode","handleMouseOverLine","handleMouseOutLine","handlePageChange","relationshipClicked","stageRef","PosOneY","connectedShapes","lineLinks","refs","stage","getStage","find","each","JSON","parse","connectionsList","ref","text","fontFamily","fontStyle","fill","padding","align","name","stroke","onMouseOver","onMouseOut","points","DataCards","members","sub","super","type","validSearch","unusual","autochthony","tf","passage","createdWithoutParents","createdByAgent","agentID","parthenogenesis","bornFromObject","objectID","diesWithoutChildren","alternativeName","handleNameClicked","startID","author","passages","Author","title","Title","start","Passage","end","endID","URN","URNsplit","rel","href","color","history","grandparents","g","duplicate","duplicateIndex","newPassages","removeGrandparentDuplicates","clear","fontWeight","textTransform","float","paddingRight","marginTop","textDecoration","getPassageLink","relationship","Pluralize","singular","showPassage","getPluralization","entityNameAndPassage","objectNameAndPassage","getChildParentGrouped","getOtherParentText","group","pID","marginBottom","member","relation","otherParents","divineParents","params","queryString","location","search","slice","newState","display","border","getAlternativeNames","getAlternativePage","getGrandparentDataPoints","getCollectiveSubheading","keys","getDataPoints","getCollectiveMembers","App","subjectID","show","ID","initialize","pageview","toggleModalState","paddingTop","path","component","Boolean","window","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.ef2c8b22.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,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\"","import React from \"react\";\nimport \"./App.css\";\n\nconst Header: React.FC = () => {\n  return (\n    <img\n      src={require(\"./images/logo.svg\")}\n      alt=\"Manto logo\"\n      style={{ width: \"20%\" }}\n    ></img>\n  );\n};\n\nexport default Header;\n","import React from \"react\";\nimport \"./App.css\";\nimport entities from \"./data/entities.json\";\nimport { Redirect } from \"react-router-dom\";\nimport arrow from \"./images/arrow.svg\";\nimport ReactGA from \"react-ga\";\n\ntype SearchProps = {};\ntype SearchState = {\n  redirect: boolean;\n  targetID: string;\n};\n\nclass Search extends React.Component<SearchProps, SearchState> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      redirect: false,\n      targetID: \"\"\n    };\n    // this.onSearchSubmit = this.onSearchSubmit.bind(this);\n    this.handleSearch = this.handleSearch.bind(this);\n    this.handleSearchKeyDown = this.handleSearchKeyDown.bind(this);\n    this.getDescriptors = this.getDescriptors.bind(this);\n  }\n\n  getDescriptors(id: string) {\n    if (this.hasKey(entities, id)) {\n      let alternatives: string = \"\";\n      if (entities[id][\"Name (transliteration)\"] !== \"\") {\n        alternatives =\n          alternatives + \", \" + entities[id][\"Name (transliteration)\"];\n      }\n      if (entities[id][\"Name (Greek font)\"] !== \"\") {\n        alternatives = alternatives + \", \" + entities[id][\"Name (Greek font)\"];\n      }\n      if (entities[id][\"Name (Latinized)\"] !== \"\") {\n        alternatives = alternatives + \", \" + entities[id][\"Name (Latinized)\"];\n      }\n      if (entities[id][\"Name in Latin texts\"] !== \"\") {\n        alternatives =\n          alternatives + \", \" + entities[id][\"Name in Latin texts\"];\n      }\n      if (entities[id][\"Alternative names\"] !== \"\") {\n        alternatives = alternatives + \", \" + entities[id][\"Alternative names\"];\n      }\n      let inputText =\n        entities[id][\"Name (house style)\"] +\n        alternatives +\n        \": \" +\n        entities[id][\"Identifying information\"];\n      return inputText;\n    }\n  }\n\n  pageRedirect = () => {\n    if (this.state.redirect) {\n      return <Redirect to={\"/datacards?id=\" + this.state.targetID} />;\n    }\n  };\n\n  handleSearch() {\n    ReactGA.event({\n      category: \"Search\",\n      action: \"User searched for an entity using the search bar\"\n    });\n    let currentInput = document.getElementById(\"input\") as HTMLInputElement;\n    if (currentInput.value !== \"\") {\n      //Search based on name and identifying information - super inefficient. TODO: fix this\n      for (let id in entities) {\n        if (this.hasKey(entities, id)) {\n          if (\n            entities[id][\"Identifying information\"] ===\n            currentInput.value.split(\": \")[1]\n          ) {\n            let currentInputName = currentInput.value\n              .split(\": \")[0]\n              .split(\",\")[0]\n              .trim();\n\n            if (\n              currentInputName === entities[id][\"Name (house style)\"] ||\n              currentInputName === entities[id][\"Name (transliteration)\"] ||\n              currentInputName === entities[id][\"Name (Greek font)\"] ||\n              currentInputName === entities[id][\"Name (Latinized)\"] ||\n              currentInputName === entities[id][\"Name in Latin texts\"] ||\n              currentInputName === entities[id][\"Alternative names\"]\n            ) {\n              this.setState({\n                redirect: true,\n                targetID: id\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n\n  handleSearchKeyDown(event: any) {\n    if (event.which === 13 || event.keyCode === 13) {\n      this.handleSearch();\n    }\n  }\n\n  /* Addresses typescript indexing objects error */\n  hasKey<O>(obj: O, key: keyof any): key is keyof O {\n    return key in obj;\n  }\n\n  render() {\n    /* const entitiesArray = Object.values(entities).map(entity => {\n      return {\n        // what to show to the user\n        label: entity.ID + \": \" + this.getDescriptors(entity.ID),\n        // key to identify the item within the array\n        key: entity.ID\n      };\n    }); */\n    return (\n      <React.Fragment>\n        {/* <h3 style={{ textAlign: \"center\" }}>SEARCH</h3> */}\n        {this.pageRedirect()}\n        <div\n          style={{\n            margin: \"1rem 0 1rem 0\",\n            textAlign: \"center\"\n          }}\n        >\n          {/* <DataListInput\n          placeholder={\"Search by entity name...\"}\n          items={entitiesArray}\n          onSelect={this.pageRedirect}\n          match={this.matchCurrentInput}\n        /> */}\n          <input\n            // type=\"search\"\n            placeholder=\"Search by name\"\n            id=\"input\"\n            list=\"entities\"\n            onKeyDown={this.handleSearchKeyDown}\n            style={{ width: \"50%\", textAlign: \"center\", fontSize: \"1rem\" }}\n          ></input>\n          <datalist id=\"entities\" style={{ maxHeight: \"100px\" }}>\n            {Object.values(entities).map(entity => {\n              return (\n                <option value={this.getDescriptors(entity[\"ID\"])}></option>\n              );\n            })}\n          </datalist>\n          <div>\n            <img\n              alt=\"Submit search\"\n              src={arrow}\n              onClick={this.handleSearch}\n              className=\"search-arrow\"\n            ></img>\n          </div>\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default Search;\n","var ties = require(\"./data/ties.json\");\nvar entities = require(\"./data/entities.json\");\nvar objects = require(\"./data/objects.json\");\nvar relationships = require(\"./data/relationships.json\");\n\ntype passageInfo = {\n  start: string;\n  startID: string;\n  end: string;\n  endID: string;\n};\n\nexport type entityInfo = {\n  target: string;\n  targetID: string;\n  passage: passageInfo[];\n  type: string;\n};\n\ntype childrenInfo = {\n  child: entityInfo[];\n  otherParentIDs: string[];\n  divineParentID?: string;\n};\n\nexport type relationshipInfo = {\n  MOTHERS: entityInfo[];\n  FATHERS: entityInfo[];\n  CREATORS: entityInfo[];\n  BORNFROM: entityInfo[];\n  SIBLINGS: entityInfo[];\n  TWIN: entityInfo[];\n  SPOUSES: entityInfo[];\n  CHILDREN: childrenInfo[];\n};\n\ntype returningInfo = {\n  id: string;\n  relationships: relationshipInfo;\n  name: string;\n  members: { sub: any[]; super: any[] };\n  type: string;\n  validSearch: boolean;\n  unusual: {\n    autochthony: { tf: boolean; passage: passageInfo[] };\n    createdWithoutParents: { tf: boolean; passage: passageInfo[] };\n    createdByAgent: { tf: boolean; passage: passageInfo[]; agentID: string };\n    parthenogenesis: { tf: boolean; passage: passageInfo[] };\n    bornFromObject: { tf: boolean; passage: passageInfo[]; objectID: string };\n    diesWithoutChildren: { tf: boolean; passage: passageInfo[] };\n  };\n  alternativeName: { targetID: string; passage: passageInfo[] };\n};\n\nlet familyTies = [\n  /* Parent */\n  \"is father of\",\n  \"is mother of\",\n  \"is parent of\",\n  /* Child */\n  \"is child of\",\n  /* Sibling */\n  \"is sibling of\",\n  \"is twin of\",\n  \"is older than\",\n  /* Spouse */\n  \"is spouse of\",\n  \"marries\",\n  /* Ancestors - currently unused\n  \"is grandfather of\",\n  \"is grandmother of\",\n  \"is grandparent of\",\n  \"is grandson of\",\n  \"is granddaughter of\",\n  \"is grandchild of\",\n  */\n\n  /* Member of collective */\n  \"is part of\",\n  \"is member of\",\n\n  /* Unusual relationships */\n  \"is born by autochthony [in/on/at]\",\n  \"comes into being\",\n  \"creates [agent]\",\n  \"is mother by parthenogenesis of\",\n  \"is born from [object]\",\n  \"has no children\"\n];\n\n/******************************************************************************************/\n/* Returns the data card geneology information, interfaces with DataCards.tsx                \n/******************************************************************************************/\nexport const updateComponent = (id: string) => {\n  let connections = getAllConnections(id);\n  if (\n    connections.length > 0 &&\n    connections[0].predicate === \"is alternative name for\"\n  ) {\n    let empty: relationshipInfo = {\n      MOTHERS: [],\n      FATHERS: [],\n      CREATORS: [],\n      BORNFROM: [],\n      SIBLINGS: [],\n      TWIN: [],\n      SPOUSES: [],\n      CHILDREN: []\n    };\n    let altNameConnection: returningInfo = {\n      id: id,\n      relationships: empty,\n      name: getName(entities[id]),\n      members: { sub: [], super: [] },\n      type: entities[id] ? entities[id][\"Type of entity\"] : \"\",\n      validSearch: true,\n      alternativeName: {\n        targetID: connections[0].targetID,\n        passage: connections[0].passage\n      },\n      unusual: {\n        autochthony: { tf: false, passage: [] },\n        createdWithoutParents: { tf: false, passage: [] },\n        createdByAgent: { tf: false, passage: [], agentID: \"\" },\n        parthenogenesis: { tf: false, passage: [] },\n        bornFromObject: { tf: false, passage: [], objectID: \"\" },\n        diesWithoutChildren: { tf: false, passage: [] }\n      }\n    };\n    return altNameConnection;\n  } else {\n    return sortConnectionsIntoRelationships(id, connections);\n  }\n};\n\n/******************************************************************************************/\n/* Find all relationships                                                                 */\n/* -------------------------------------------------------------------------------------- */\n/* This function changes all ties (X <predicate> Y, Y <predicate> X, Z <predicate> Y X) to Y <predicate> X. */\n/******************************************************************************************/\nconst getAllConnections = (id: string) => {\n  var connections: {\n    target: string;\n    targetID: string;\n    predicate: string;\n    passage: passageInfo[];\n  }[] = [];\n\n  Object.values(ties).forEach(function(tieRow) {\n    // TODO: Fix this temporary solution for entities not existing in entities.csv\n    if (typeof tieRow !== \"object\" || tieRow === null) {\n    } else {\n      // The first if statement is to remove \"object is of type unknown\" error\n\n      if (entities[tieRow[\"Subject ID\"]]) {\n        //check if the entity is just an \"alternative name for\"\n        //if so, ignore all geneological data gathered so far and just return connections = [{target: \"\", targetID: \"\", predicate: \"is alternative name for\", passage:[]}]\n\n        if (\n          tieRow[\"Subject ID\"] === id &&\n          tieRow[\"Predicate\"] === \"is alternative name for\"\n        ) {\n          let passageInfo: passageInfo[] = [\n            {\n              start: tieRow[\"Passage: start\"],\n              startID: tieRow[\"Passage: start ID\"],\n              end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n              endID:\n                tieRow[\"Passage: end ID\"] === \"\"\n                  ? \"\"\n                  : tieRow[\"Passage: end ID\"]\n            }\n          ];\n          connections = [\n            {\n              target: \"\",\n              targetID: tieRow[\"Direct Object ID\"],\n              predicate: \"is alternative name for\",\n              passage: passageInfo\n            }\n          ];\n          return connections;\n        }\n\n        /*********************************************************/\n        /* If you are the direct object X, e.g. (Y (predicate) X)     */\n        /*********************************************************/\n        if (\n          tieRow[\"Direct Object ID\"] === id &&\n          familyTies.includes(tieRow[\"Predicate\"])\n        ) {\n          // For mother not including parthenogenesis part\n          let passageInfo: passageInfo[] = [\n            {\n              start: tieRow[\"Passage: start\"],\n              startID: tieRow[\"Passage: start ID\"],\n              end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n              endID:\n                tieRow[\"Passage: end ID\"] === \"\"\n                  ? \"\"\n                  : tieRow[\"Passage: end ID\"]\n            }\n          ];\n\n          if (\n            getGender(tieRow[\"Subject ID\"]) &&\n            tieRow[\"Predicate\"] === \"marries\"\n          ) {\n            tieRow[\"Predicate\"] = \"is spouse of\";\n          }\n\n          if (\n            tieRow[\"Predicate\"] === \"is part of\" ||\n            tieRow[\"Predicate\"] === \"is member of\"\n          ) {\n            tieRow[\"Predicate\"] = \"has members\";\n          }\n\n          // Unusual relationships X is mother by parthenogenesis of Y, and X creates Y are dealt with here.\n\n          // Push connections to the list of connections\n          connections.push({\n            target: getName(entities[tieRow[\"Subject ID\"]]),\n            targetID: tieRow[\"Subject ID\"],\n            predicate: tieRow[\"Predicate\"],\n            passage: passageInfo\n          });\n        }\n\n        /*********************************************************/\n        /* If you are the subject X, e.g. (X (predicate) Y)           */\n        /*********************************************************/\n        if (\n          tieRow[\"Subject ID\"] === id &&\n          familyTies.includes(tieRow[\"Predicate\"])\n        ) {\n          let passageInfo: passageInfo[] = [\n            {\n              start: tieRow[\"Passage: start\"],\n              startID: tieRow[\"Passage: start ID\"],\n              end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n              endID: tieRow[\"Passage: end ID\"]\n            }\n          ];\n\n          // Push connections to the list of connections\n          if (\n            tieRow[\"Predicate\"] === \"is born by autochthony [in/on/at]\" ||\n            tieRow[\"Predicate\"] === \"comes into being\" ||\n            tieRow[\"Predicate\"] === \"has no children\"\n          ) {\n            connections.push({\n              target: \"\",\n              targetID: \"\",\n              predicate: tieRow[\"Predicate\"],\n              passage: passageInfo\n            });\n          } else if (tieRow[\"Predicate\"] === \"is born from [object]\") {\n            connections.push({\n              target: getName(objects[tieRow[\"Direct Object ID\"]]),\n              targetID: tieRow[\"Direct Object ID\"],\n              predicate: tieRow[\"Predicate\"],\n              passage: passageInfo\n            });\n          } else {\n            // If collective member\n            connections.push({\n              target: getName(entities[tieRow[\"Direct Object ID\"]]),\n              targetID: tieRow[\"Direct Object ID\"],\n              predicate:\n                tieRow[\"Predicate\"] === \"is part of\" ||\n                tieRow[\"Predicate\"] === \"is member of\"\n                  ? \"is member of\"\n                  : reversedPredicate(\n                      tieRow[\"Predicate\"],\n                      tieRow[\"Direct Object ID\"]\n                    ),\n              passage: passageInfo\n            });\n          }\n        }\n\n        /***********************************************************************/\n        /* For \"Gives in marriage:\" - parent gives child in marriage to person */\n        /*************************************************************************/\n\n        // If you are the indirect object X, e.g. (Z (predicate) Y X)\n        if (\n          tieRow[\"Indirect Object (to/for) ID\"] &&\n          tieRow[\"Indirect Object (to/for) ID\"] === id &&\n          tieRow[\"Predicate\"] === \"gives in marriage [dir. obj.] [ind. obj.]\"\n        ) {\n          let passageInfo: passageInfo[] = [\n            {\n              start: tieRow[\"Passage: start\"],\n              startID: tieRow[\"Passage: start ID\"],\n              end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n              endID: tieRow[\"Passage: end ID\"]\n            }\n          ];\n          connections.push({\n            target: getName(entities[tieRow[\"Direct Object ID\"]]),\n            targetID: tieRow[\"Direct Object ID\"],\n            predicate: \"is spouse of\",\n            passage: passageInfo\n          });\n        }\n\n        // If you are the direct object X, e.g. (Z (predicate) X Y)\n        else if (\n          tieRow[\"Direct Object ID\"] &&\n          tieRow[\"Direct Object ID\"] === id &&\n          tieRow[\"Predicate\"] === \"gives in marriage [dir. obj.] [ind. obj.]\"\n        ) {\n          let passageInfo: passageInfo[] = [\n            {\n              start: tieRow[\"Passage: start\"],\n              startID: tieRow[\"Passage: start ID\"],\n              end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n              endID: tieRow[\"Passage: end ID\"]\n            }\n          ];\n          connections.push({\n            target: getName(entities[tieRow[\"Indirect Object (to/for) ID\"]]),\n            targetID: tieRow[\"Indirect Object (to/for) ID\"],\n            predicate: \"is spouse of\",\n            passage: passageInfo\n          });\n        }\n      }\n    }\n  });\n\n  return connections;\n};\n\n/******************************************************************************************/\n/* Sort relationships                                                                     */\n/* -------------------------------------------------------------------------------------- */\n/* This function sorts all of the found connections into existing geneological categories */\n/******************************************************************************************/\nconst sortConnectionsIntoRelationships = (id: string, connections: any) => {\n  /* Preliminary info about the entity */\n  let name = getName(entities[id]);\n  let type = entities[id] ? entities[id][\"Type of entity\"] : \"\";\n  let members: { sub: any[]; super: any[] } = { sub: [], super: [] };\n  let relationships: relationshipInfo = {\n    MOTHERS: [],\n    FATHERS: [],\n    CREATORS: [],\n    BORNFROM: [],\n    SIBLINGS: [],\n    TWIN: [],\n    SPOUSES: [],\n    CHILDREN: []\n  };\n  let Oautochthony = { tf: false, passage: [] };\n  let OcreatedWithoutParents = { tf: false, passage: [] };\n  let OcreatedByAgent = { tf: false, passage: [], agentID: \"\" };\n  let Oparthenogenesis = { tf: false, passage: [] };\n  let ObornFromObject = { tf: false, passage: [], objectID: \"\" };\n  let OdiesWithoutChildren = { tf: false, passage: [] };\n\n  let childrenTemp: entityInfo[] = [];\n  connections.forEach(tie => {\n    // For each of the connections already found,\n    // build the associated entity object, and\n    // populate with existing information\n\n    let tieNoY =\n      tie.predicate === \"is born by autochthony [in/or/at]\" ||\n      tie.predicate === \"comes into being\" ||\n      tie.predicate === \"has no children\"\n        ? true\n        : false;\n    // Checking for X (tie) Y where Y does not exist/is empty\n    let d: entityInfo = {\n      target: tieNoY ? \"\" : tie.target,\n      targetID: tieNoY ? \"\" : tie.targetID,\n      passage: tie.passage,\n      type: tieNoY\n        ? \"\"\n        : entities[tie.targetID]\n        ? entities[tie.targetID][\"Type of entity\"]\n        : \"\"\n    };\n\n    /* Categorising the connections, also checking for duplicates */\n\n    // X is your MOTHER\n    if (tie.predicate === \"is mother of\") {\n      // If passage is a duplicate / already exists\n      // for this entity, or  in the list of connections\n      relationships.MOTHERS = checkAndRemoveDuplicates(\n        relationships.MOTHERS,\n        d\n      );\n    }\n\n    // X is your FATHER\n    else if (tie.predicate === \"is father of\") {\n      relationships.FATHERS = checkAndRemoveDuplicates(\n        relationships.FATHERS,\n        d\n      );\n    }\n\n    // X is your CHILD\n    else if (tie.predicate === \"is child of\") {\n      childrenTemp = checkAndRemoveDuplicates(childrenTemp, d);\n    }\n\n    // X is your SIBLING\n    else if (\n      tie.predicate === \"is sibling of\" ||\n      tie.predicate === \"is older than\"\n    ) {\n      relationships.SIBLINGS = checkAndRemoveDuplicates(\n        relationships.SIBLINGS,\n        d\n      );\n    }\n\n    // X is your TWIN\n    else if (tie.predicate === \"is twin of\") {\n      relationships.TWIN = checkAndRemoveDuplicates(relationships.TWIN, d);\n    }\n    // X is your WIFE / HUSBAND\n    else if (tie.predicate === \"is spouse of\" || tie.predicate === \"marries\") {\n      relationships.SPOUSES = checkAndRemoveDuplicates(\n        relationships.SPOUSES,\n        d\n      );\n    }\n    // X is a MEMBER of a collective but the main ID\n    else if (tie.predicate === \"is member of\") {\n      members.super = checkAndRemoveDuplicates(members.super, d);\n    } else if (tie.predicate === \"has members\") {\n      members.sub = checkAndRemoveDuplicates(members.sub, d);\n    }\n\n    /*\n     *\n     *     UNUSUAL RELATIONSHIPS\n     *\n     */\n\n    // X is your MOTHER by parthenogenesis\n    else if (tie.predicate === \"is born by autochthony [in/on/at]\") {\n      Oautochthony = { tf: true, passage: tie.passage };\n    } else if (tie.predicate === \"comes into being\") {\n      OcreatedWithoutParents = { tf: true, passage: tie.passage };\n    } else if (tie.predicate === \"creates [agent]\") {\n      relationships.CREATORS = checkAndRemoveDuplicates(\n        relationships.CREATORS,\n        d\n      );\n      OcreatedByAgent = {\n        tf: true,\n        passage: tie.passage,\n        agentID: tie.targetID\n      };\n    } else if (tie.predicate === \"is born from [object]\") {\n      relationships.BORNFROM = checkAndRemoveDuplicates(\n        relationships.BORNFROM,\n        d\n      );\n      ObornFromObject = {\n        tf: true,\n        passage: tie.passage,\n        objectID: tie.targetID\n      };\n    } else if (tie.predicate === \"is mother by parthenogenesis of\") {\n      Oparthenogenesis = { tf: true, passage: tie.passage };\n    } else if (tie.predicate === \"is born from\") {\n      ObornFromObject = { tf: true, passage: tie.passage, objectID: \"\" }; //TODO: Add object info here, and import object\n    } else if (tie.predicate === \"has no children\") {\n      OdiesWithoutChildren = { tf: true, passage: tie.passage };\n    }\n  });\n\n  /* TODO: Check for any indirect siblings in the ties */\n  relationships.SIBLINGS = getIndirectSiblings(\n    id,\n    relationships.MOTHERS,\n    relationships.FATHERS,\n    relationships.SIBLINGS\n  );\n\n  /* Alphabetize the relationships */\n  relationships.MOTHERS = alphabetize(relationships.MOTHERS);\n  relationships.FATHERS = alphabetize(relationships.FATHERS);\n  relationships.SIBLINGS = alphabetize(relationships.SIBLINGS);\n  relationships.TWIN = alphabetize(relationships.TWIN);\n  relationships.SPOUSES = alphabetize(relationships.SPOUSES);\n  relationships.CREATORS = alphabetize(relationships.CREATORS);\n  relationships.BORNFROM = alphabetize(relationships.BORNFROM);\n  members.super = alphabetize(members.super);\n  members.sub = alphabetize(members.sub);\n  // Currently very inefficient, but finds the other parent of the child\n  relationships.CHILDREN = getOtherParents(id, childrenTemp);\n  // relationships.CHILDREN = alphabetizeChildren(relationships.CHILDREN);\n\n  /* Return alphabetized, complete list of relationships */\n\n  let connection: returningInfo = {\n    id: id,\n    relationships: relationships,\n    name: name,\n    members: members,\n    type: type,\n    validSearch: true,\n    unusual: {\n      autochthony: Oautochthony,\n      createdWithoutParents: OcreatedWithoutParents,\n      createdByAgent: OcreatedByAgent,\n      parthenogenesis: Oparthenogenesis,\n      bornFromObject: ObornFromObject,\n      diesWithoutChildren: OdiesWithoutChildren\n    },\n    alternativeName: { targetID: \"\", passage: [] }\n  };\n  return connection;\n};\n\n/******************************************************************************************/\n/* Check passage and entity duplicates                                                    */\n/* -------------------------------------------------------------------------------------- */\n/* This function removes duplicate ties (incl. after reversal) and duplicate passages   */\n/* for the same connected entity                                                          */\n/******************************************************************************************/\nconst checkAndRemoveDuplicates = (entities: any[], d: entityInfo) => {\n  let duplicate = false;\n  entities.forEach(e => {\n    if (e.targetID === d.targetID) {\n      duplicate = true;\n      let passageDuplicate = false;\n      e.passage.forEach(p => {\n        if (\n          p.startID === d.passage[0].startID &&\n          p.endID === d.passage[0].endID\n        ) {\n          passageDuplicate = true;\n        }\n      });\n      if (!passageDuplicate) {\n        e.passage.push(d.passage[0]);\n      }\n    }\n  });\n  if (!duplicate) {\n    entities.push(d);\n  }\n  return entities;\n};\n\nconst checkAndRemoveParentDuplicates = (\n  child: entityInfo, //child to add\n  parentsList: string[], //list of child's parents\n  parentsGrouped: childrenInfo[] //existing parents list to update\n) => {\n  // This function removes duplicates but also groups children by the \"other\" parent\n  // returns childrenInfo object: {child: <list of associated children>, otherParentIDs}\n\n  // If the same child appears under two different \"otherParent\"s, then dispute is expressed\n  // The child will be under {child: <list of children>, otherParents: <list of all parents + disputed>}\n  let parentDuplicate = false;\n  let childDuplicate = false;\n\n  for (let i = 0; i < parentsGrouped.length; i++) {\n    if (isEqual(parentsList, parentsGrouped[i])) {\n      // Is parent duplicate. Now check if child is already in list.\n      parentDuplicate = true;\n      for (let j = 0; j < parentsGrouped[i].child.length; j++) {\n        if (parentsGrouped[i].child[j].targetID === child.targetID) {\n          childDuplicate = true;\n        }\n      }\n      if (!childDuplicate) {\n        parentsGrouped[i].child.push(child);\n      }\n    }\n  }\n\n  if (!childDuplicate && !parentDuplicate) {\n    let newChild: childrenInfo = {\n      child: [child],\n      otherParentIDs: parentsList\n    };\n    parentsGrouped.push(newChild);\n  }\n\n  return parentsGrouped;\n};\n\n/******************************************************************************************/\n/* Alphabetize the list of names in each category                                         */\n/******************************************************************************************/\nconst alphabetize = (relation: any[]) => {\n  if (relation.length === 0) {\n    return [];\n  } else {\n    relation.sort(function(a, b) {\n      var relationA = a.target.toUpperCase();\n      var relationB = b.target.toUpperCase();\n      return relationA < relationB ? -1 : relationA > relationB ? 1 : 0;\n    });\n  }\n  return relation;\n};\n\nconst alphabetizeIDs = (relation: any[]) => {\n  if (relation.length === 0) {\n    return [];\n  } else {\n    relation.sort(function(a, b) {\n      var relationA = a.targetID;\n      var relationB = b.targetID;\n      return relationA < relationB ? -1 : relationA > relationB ? 1 : 0;\n    });\n  }\n  return relation;\n};\n\n/******************************************************************************************/\n/* Check if two arrays are equal                                                          */\n/******************************************************************************************/\nconst isEqual = (parentsList: any[], child: childrenInfo) => {\n  if (parentsList.length !== child.otherParentIDs.length) {\n    return false;\n  } else {\n    for (let i = 0; i < parentsList.length; i++) {\n      if (parentsList[i] !== child.otherParentIDs[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\n/******************************************************************************************/\n/* TODO: Fix this very VERY inefficient method of finding the other parent.               */\n/* Swap for shared NodegoatID                                                             */\n/******************************************************************************************/\nconst getOtherParents = (id: string, children: entityInfo[]) => {\n  let mainGender = getGender(id);\n  let parentsGrouped: childrenInfo[] = [];\n  children.forEach(c => {\n    if (relationships[c.targetID] !== undefined) {\n      var parentsList;\n      if (mainGender === \"Female\") {\n        parentsList = JSON.parse(relationships[c.targetID]).relationships\n          .FATHERS;\n      } else {\n        //temporary solution to undefined gender\n        parentsList = JSON.parse(relationships[c.targetID]).relationships\n          .MOTHERS;\n      }\n      // Convert list of entityInfo to a list of IDs\n      for (let i = 0; i < parentsList.length; i++) {\n        parentsList[i] = parentsList[i].targetID;\n      }\n      parentsList = alphabetizeIDs(parentsList);\n      parentsGrouped = checkAndRemoveParentDuplicates(\n        c,\n        parentsList,\n        parentsGrouped\n      );\n    }\n  });\n  return parentsGrouped;\n};\n\n/******************************************************************************************/\n/* Get the gender of the entity                                                           */\n/******************************************************************************************/\nexport const getGender = (id: string) => {\n  return entities[id] ? entities[id][\"Agent/Coll.: gender\"] : \"\";\n};\n\n/******************************************************************************************/\n/* Tie reversals                                                   */\n/* -------------------------------------------------------------------------------------- */\n/* This function flips the predicate so that X can become the direct object,                   */\n/* without compromising the validity of the tie                                         */\n/*                                                                                        */\n/* e.g. X <is mother of> Y, where Y is <male>                                             */\n/* => returns predicate <is son of>, to let X become the direct object (Y is son of X)         */\n/******************************************************************************************/\nconst reversedPredicate = (predicate: string, dirObject: string) => {\n  // TODO: Fix this temporary solution for gender data not existing for entity\n  // PARENT -> CHILD\n  if (predicate === \"is parent of\") {\n    // Uses generic \"is child of\" since data cards do not show gender specificity for children\n    return \"is child of\";\n  }\n\n  // CHILD -> PARENT\n  else if (predicate === \"is child of\") {\n    if (getGender(dirObject) === \"Female\") {\n      return \"is mother of\";\n    } else if (getGender(dirObject) === \"Male\") {\n      return \"is father of\";\n    } else {\n      // Placeholder since \"is parent of\" is not currently used in data cards\n      return \"\";\n    }\n  }\n\n  // TWIN -> TWIN\n  else if (predicate === \"is twin of\") {\n    return \"is twin of\";\n  }\n\n  // SIBLING -> SIBLING\n  else if (predicate === \"is sibling of\" || predicate === \"is older than\") {\n    return \"is sibling of\";\n  }\n\n  // WIFE -> HUSBAND\n  // HUSBAND -> WIFE\n  // No cases of homosexual relationships in the mythology\n  else if (predicate === \"is spouse of\" || predicate === \"marries\") {\n    return \"is spouse of\";\n  } else if (predicate === \"is member of\" || predicate === \"is part of\") {\n    return \"\";\n  } else {\n    console.log(\n      \"Unsure of \" +\n        predicate +\n        \" \" +\n        dirObject +\n        \" connection, or connection is not relevant for the datacards.\",\n      predicate,\n      dirObject\n    );\n    return \"\";\n  }\n};\n\n/******************************************************************************************/\n/* Populate an array of siblings based on matching parents                                */\n/* -------------------------------------------------------------------------------------- */\n/* This function checks through the list of ties and pushes to the list of siblings:    */\n/*                                                                                        */\n/* e.g. X is <child> of A, X is <child> of B, Y is <child> of A, Y is <child> of B        */\n/******************************************************************************************/\nconst getIndirectSiblings = (\n  id: string,\n  mothers: any[],\n  fathers: any[],\n  siblings: any[]\n) => {\n  // CURRENTLY A VERY SLOW SOLUTION - OPTIMIZE IT LATER\n  // CHANGE TO POPULATING A DATABASE OF RELATIONS AND READING OFF THAT DATABASE\n  // RATHER THAN DYNAMICALLY GENERATING IT HERE (CHANGE TO O(N) NOT LEAVE AS O(N^3))\n  // ALTERNATIVELY: Use Nodegoat ID to determine those in the same datum ID, and then match those\n\n  let newsiblings: {} = {};\n  Object.values(ties).forEach(function(tieRow) {\n    if (typeof tieRow !== \"object\" || tieRow === null) {\n    } else {\n      let testsibling = {\n        motherMatch: false,\n        fatherMatch: false,\n        info: {}\n      };\n      let passageInfo: passageInfo[] = [\n        {\n          start: tieRow[\"Passage: start\"],\n          startID: tieRow[\"Passage: start ID\"],\n          end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n          endID: tieRow[\"Passage: end ID\"]\n        }\n      ];\n      let testinfo: entityInfo = {\n        target: \"\",\n        targetID: \"\",\n        passage: passageInfo,\n        type: entities[id] ? entities[id][\"Type of entity\"] : \"\"\n      };\n      // Firstly, determine where Y is <child> of A,B\n      if (\n        tieRow[\"Predicate\"] === \"is daughter of\" ||\n        tieRow[\"Predicate\"] === \"is son of\" ||\n        tieRow[\"Predicate\"] === \"is child of\"\n      ) {\n        mothers.forEach(m => {\n          if (m.targetID === tieRow[\"Direct Object ID\"]) {\n            testsibling.motherMatch = true;\n            testinfo.target = getName(entities[tieRow[\"Subject ID\"]]);\n            testinfo.targetID = tieRow[\"Subject ID\"];\n            testsibling.info = testinfo;\n            if (!(tieRow[\"Subject ID\"] in newsiblings)) {\n              newsiblings[tieRow[\"Subject ID\"]] = testsibling;\n            } else {\n              newsiblings[tieRow[\"Subject ID\"]].motherMatch = true;\n            }\n          }\n        });\n        fathers.forEach(f => {\n          if (f.targetID === tieRow[\"Direct Object ID\"]) {\n            testsibling.fatherMatch = true;\n            testinfo.target = getName(entities[tieRow[\"Subject ID\"]]);\n            testinfo.targetID = tieRow[\"Subject ID\"];\n            testsibling.info = testinfo;\n            if (!(tieRow[\"Subject ID\"] in newsiblings)) {\n              newsiblings[tieRow[\"Subject ID\"]] = testsibling;\n            } else {\n              newsiblings[tieRow[\"Subject ID\"]].fatherMatch = true;\n            }\n          }\n        });\n      }\n      // Then, determine where A is mother of Y, or if parent of Y where A is female\n      if (\n        tieRow[\"Predicate\"] === \"is mother of\" ||\n        tieRow[\"Predicate\"] === \"is divine mother of\" ||\n        (tieRow[\"Predicate\"] === \"is parent of\" &&\n          entities[tieRow[\"Subject ID\"]] &&\n          entities[tieRow[\"Subject ID\"]][\"Agent/Coll.: gender\"] === \"Female\")\n      ) {\n        mothers.forEach(m => {\n          if (m.targetID === tieRow[\"Subject ID\"]) {\n            testsibling.motherMatch = true;\n            testinfo.target = getName(entities[tieRow[\"Direct Object ID\"]]);\n            testinfo.targetID = tieRow[\"Direct Object ID\"];\n            testsibling.info = testinfo;\n            if (!(tieRow[\"Direct Object ID\"] in newsiblings)) {\n              newsiblings[tieRow[\"Direct Object ID\"]] = testsibling;\n            } else {\n              newsiblings[tieRow[\"Direct Object ID\"]].motherMatch = true;\n            }\n          }\n        });\n      }\n      // Then, determine where A is father of Y, or if parent of Y where A is male\n      if (\n        tieRow[\"Predicate\"] === \"is father of\" ||\n        tieRow[\"Predicate\"] === \"is divine father of\" ||\n        (tieRow[\"Predicate\"] === \"is parent of\" &&\n          entities[tieRow[\"Subject ID\"]] &&\n          entities[tieRow[\"Subject ID\"]][\"Agent/Coll.: gender\"] === \"Male\")\n      ) {\n        fathers.forEach(f => {\n          if (f.targetID === tieRow[\"Subject ID\"]) {\n            testsibling.fatherMatch = true;\n            testinfo.target = getName(entities[tieRow[\"Direct Object ID\"]]);\n            testinfo.targetID = tieRow[\"Direct Object ID\"];\n            testsibling.info = testinfo;\n            if (!(tieRow[\"Direct Object ID\"] in newsiblings)) {\n              newsiblings[tieRow[\"Direct Object ID\"]] = testsibling;\n            } else {\n              newsiblings[tieRow[\"Direct Object ID\"]].fatherMatch = true;\n            }\n          }\n        });\n      }\n    }\n  });\n  let keys: any[] = Object.keys(newsiblings);\n  keys.forEach(k => {\n    if (\n      !newsiblings[k].motherMatch ||\n      !newsiblings[k].fatherMatch ||\n      k === id\n    ) {\n      delete newsiblings[k];\n    } else {\n      siblings = checkAndRemoveDuplicates(siblings, newsiblings[k].info);\n    }\n  });\n  return siblings;\n};\n\n/******************************************************************************************/\n/* Check if no relations exist for this entity (used in DataCards.tsx)                    */\n/******************************************************************************************/\nexport const checkNoRelations = (relationships: any) => {\n  return (\n    relationships.MOTHERS.length === 0 &&\n    relationships.FATHERS.length === 0 &&\n    relationships.SIBLINGS.length === 0 &&\n    relationships.TWIN.length === 0 &&\n    relationships.SPOUSES.length === 0 &&\n    relationships.CHILDREN.length === 0\n  );\n};\n\nexport const checkNoMembers = (members: any) => {\n  return !members || members.length === 0;\n};\n\n/******************************************************************************************/\n/* Return all alternative names for entity (used in DataCards.tsx)                        */\n/******************************************************************************************/\nexport const getAlternativeNames = (id: string) => {\n  let alternatives: string = \"\";\n  alternatives += getNameString(\"Name (transliteration)\", alternatives, id);\n  alternatives += getNameString(\"Name (Greek font)\", alternatives, id);\n  alternatives += getNameString(\"Name (Latinized)\", alternatives, id);\n  alternatives += getNameString(\"Name in Latin texts\", alternatives, id);\n  alternatives += getNameString(\"Alternative names\", alternatives, id);\n\n  if (alternatives === \"\") {\n    return alternatives;\n  } else {\n    return \"(Also known as: \" + alternatives + \")\";\n  }\n};\n\nconst getNameString = (parameter: string, stringSoFar: string, id: string) => {\n  let s = \"\";\n  if (entities[id][parameter] !== \"\") {\n    if (stringSoFar === \"\") {\n      s = entities[id][parameter];\n    } else {\n      s = stringSoFar + \", \" + entities[id][parameter];\n    }\n  }\n  return s;\n};\n\n/******************************************************************************************/\n/* Get the entity's name                                                                  */\n/******************************************************************************************/\nexport const getName = (entityRow: any) => {\n  let possibleNames = [\n    \"Name (house style)\",\n    \"Name (transliteration)\",\n    \"Name (Greek font)\",\n    \"Name (Latinized)\",\n    \"Name in Latin texts\",\n    \"Alternative names\"\n  ];\n  if (entityRow) {\n    for (let i = 0; i < possibleNames.length; i++) {\n      if (\n        entityRow[possibleNames[i]] &&\n        entityRow[possibleNames[i]] !== \"\" &&\n        entityRow[possibleNames[i]] !== undefined\n      ) {\n        return entityRow[possibleNames[i]];\n      }\n      return \"\";\n    }\n  } else {\n    return \"\";\n  }\n};\n\n/******************************************************************************************/\n/* Get the entity type                                                                    */\n/******************************************************************************************/\nexport const getEntityType = (id: string) => {\n  if (entities[id]) {\n    if (entities[id][\"Type of entity\"] === \"Collective (Episodic)\") {\n      return \"Collective (Episodic)\";\n    } else if (entities[id][\"Type of entity\"] === \"Collective (misc.)\") {\n      return \"Collective (Miscellaneous)\";\n    } else if (entities[id][\"Type of entity\"] === \"Collective (genealogical)\") {\n      return \"Collective (Genealogical)\";\n    } else {\n      return \"\";\n    }\n  } else {\n    return \"\";\n  }\n};\n","// template from: https://konvajs.org/docs/react/index.html\n// Refs (stage and components): https://reactjsexample.com/react-binding-to-canvas-element-via-konva-framework/\nimport React, { Component } from \"react\";\nimport Konva from \"konva\";\nimport { Stage, Layer, Star, Text, Rect, Line, Polygon } from \"react-konva\";\nimport relationships from \"./data/relationships.json\";\nimport { getName } from \"./DataCardHandler\";\nimport entities from \"./data/entities.json\";\nimport { formatPrefix } from \"d3\";\n\nclass EntityGraph extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      allShapes: [],\n      stageRef: undefined,\n      graphAttr: {\n        initX: 50,\n        spaceX: 200,\n        nodeWidth: 150,\n        nodeHeight: 80,\n        NegOneY: 100,\n        ZeroY: 400,\n        PosOneY: 700\n      },\n      connectedShapes: [\"edge1\", \"node3\", \"node5\"], // Nodes and links that are connected with each other\n      depthNodes: {\n        depthNegOne: [],\n        depthZero: [],\n        depthPosOne: []\n      },\n      lineLinks: [],\n      entityData: {},\n      id: \"\"\n    };\n    this.getDepthNodes = this.getDepthNodes.bind(this);\n  }\n\n  /*****************************************************\n   *\n   *\n   *   SETUP METHODS\n   *\n   *\n   *****************************************************/\n  componentDidMount() {\n    // log stage react wrapper (reference)\n    console.log(this.refs.stage);\n    // log Konva.Stage instance (reference)\n    console.log(this.refs.stage.getStage());\n    // Get all children from the stage (equiiv. to stage.layers.<allchildren>)\n    // Get the object with the specified name (use \".\"+name)\n    console.log(this.refs.stage.find(\".name1\"));\n    // Use \"each()\" operator to sift through all items in the collection\n    // Use \"each\" here and \"forEach\" everywhere else and when referencinig this.state.allShapes\n    this.refs.stage.children[1].children.each(function(shape) {\n      console.log(\"Test\", shape.attrs.id);\n    });\n    console.log(this.refs.stage.children[1].children);\n    console.log(\"IDs:\", JSON.parse(relationships[this.props.id]));\n    let entityData = JSON.parse(relationships[this.props.id]);\n\n    // Set states\n    this.setState({\n      allShapes: this.refs.stage.children[1].children,\n      stageRef: this.refs.stage,\n      id: this.props.id,\n      entityData: entityData,\n      depthNodes: this.getDepthNodes(entityData)\n    });\n  }\n\n  componentDidUpdate() {\n    if (this.props.id !== this.state.id) {\n      let entityData = JSON.parse(relationships[this.props.id]);\n      let depthNodes = this.getDepthNodes(entityData);\n\n      // Create a connection calculator here\n      let connectionsList = this.getConnectionsList(entityData, this.props.id);\n\n      //Test set for getRelationshipLinks\n      let connections = [\"8189678\", \"8188419\", \"8187829\", \"8182233\"];\n\n      this.setState({\n        id: this.props.id,\n        entityData: entityData,\n        depthNodes: depthNodes,\n        lineLinks: this.geAllLinePoints(depthNodes, connectionsList)\n      });\n    }\n  }\n\n  getRandomPoints = () => {\n    let edge = [];\n    this.state.allShapes.forEach(function(shape) {\n      edge.push(shape.attrs.x + 75);\n      edge.push(shape.attrs.y + 40);\n    });\n    return edge;\n  };\n\n  /*****************************************************\n   *\n   *\n   *   GETTERS AND SETTERS\n   *\n   *\n   *****************************************************/\n\n  /* GET ALL NODES AND THEIR DEPTHS / GENERATION */\n  getDepthNodes = entityData => {\n    let depthNegOne = [],\n      depthZero = [],\n      depthPosOne = [];\n\n    //Parents and step-parents depth -1\n    entityData.relationships.MOTHERS.forEach(m => {\n      depthNegOne.push(m.targetID);\n    });\n    entityData.relationships.FATHERS.forEach(f => {\n      depthNegOne.push(f.targetID);\n    });\n    entityData.relationships.CREATORS.forEach(c => {\n      depthNegOne.push(c.targetID);\n    });\n    entityData.relationships.BORNFROM.forEach(b => {\n      depthNegOne.push(b.targetID);\n    });\n\n    //siblings, twins and spouses depth 0\n    entityData.relationships.SIBLINGS.forEach(s => {\n      depthZero.push(s.targetID);\n    });\n    entityData.relationships.TWIN.forEach(t => {\n      depthZero.push(t.targetID);\n    });\n    entityData.relationships.SPOUSES.forEach(s => {\n      depthZero.push(s.targetID);\n    });\n\n    // + all other parents\n    //children depth +1\n    for (let d = 0; d < entityData.relationships.CHILDREN.length; d++) {\n      entityData.relationships.CHILDREN[d].child.forEach(c => {\n        depthPosOne = this.checkForDuplicates(depthPosOne, c.targetID);\n      });\n      entityData.relationships.CHILDREN[d].otherParentIDs.forEach(p => {\n        depthZero = this.checkForDuplicates(depthZero, p); // NOte that the above deals with entityInfo type, but this (aka. highlighted node) is just ID\n      });\n    }\n\n    depthZero.splice(Math.ceil(depthZero.length / 2), 0, this.props.id); // NOte that the above deals with entityInfo type, but this (aka. highlighted node) is just ID\n    return {\n      depthNegOne: depthNegOne,\n      depthZero: depthZero,\n      depthPosOne: depthPosOne\n    };\n  };\n\n  checkForDuplicates = (arr, e) => {\n    if (arr.includes(e)) {\n      return arr;\n    } else {\n      arr.push(e);\n      return arr;\n    }\n  };\n\n  /* GET THE CONNECTIONS BETWEEN ENTITIES BASED ON THE RELATIONSHIPS GIVEN */\n  /* returns: [{parents: [list of ids], children: [list of ids], pNodeDepth: <depthNegOne, depthZero, depthPosOne>} , {...}] */\n  getConnectionsList = (entityData, id) => {\n    console.log(\"Return\", entityData);\n    let allConnections = [];\n\n    //MOTHER+FATHER -> YOU+SIBLING+TWIN\n    if (\n      entityData.relationships.MOTHERS.length > 0 ||\n      entityData.relationships.FATHERS.length > 0\n    ) {\n      let connection = { parents: [], children: [], pNodeDepth: \"\" };\n      let parentsDepth = entityData.relationships.MOTHERS.concat(\n        entityData.relationships.FATHERS\n      );\n      parentsDepth.forEach(p => {\n        connection.parents.push(p.targetID);\n      });\n      let childrenDepth = entityData.relationships.SIBLINGS.concat(\n        entityData.relationships.TWIN\n      );\n      childrenDepth.forEach(c => {\n        connection.children.push(c.targetID);\n      });\n      connection.children.push(id);\n      connection.pNodeDepth = \"depthNegOne\";\n      allConnections.push(connection);\n    }\n\n    //YOU+OTHERPARENTID -> CHILDREN\n    if (entityData.relationships.CHILDREN.length > 0) {\n      entityData.relationships.CHILDREN.forEach(cp => {\n        let connection = { parents: [], children: [], pNodeDepth: \"\" };\n        cp.child.forEach(c => {\n          connection.children.push(c.targetID);\n        });\n        cp.otherParentIDs.forEach(p => {\n          connection.parents.push(p);\n        });\n        connection.parents.push(id);\n        connection.pNodeDepth = \"depthZero\";\n        allConnections.push(connection);\n      });\n    }\n\n    //Check if spouse is already listed in otherParentIDs in children. If not, means is connection without children.    //TODO: BORN FROM (OBJECT)\n    if (entityData.relationships.SPOUSES.length > 0) {\n      entityData.relationships.SPOUSES.forEach(s => {\n        if (!this.isSpouseRepeated(s.targetID, allConnections)) {\n          allConnections.push({ parents: [id, s.targetID], children: [] });\n          // TODO: Deal with children is empty when spouse without children\n        }\n      });\n    }\n\n    //TODO: CREATED (BY AGENT)\n\n    //TODO: AUTOCHTHONY\n\n    //TODO: CREATED WITHOUT PARENTS\n\n    //TODO: PARTHENOGENESIS\n\n    //TODO: DIES WITHOUT CHILDREN\n\n    console.log(allConnections);\n    return allConnections;\n  };\n\n  /* GET LINE POINTS BASED ON THE LINE CONNECTIONS FOUND */\n\n  // Create an array holding all relationships between entities, parent+parent->children+siblings [[P,P,C,S], [...]]\n  geAllLinePoints = (depthNodes, connections) => {\n    // connections ] [P,P,C,S...]\n\n    // Separate connections by depth\n    // Notice have used all three depths here due to incest possibility\n    /* let d = { depthNegOne: [], depthZero: [], depthPosOne: [] };\n    for (let i = 0; i < connections.length; i++) {\n      if (depthNodes.depthNegOne.includes(connections[i])) {\n        d.depthNegOne.push(connections[i]);\n      } else if (depthNodes.depthZero.includes(connections[i])) {\n        d.depthZero.push(connections[i]);\n      } else if (depthNodes.depthPosOne.includes(connections[i])) {\n        d.depthPosOne.push(connections[i]);\n      } else {\n      }\n    }*/\n\n    let allLinePoints = [];\n\n    /*\n     *    (p1)                  (p2)\n     *     |                     ^ |\n     *     |                     | |\n     *     v                     | v\n     *    (p1L)---------------->(p2L)\n     *               (pM)<---------\n     *                |\n     *                |\n     *                v\n     *  (c1U)<------(cM)     /->(c2U)\n     *    | ^ --------------/     |\n     *    | |                     |\n     *    v |                     v\n     *   (c1)                   (c2)\n     */\n\n    // [P1, P1L, P2L, P2, P2L, PM, CU, C1U, C1, C1U, C2U, C2]\n    //Connect parent nodes\n    // if (d.depthNegOne.length > 0 && d.depthZero.length > 0) {\n    let width = this.state.graphAttr.nodeWidth;\n    let height = this.state.graphAttr.nodeHeight;\n    let diff = 50;\n    let initX = this.state.graphAttr.initX;\n    let spaceX = this.state.graphAttr.spaceX;\n\n    /* TODO: FIX THIS FOR GENERATION-ANONYMOUS */\n    for (let i = 0; i < connections.length; i++) {\n      // connections[INDEX] = {parents: [id1, id2, ...], children: [id1, id2, ...]}\n\n      // TODO: Make the following more efficient\n\n      let linePoints = [];\n\n      let PM_Y = 0,\n        PM_X = 0;\n\n      // Get the depth of the nodes\n      let depth;\n      if (connections[i].pNodeDepth === \"depthNegOne\") {\n        depth = depthNodes.depthNegOne;\n        PM_Y = this.state.graphAttr.NegOneY + height + diff; // Assign PM_Y value here\n      } else {\n        depth = depthNodes.depthZero;\n        PM_Y = this.state.graphAttr.ZeroY + height + diff; // Assign PM_Y value here\n      }\n\n      // Get middle X location first (average of all X values)\n      connections[i].parents.forEach(p => {\n        let pX = initX + depth.indexOf(p) * spaceX;\n        PM_X = PM_X + pX;\n      });\n      PM_X =\n        connections[i].parents.length > 0 // Removes division by 0 error\n          ? (PM_X + width / 2) / connections[i].parents.length\n          : PM_X;\n      console.log(connections[i].parents);\n\n      // Start checking nodes. PM -> PL -> P -> PL -> PM. This joins the lines at the middle point for each connection.\n      connections[i].parents.forEach(p => {\n        let pIndex = depth.indexOf(p);\n        let pY = 0;\n        if (connections[i].pNodeDepth === \"depthNegOne\") {\n          pY = this.state.graphAttr.NegOneY + height;\n        } else {\n          pY = this.state.graphAttr.ZeroY + height;\n        }\n        linePoints.push(PM_X, PM_Y); //PM\n        linePoints.push(initX + pIndex * spaceX + width / 2, PM_Y); //PL\n        linePoints.push(\n          initX + pIndex * spaceX + width / 2,\n          pY //P\n        );\n        linePoints.push(initX + pIndex * spaceX + width / 2, PM_Y); //PL\n        linePoints.push(PM_X, PM_Y); //PM\n      });\n\n      // END AT THE MIDDLE POINT FOR PARENT (PM)\n\n      // For x number of children\n\n      /* let parentOneIndex = depthNodes.depthNegOne.indexOf(\n        connections[i].parents[0]\n      );\n      let parentTwoIndex = depthNodes.depthNegOne.indexOf(\n        connections[i].parents[1]\n      );\n      let childOneIndex = depthNodes.depthZero.indexOf(\n        connections[i].children[0]\n      );\n      let childTwoIndex = depthNodes.depthZero.indexOf(\n        connections[i].children[1]\n      );\n      // X values\n      let P1_X = initX + parentOneIndex * spaceX + width / 2; // P1_X & P1L_X\n      let P2_X = initX + parentTwoIndex * spaceX + width / 2; // P1_Y & P1L_Y\n      let C1_X = initX + childOneIndex * spaceX + width / 2; //C1_X & C2U_X\n      let C2_X = initX + childTwoIndex * spaceX + width / 2; //C2_X & C2U_X\n      // Y values\n      let P_Y = this.state.graphAttr.NegOneY + height; //P1_Y & P2_Y\n      let PL_Y = P_Y + diff; //P1L_Y & P2L_Y & PM_Y\n      let C_Y = this.state.graphAttr.ZeroY; //C1_Y & C2_Y\n      let CU_Y = C_Y - diff; //C1U_Y & C2U_Y & CM_Y\n\n      // Push line\n      let linePoints = [\n        P1_X,\n        P_Y,\n        P1_X,\n        PL_Y,\n        P2_X,\n        PL_Y,\n        P2_X,\n        P_Y,\n        P2_X,\n        PL_Y,\n        PM_X,\n        PL_Y,\n        PM_X,\n        CU_Y,\n        C1_X,\n        CU_Y,\n        C1_X,\n        C_Y,\n        C1_X,\n        CU_Y,\n        C2_X,\n        CU_Y,\n        C2_X,\n        C_Y\n      ];\n      /*  }\n    } else if (d.depthZero.length > 0 && d.depthPosOne.length > 0) {\n    } else {\n      //deal with the intergenerational/incestual relationships here\n    } */\n      allLinePoints.push(linePoints);\n      console.log(\n        \"Connections:\",\n        connections[i],\n        \"and linepoints:\",\n        linePoints\n      );\n    }\n    return allLinePoints;\n  };\n\n  isSpouseRepeated = (sID, allConnections) => {\n    for (let i = 0; i < allConnections.length; i++) {\n      for (let j = 0; j < allConnections[i].length; j++) {\n        if (sID === allConnections[i][j]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  /****************************************************\n   *\n   *\n   *   EVENT HANDLERS\n   *\n   *\n   ****************************************************/\n\n  handleMouseOverNode = e => {\n    document.body.style.cursor = \"pointer\";\n    e.target.to({\n      strokeWidth: 8\n    });\n  };\n  handleMouseOutNode = e => {\n    document.body.style.cursor = \"default\";\n    e.target.to({\n      strokeWidth: 4\n    });\n  };\n\n  handleMouseOverLine = e => {\n    /* if (e.target.attrs.name === \"edge1\") {\n      this.state.connectedShapes.forEach(s => {\n        let item = this.state.stageRef.find(\".\" + s);\n        if (item.length > 0) { \n          item.to({\n            strokeWidth: 8\n          });\n        }\n      });\n    }*/\n    document.body.style.cursor = \"pointer\";\n    e.target.to({\n      strokeWidth: 8\n    });\n  };\n  handleMouseOutLine = e => {\n    /*\n    if (e.target.attrs.name === \"edge1\") {\n      this.state.connectedShapes.forEach(s => {\n        let item = this.state.stageRef.find(\".\" + s);\n        if (item.length > 0) {\n          item.to({\n            strokeWidth: 4\n          });\n        }\n      });\n    } */\n    document.body.style.cursor = \"default\";\n    e.target.to({\n      strokeWidth: 4\n    });\n  };\n\n  handlePageChange = e => {\n    console.log(\"Page change\", e.target.attrs.id);\n    this.props.relationshipClicked(e.target.attrs.id);\n  };\n\n  /****************************************************\n   *\n   *\n   *   RENDERING\n   *\n   *\n   ****************************************************/\n\n  render() {\n    {\n      console.log(this.state.depthNodes);\n    }\n    return (\n      <Stage ref=\"stage\" width={4000} height={2000}>\n        <Layer>\n          {this.state.depthNodes.depthNegOne.map((e, i) => (\n            <Text\n              x={this.state.graphAttr.initX + this.state.graphAttr.spaceX * i}\n              ref=\"text\"\n              y={this.state.graphAttr.NegOneY}\n              text={getName(entities[e])}\n              fontSize={18}\n              fontFamily=\"Calibri\"\n              fontStyle=\"bold\"\n              fill=\"#000\"\n              width={this.state.graphAttr.nodeWidth}\n              height={this.state.graphAttr.nodeHeight}\n              padding={20}\n              align=\"center\"\n            />\n          ))}\n          {this.state.depthNodes.depthZero.map((e, i) => (\n            <Text\n              x={this.state.graphAttr.initX + this.state.graphAttr.spaceX * i}\n              ref=\"text\"\n              y={this.state.graphAttr.ZeroY}\n              text={getName(entities[e])}\n              fontSize={18}\n              fontFamily=\"Calibri\"\n              fontStyle=\"bold\"\n              fill=\"#000\"\n              width={this.state.graphAttr.nodeWidth}\n              height={this.state.graphAttr.nodeHeight}\n              padding={20}\n              align=\"center\"\n            />\n          ))}\n          {this.state.depthNodes.depthPosOne.map((e, i) => (\n            <Text\n              x={this.state.graphAttr.initX + this.state.graphAttr.spaceX * i}\n              ref=\"text\"\n              y={this.state.graphAttr.PosOneY}\n              text={getName(entities[e])}\n              fontSize={18}\n              fontFamily=\"Calibri\"\n              fontStyle=\"bold\"\n              fill=\"#000\"\n              width={this.state.graphAttr.nodeWidth}\n              height={this.state.graphAttr.nodeHeight}\n              padding={20}\n              align=\"center\"\n            />\n          ))}\n        </Layer>\n        <Layer>\n          {this.state.depthNodes.depthNegOne.map((e, i) => (\n            <Rect\n              refs={\"rect\"}\n              id={e}\n              name={\"node\" + i}\n              x={this.state.graphAttr.initX + this.state.graphAttr.spaceX * i}\n              y={this.state.graphAttr.NegOneY}\n              width={this.state.graphAttr.nodeWidth}\n              height={this.state.graphAttr.nodeHeight}\n              stroke=\"#000\"\n              strokeWidth={4}\n              onMouseOver={this.handleMouseOverNode}\n              onMouseOut={this.handleMouseOutNode}\n              onClick={this.handlePageChange}\n            />\n          ))}\n          {this.state.depthNodes.depthZero.map((e, i) => (\n            <Rect\n              refs={\"rect\"}\n              id={e}\n              name={\"node\" + i}\n              x={this.state.graphAttr.initX + this.state.graphAttr.spaceX * i}\n              y={this.state.graphAttr.ZeroY}\n              width={this.state.graphAttr.nodeWidth}\n              height={this.state.graphAttr.nodeHeight}\n              stroke=\"#000\"\n              strokeWidth={4}\n              onMouseOver={this.handleMouseOverNode}\n              onMouseOut={this.handleMouseOutNode}\n              onClick={this.handlePageChange}\n            />\n          ))}\n          {this.state.depthNodes.depthPosOne.map((e, i) => (\n            <Rect\n              refs={\"rect\"}\n              id={e}\n              name={\"node\" + i}\n              x={this.state.graphAttr.initX + this.state.graphAttr.spaceX * i}\n              y={this.state.graphAttr.PosOneY}\n              width={this.state.graphAttr.nodeWidth}\n              height={this.state.graphAttr.nodeHeight}\n              stroke=\"#000\"\n              strokeWidth={4}\n              onMouseOver={this.handleMouseOverNode}\n              onMouseOut={this.handleMouseOutNode}\n              onClick={this.handlePageChange}\n            />\n          ))}\n          {this.state.lineLinks.map((e, i) => (\n            <Line\n              name={\"blah\"}\n              points={e}\n              stroke=\"#000000\"\n              strokeWidth={4}\n              onMouseOver={this.handleMouseOverLine}\n              onMouseOut={this.handleMouseOutLine}\n            />\n          ))}\n        </Layer>\n      </Stage>\n    );\n  }\n}\n\nexport default EntityGraph;\n","import React from \"react\";\nimport \"./App.css\";\nimport \"./DataCards.scss\";\nimport queryString from \"querystring\";\nimport passages from \"./data/passages.json\";\nimport relationships from \"./data/relationships.json\";\nimport EntityGraph from \"./EntityGraph.jsx\";\nimport ReactGA from \"react-ga\";\nimport entities from \"./data/entities.json\";\nimport {\n  relationshipInfo,\n  entityInfo,\n  checkNoRelations,\n  getAlternativeNames,\n  getGender,\n  getName,\n  getEntityType\n} from \"./DataCardHandler\";\nimport Pluralize from \"pluralize\";\n\ntype DatumProps = {\n  location: {\n    search: string;\n  };\n  history: {\n    push: ({}) => null;\n  };\n};\ntype DatumState = {\n  id: string;\n  name: string;\n  relationships: relationshipInfo;\n  members: { sub: any[]; super: any[] };\n  type: string;\n  validSearch: boolean;\n  unusual: {\n    autochthony: { tf: boolean; passage: any[] };\n    createdWithoutParents: { tf: boolean; passage: any[] };\n    createdByAgent: { tf: boolean; passage: any[]; agentID: string };\n    parthenogenesis: { tf: boolean; passage: any[] };\n    bornFromObject: { tf: boolean; passage: any[]; objectID: string };\n    diesWithoutChildren: { tf: boolean; passage: any[] };\n  };\n  alternativeName: { targetID: string; passage: any[] };\n};\n\nclass DataCards extends React.Component<DatumProps, DatumState> {\n  constructor(props: any) {\n    super(props);\n    // Dionysus is 8188175, use to test multiple names\n    // Atreus is 8187873\n    // Theseus is 8188822\n    // Agamemnon is 8182035\n    // Use Clytaimnestra example, 8188055\n    this.state = {\n      id: \"8182035\", // placeholder: Agamemnon\n      name: \"\",\n      relationships: {\n        MOTHERS: [],\n        FATHERS: [],\n        CREATORS: [],\n        BORNFROM: [],\n        SIBLINGS: [],\n        TWIN: [],\n        SPOUSES: [],\n        CHILDREN: []\n      },\n      members: { sub: [], super: [] },\n      type: \"\",\n      validSearch: false,\n      unusual: {\n        autochthony: { tf: false, passage: [] },\n        createdWithoutParents: { tf: false, passage: [] },\n        createdByAgent: { tf: false, passage: [], agentID: \"\" },\n        parthenogenesis: { tf: false, passage: [] },\n        bornFromObject: { tf: false, passage: [], objectID: \"\" },\n        diesWithoutChildren: { tf: false, passage: [] }\n      },\n      alternativeName: { targetID: \"\", passage: [] }\n    };\n    /* this.getNameFromID = this.getNameFromID.bind(this);\n    this.checkNoRelations = this.checkNoRelations.bind(this);\n    this.reversedVerb = this.reversedVerb.bind(this);\n    this.getDataPoints = this.getDataPoints.bind(this); */\n    this.handleNameClicked = this.handleNameClicked.bind(this);\n    // this.handleDisputeClicked = this.handleDisputeClicked.bind(this);\n    /* this.getAlternativeNames = this.getAlternativeNames.bind(this); */\n  }\n\n  /*******************/\n  /* HELPER FUNCTIONS */\n  /*******************/\n\n  getPassageLink(passage: any) {\n    let id = passage.startID;\n    let author: string = passages[id].Author;\n    let title: string = passages[id].Title;\n    let start: string = passages[id].Passage;\n    let end: string = passage.endID;\n\n    // Dealing with multiple URNs\n    let URN: string = \"\";\n    let URNsplit = passages[id][\"CTS URN\"].split(\", \");\n    if (URNsplit.length >= 2) {\n      URN = URNsplit[1];\n    } else {\n      URN = passages[id][\"CTS URN\"];\n    }\n\n    URN = \"https://scaife.perseus.org/reader/\" + URN;\n    if (passage.endID !== \"\") {\n      end = passages[end].Passage;\n      URN = URN + \"-\" + end;\n    }\n    URN = URN + \"/?right=perseus-eng2\";\n\n    return (\n      <span>\n        {\"  (\"}\n        <a\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          href={URN}\n          style={{\n            color: \"grey\",\n            fontSize: \"0.8rem\"\n          }}\n        >\n          {author + \", \"}\n          <span style={{ fontStyle: \"italic\" }}>{title}</span> {start}\n          {start !== end && end !== \"\" ? \"-\" + end : \"\"}\n        </a>\n        {\")\"}\n      </span>\n    );\n  }\n\n  handleNameClicked(targetID: string) {\n    ReactGA.event({\n      category: \"NameClicked\",\n      action: \"User clicked on a name within the data card\"\n    });\n    this.props.history.push(\"/datacards?id=\" + targetID);\n  }\n\n  /* handleDisputeClicked(edge: any, id: string) {\n    console.log(\"edge\", edge, \"id\", id);\n    this.setState({\n      openInfoPage: { showDisputePage: true, showUnusualPage: false }\n    });\n  } */\n\n  removeGrandparentDuplicates(grandparents: entityInfo[], g: entityInfo[]) {\n    //grandparents = the original grandparents list\n    //g = a list of new entities to add\n    for (let i = 0; i < g.length; i++) {\n      let duplicate = false;\n      let duplicateIndex = 0;\n      for (let j = 0; j < grandparents.length; j++) {\n        if (g[i].targetID === grandparents[j].targetID) {\n          duplicate = true;\n          duplicateIndex = j;\n          break;\n        }\n      }\n      if (duplicate) {\n        let newPassages = grandparents[duplicateIndex].passage.concat(\n          g[i].passage\n        );\n        grandparents[duplicateIndex].passage = newPassages;\n      } else {\n        grandparents.push(g[i]);\n      }\n    }\n    return grandparents;\n  }\n\n  getGrandparentDataPoints() {\n    let that = this;\n    let grandparents: entityInfo[] = [];\n    // Check all mother's mother and fathers\n    that.state.relationships.MOTHERS.forEach(m => {\n      grandparents = this.removeGrandparentDuplicates(\n        grandparents,\n        JSON.parse(relationships[m.targetID]).relationships.MOTHERS\n      );\n      grandparents = this.removeGrandparentDuplicates(\n        grandparents,\n        JSON.parse(relationships[m.targetID]).relationships.FATHERS\n      );\n    });\n    that.state.relationships.FATHERS.forEach(f => {\n      grandparents = this.removeGrandparentDuplicates(\n        grandparents,\n        JSON.parse(relationships[f.targetID]).relationships.MOTHERS\n      );\n      grandparents = this.removeGrandparentDuplicates(\n        grandparents,\n        JSON.parse(relationships[f.targetID]).relationships.FATHERS\n      );\n    });\n    //Remove duplicate grandparents\n    for (let i = 0; i < grandparents.length; i++) {\n      for (let j = i + 1; j < grandparents.length; j++) {}\n    }\n    //Add grandparent data points\n    if (grandparents.length > 0) {\n      return (\n        <div style={{ clear: \"both\" }}>\n          <div\n            style={{\n              fontWeight: \"bold\",\n              textTransform: \"uppercase\",\n              float: \"left\",\n              paddingRight: \"1rem\",\n              marginTop: \"0.5rem\"\n            }}\n          >\n            {grandparents.length === 1 ? \"GRANDPARENT:\" : \"GRANDPARENTS:\"}\n          </div>\n          <div style={{ float: \"left\", marginTop: \"0.5rem\" }}>\n            {grandparents.map(entity => {\n              return (\n                <div style={{ margin: \"0\" }}>\n                  <span>\n                    <div\n                      className=\"entity-button\"\n                      onClick={() => this.handleNameClicked(entity.targetID)}\n                    >\n                      <span style={{ textDecoration: \"underline\" }}>\n                        {entity.target}\n                      </span>\n                    </div>\n                    {entity.passage.map(passage => {\n                      return this.getPassageLink(passage);\n                    })}\n                  </span>\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      );\n    } else {\n      return <span></span>;\n    }\n\n    // Create grandparent title data point\n    // Check all mother's mother & father IDs\n    // Check all father's mother  & father IDs\n    // Generate the data points using getDataPoints and getUnusualConnectionsetc. below\n  }\n\n  getPluralization(relationship: string) {\n    if (relationship === \"PART OF\") {\n      return relationship + \": \";\n    } else if (relationship === \"MOTHERS\" || relationship === \"FATHERS\") {\n      return Pluralize.singular(relationship) + \": \";\n    } else if (\n      relationship === \"CHILDREN\" &&\n      this.state.relationships[relationship].length === 1 &&\n      this.state.relationships[relationship][0].child.length > 1\n    ) {\n      return relationship + \": \";\n    } else {\n      if (\n        this.state.relationships[relationship].length === 1 ||\n        this.state.relationships[relationship].length === 0\n      ) {\n        return Pluralize.singular(relationship) + \": \";\n      } else {\n        return relationship + \": \";\n      }\n    }\n  }\n\n  entityNameAndPassage(\n    entity: any,\n    relationship: string,\n    showPassage: boolean\n  ) {\n    return (\n      <div>\n        <div\n          className=\"entity-button\"\n          onClick={() => this.handleNameClicked(entity.targetID)}\n        >\n          {entity !== this.state.relationships[relationship][0] &&\n          relationship !== \"SIBLINGS\" ? (\n            <span>OR </span>\n          ) : (\n            \"\"\n          )}\n          <span style={{ textDecoration: \"underline\" }}>{entity.target}</span>\n        </div>\n        {showPassage\n          ? entity.passage.map(passage => {\n              return this.getPassageLink(passage);\n            })\n          : \"\"}\n      </div>\n    );\n  }\n\n  objectNameAndPassage(entity: any) {\n    return (\n      <div>\n        <div className=\"entity-button\">\n          {entity !== this.state.relationships[\"BORNFROM\"][0] ? (\n            <span>OR </span>\n          ) : (\n            \"\"\n          )}\n          {entity.target}\n        </div>\n        {entity.passage.map(passage => {\n          return this.getPassageLink(passage);\n        })}\n      </div>\n    );\n  }\n\n  getDataPoints(relationship: any) {\n    // FATHER: autochthony, parthenogenesis & multiple fathers\n    if (relationship === \"FATHERS\") {\n      if (this.state.unusual.parthenogenesis.tf) {\n        return (\n          <div style={{ clear: \"both\" }}>\n            <div className=\"relationship-header\">\n              {this.getPluralization(relationship)}\n            </div>\n\n            <div style={{ float: \"left\", marginTop: \"0.5rem\", margin: \"0\" }}>\n              {this.state.relationships[relationship].map(e => {\n                return this.entityNameAndPassage(e, relationship, true);\n              })}\n              {/* parthenogenesis part */}\n              <div className=\"entity-button\">\n                {this.state.relationships[relationship].length === 0\n                  ? \"by parthenogenesis\"\n                  : \"OR by parthenogenesis\"}\n              </div>\n              {this.state.unusual.parthenogenesis.passage.map(passage => {\n                return this.getPassageLink(passage);\n              })}\n            </div>\n          </div>\n        );\n      } else if (this.state.unusual.autochthony.tf) {\n        return (\n          <div style={{ clear: \"both\" }}>\n            <div className=\"relationship-header\">\n              {this.getPluralization(relationship)}\n            </div>\n            <div style={{ float: \"left\", marginTop: \"0.5rem\", margin: \"0\" }}>\n              {this.state.relationships[relationship].map(e => {\n                return this.entityNameAndPassage(e, relationship, true);\n              })}\n              {/* autochthony part */}\n              <div className=\"entity-button\">\n                {this.state.relationships[relationship].length === 0\n                  ? \"by autochthony\"\n                  : \"OR by autochthony\"}\n              </div>\n              {this.state.unusual.autochthony.passage.map(passage => {\n                return this.getPassageLink(passage);\n              })}\n            </div>\n          </div>\n        );\n      } else if (this.state.unusual.createdWithoutParents.tf) {\n        return (\n          <div style={{ clear: \"both\" }}>\n            <div className=\"relationship-header\">\n              {this.getPluralization(relationship)}\n            </div>\n            <div style={{ float: \"left\", marginTop: \"0.5rem\", margin: \"0\" }}>\n              {this.state.relationships[relationship].map(e => {\n                return this.entityNameAndPassage(e, relationship, true);\n              })}\n              {/* created without parents part */}\n              <div className=\"entity-button\">\n                {this.state.relationships[relationship].length === 0\n                  ? \"created without parents\"\n                  : \"OR created without parents\"}\n              </div>\n              {this.state.unusual.createdWithoutParents.passage.map(passage => {\n                return this.getPassageLink(passage);\n              })}\n            </div>\n          </div>\n        );\n      } else if (this.state.relationships[relationship].length > 0) {\n        return (\n          <div style={{ clear: \"both\" }}>\n            <div className=\"relationship-header\">\n              {this.getPluralization(relationship)}\n            </div>\n            <div style={{ float: \"left\", marginTop: \"0.5rem\", margin: \"0\" }}>\n              {this.state.relationships[relationship].map(e => {\n                return this.entityNameAndPassage(e, relationship, true);\n              })}\n            </div>\n          </div>\n        );\n      } else {\n        return <span></span>;\n      }\n    }\n\n    // MOTHER: autochthony, creation without parents\n    else if (relationship === \"MOTHERS\") {\n      if (this.state.unusual.createdWithoutParents.tf) {\n        return (\n          <div style={{ clear: \"both\" }}>\n            <div className=\"relationship-header\">\n              {this.getPluralization(relationship)}\n            </div>\n            <div style={{ float: \"left\", marginTop: \"0.5rem\", margin: \"0\" }}>\n              {this.state.relationships[relationship].map(e =>\n                this.entityNameAndPassage(e, relationship, true)\n              )}\n              <div className=\"entity-button\">\n                {this.state.relationships[relationship].length === 0\n                  ? \"created without parents\"\n                  : \"OR created without parents\"}\n              </div>\n              {this.state.unusual.createdWithoutParents.passage.map(passage => {\n                return this.getPassageLink(passage);\n              })}\n            </div>\n          </div>\n        );\n      } else if (this.state.unusual.autochthony.tf) {\n        return (\n          <div style={{ clear: \"both\" }}>\n            <div className=\"relationship-header\">\n              {this.getPluralization(relationship)}\n            </div>\n            <div style={{ float: \"left\", marginTop: \"0.5rem\", margin: \"0\" }}>\n              {this.state.relationships[relationship].map(e => {\n                return this.entityNameAndPassage(e, relationship, true);\n              })}\n              {/* autochthony part */}\n              <div className=\"entity-button\">\n                {this.state.relationships[relationship].length === 0\n                  ? \"by autochthony\"\n                  : \"OR by autochthony\"}\n              </div>\n              {this.state.unusual.autochthony.passage.map(passage => {\n                return this.getPassageLink(passage);\n              })}\n            </div>\n          </div>\n        );\n      } else if (this.state.relationships[relationship].length > 0) {\n        return (\n          <div style={{ clear: \"both\" }}>\n            <div className=\"relationship-header\">\n              {this.getPluralization(relationship)}\n            </div>\n            <div style={{ float: \"left\", marginTop: \"0.5rem\", margin: \"0\" }}>\n              {this.state.relationships[relationship].map(e => {\n                return this.entityNameAndPassage(e, relationship, true);\n              })}\n            </div>\n          </div>\n        );\n      } else {\n        return <span></span>;\n      }\n    }\n\n    //CREATORS:\n    else if (\n      relationship === \"CREATORS\" &&\n      this.state.relationships[relationship].length > 0\n    ) {\n      return (\n        <div style={{ clear: \"both\" }}>\n          <div className=\"relationship-header\">\n            {this.getPluralization(relationship)}\n          </div>\n          <div style={{ float: \"left\", marginTop: \"0.5rem\", margin: \"0\" }}>\n            {this.state.relationships[relationship].map(e => {\n              return this.entityNameAndPassage(e, relationship, true);\n            })}\n          </div>\n        </div>\n      );\n    }\n\n    //BORN FROM:\n    else if (\n      relationship === \"BORNFROM\" &&\n      this.state.relationships[relationship].length > 0\n    ) {\n      return (\n        <div style={{ clear: \"both\" }}>\n          <div className=\"relationship-header\">BORN FROM: </div>\n          <div style={{ float: \"left\", marginTop: \"0.5rem\", margin: \"0\" }}>\n            {this.state.relationships[relationship].map(e => {\n              return this.objectNameAndPassage(e);\n            })}\n          </div>\n        </div>\n      );\n    }\n\n    //CHILDREN:\n    else if (\n      relationship === \"CHILDREN\" &&\n      (this.state.relationships[relationship].length > 0 ||\n        this.state.unusual.diesWithoutChildren.tf)\n    ) {\n      return (\n        <div style={{ clear: \"both\" }}>\n          <div className=\"relationship-header\">\n            {this.getPluralization(relationship)}\n          </div>\n          <div style={{ float: \"left\", marginTop: \"0.5rem\", margin: \"0\" }}>\n            {this.state.unusual.diesWithoutChildren.tf ? (\n              <div>\n                <div className=\"entity-button\">dies without children</div>\n                {this.state.unusual.diesWithoutChildren.passage.map(passage => {\n                  return this.getPassageLink(passage);\n                })}\n                {this.state.relationships.CHILDREN.length > 0 ? (\n                  <div>OR</div>\n                ) : (\n                  \"\"\n                )}\n              </div>\n            ) : (\n              <span></span>\n            )}\n\n            {this.state.relationships[relationship].map(entity => (\n              <div>\n                <div className=\"entity-child-wrapper\">\n                  <div className=\"entity-child-grouping\">\n                    {this.getChildParentGrouped(entity)}\n                  </div>\n                  {this.getOtherParentText(entity.otherParentIDs)}\n                </div>\n                <p></p>\n              </div>\n            ))}\n          </div>\n        </div>\n      );\n\n      //SPOUSES, TWINS, AND SIBLINGS\n    } else if (\n      (relationship === \"SPOUSES\" ||\n        relationship === \"TWIN\" ||\n        relationship === \"SIBLINGS\") &&\n      this.state.relationships[relationship].length > 0\n    ) {\n      return (\n        <div style={{ clear: \"both\" }}>\n          <div className=\"relationship-header\">\n            {this.getPluralization(relationship)}\n          </div>\n          <div style={{ float: \"left\", marginTop: \"0.5rem\", margin: \"0\" }}>\n            {this.state.relationships[relationship].map(e => {\n              return this.entityNameAndPassage(e, relationship, true);\n            })}\n          </div>\n        </div>\n      );\n    }\n\n    //PART OF (COLLECTIVE)\n    else if (relationship === \"PART OF\") {\n      return (\n        <div style={{ clear: \"both\" }}>\n          <div className=\"relationship-header\">PART OF: </div>\n          <div style={{ float: \"left\", marginTop: \"0.5rem\", margin: \"0\" }}>\n            {this.state.members.super.map(e => {\n              return this.entityNameAndPassage(e, relationship, true);\n            })}\n          </div>\n        </div>\n      );\n    }\n\n    //OTHER UNUSUAL RELATIONSHIP TYPES: CREATORS\n    else {\n      return <div></div>;\n    }\n  }\n\n  getChildParentGrouped(group: any) {\n    return group.child.map(c => {\n      return (\n        <div\n          className=\"entity-child-button\"\n          onClick={() => this.handleNameClicked(c.targetID)}\n        >\n          {c.target}\n        </div>\n      );\n    });\n  }\n\n  getOtherParentText(otherParentIDs: any[]) {\n    if (otherParentIDs.length === 0) {\n      return <div className=\"entity-parent-grouping\"></div>;\n    } else {\n      return (\n        <div className=\"entity-parent-grouping\">\n          with{\" \"}\n          {otherParentIDs.map(pID => {\n            return (\n              <span>\n                <span\n                  className=\"entity-child-button\"\n                  style={{ margin: 0 }}\n                  onClick={() => this.handleNameClicked(pID)}\n                >\n                  {getName(entities[pID])}\n                </span>\n                {otherParentIDs.indexOf(pID) === otherParentIDs.length - 1\n                  ? \"\"\n                  : \" OR \"}\n              </span>\n            );\n          })}\n        </div>\n      );\n    }\n  }\n\n  getCollectiveMembers() {\n    let that = this;\n    if (that.state.members.sub.length !== 0) {\n      return (\n        <div style={{ marginTop: \"3rem\", textAlign: \"center\" }}>\n          <div\n            style={{\n              fontWeight: \"bold\",\n              textTransform: \"uppercase\",\n              textDecoration: \"underline\",\n              marginBottom: \"0.5rem\",\n              marginTop: \"5rem\"\n            }}\n          >\n            MEMBERS:\n          </div>\n          {that.state.members.sub.map(member => {\n            return (\n              <div style={{ margin: \"0\" }}>\n                <span\n                  className=\"collective-button\"\n                  onClick={() => this.handleNameClicked(member.targetID)}\n                >\n                  {member.target}\n                </span>\n                {member.passage.map(passage => {\n                  return this.getPassageLink(passage);\n                })}\n              </div>\n            );\n          })}\n        </div>\n      );\n    }\n  }\n\n  getCollectiveSubheading(id: string) {\n    let relation = getGender(id) === \"Female\" ? \"daughters\" : \"sons\";\n    // How to deal with multiple of the same ID in the entities?\n    let parents = getName(\n      entities[entities[id][\"Collective (geneal.): children of ID\"]]\n    );\n    let otherParents = \"\";\n    if (entities[id][\"Other collective parent ID\"]) {\n      otherParents = getName(\n        entities[entities[id][\"Other collective parent ID\"]]\n      );\n    }\n    let divineParents = \"\";\n    if (entities[id][\"Collective (geneal.): divine father ID\"]) {\n      divineParents = getName(\n        entities[entities[id][\"Collective (geneal.): divine father ID\"]]\n      );\n    }\n    /* let parents: { mothers: string; fathers: string } = {\n      mothers: \"\",\n      fathers: \"\"\n    };\n    for (let i = 0; i < this.state.relationships.MOTHERS.length; i++) {\n      if (parents.mothers === \"\") {\n        parents.mothers = this.state.relationships.MOTHERS[i].target;\n      } else {\n        parents.mothers =\n          parents.mothers + \" OR \" + this.state.relationships.MOTHERS[i].target;\n      }\n    }\n    for (let i = 0; i < this.state.relationships.FATHERS.length; i++) {\n      if (parents.fathers === \"\") {\n        parents.fathers = this.state.relationships.FATHERS[i].target;\n      } else {\n        parents.fathers =\n          parents.fathers + \" OR \" + this.state.relationships.FATHERS[i].target;\n      }\n    }\n    let finalString = \"\";\n    if (parents.mothers !== \"\" && parents.fathers !== \"\") {\n      finalString = parents.mothers + \" and \" + parents.fathers;\n    } else if (parents.mothers !== \"\" && parents.fathers === \"\") {\n      finalString = parents.mothers;\n    } else if (parents.mothers === \"\" && parents.fathers !== \"\") {\n      finalString = parents.fathers;\n    } else {\n    } */\n\n    return (\n      <div id=\"datacard-alternativename\">\n        The {relation} of{\" \"}\n        <span\n          style={{ textDecoration: \"underline\", cursor: \"pointer\" }}\n          onClick={() =>\n            this.handleNameClicked(\n              entities[id][\"Collective (geneal.): children of ID\"]\n            )\n          }\n        >\n          {getName(\n            entities[entities[id][\"Collective (geneal.): children of ID\"]]\n          )}\n        </span>\n        {otherParents === \"\" ? (\n          \"\"\n        ) : (\n          <span>\n            {\" \"}\n            OR{\" \"}\n            <span\n              style={{ textDecoration: \"underline\", cursor: \"pointer\" }}\n              onClick={() =>\n                this.handleNameClicked(\n                  entities[id][\"Other collective parent ID\"]\n                )\n              }\n            >\n              {getName(entities[entities[id][\"Other collective parent ID\"]])}\n            </span>\n          </span>\n        )}{\" \"}\n        {divineParents === \"\" ? (\n          \"\"\n        ) : (\n          <span>\n            {\" \"}\n            OR{\" \"}\n            <span\n              style={{ textDecoration: \"underline\", cursor: \"pointer\" }}\n              onClick={() =>\n                this.handleNameClicked(\n                  entities[id][\"Collective (geneal.): divine father ID\"]\n                )\n              }\n            >\n              {getName(\n                entities[entities[id][\"Collective (geneal.): divine father ID\"]]\n              )}\n            </span>\n          </span>\n        )}\n      </div>\n    );\n  }\n\n  getAlternativePage() {\n    if (\n      this.state.alternativeName.targetID !== \"\" &&\n      this.state.alternativeName.passage !== []\n    ) {\n      return (\n        <div\n          id=\"datacard-alternativename\"\n          className={\n            this.state.alternativeName.targetID === \"\" ||\n            this.state.alternativeName.passage === []\n              ? \"no-display\"\n              : \"\"\n          }\n        >\n          Alternative name for{\" \"}\n          {this.state.alternativeName.targetID === \"\" ? (\n            \"\"\n          ) : (\n            <span>\n              <span\n                className=\"entity-alt-button\"\n                onClick={() =>\n                  this.handleNameClicked(this.state.alternativeName.targetID)\n                }\n              >\n                {getName(entities[this.state.alternativeName.targetID])}\n              </span>\n              {this.state.alternativeName.passage.map(passage => {\n                return this.getPassageLink(passage);\n              })}\n            </span>\n          )}\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  /*******************/\n  /* SETUP FUNCTIONS */\n  /*******************/\n\n  componentDidMount() {\n    const params = queryString.parse(this.props.location.search.slice(1));\n    const id = params.id as string;\n    if (!params.id) {\n      // Handle bad url\n      //@ts-ignore\n      this.setState({ validSearch: false });\n    } else {\n      //Substitute with ID\n      let newState = JSON.parse(relationships[id]);\n      this.setState({\n        id: newState.id,\n        relationships: newState.relationships,\n        members: newState.members,\n        name: newState.name,\n        type: newState.type,\n        validSearch: newState.validSearch,\n        alternativeName: newState.alternativeName,\n        unusual: newState.unusual\n      });\n    }\n  }\n\n  componentDidUpdate() {\n    const params = queryString.parse(this.props.location.search.slice(1));\n    const id = params.id as string;\n    if (!params.id) {\n      // Handle bad url\n      //@ts-ignore\n      this.setState({ validSearch: false });\n    } else if (this.state.id !== id) {\n      //Substitute with ID\n      let newState = JSON.parse(relationships[id]);\n      this.setState({\n        id: newState.id,\n        relationships: newState.relationships,\n        members: newState.members,\n        name: newState.name,\n        type: newState.type,\n        validSearch: newState.validSearch,\n        alternativeName: newState.alternativeName,\n        unusual: newState.unusual\n      });\n    }\n  }\n\n  /*************/\n  /* RENDERING */\n  /*************/\n\n  render() {\n    return (\n      <React.Fragment>\n        <div\n          className={this.state.validSearch ? \"no-display\" : \"\"}\n          style={{ textAlign: \"center\", padding: \"3rem\" }}\n        >\n          No profiles have been selected. Try using the Search function.\n        </div>\n        <div className={this.state.validSearch ? \"\" : \"no-display\"}>\n          <div\n            style={{\n              margin: \"1rem 6rem 3rem 6rem\",\n              padding: \"3rem\",\n              display: \"flow-root\",\n              border: \"solid 1px black\"\n            }}\n          >\n            <div style={{ textAlign: \"center\" }}>\n              {/* getEntityType(this.state.id)*/}\n            </div>\n            <div id=\"datacard-heading\">{this.state.name}</div>\n            <div id=\"datacard-othernames\">\n              {getAlternativeNames(this.state.id)}\n            </div>\n            <div id=\"datacard-mantoID\">MANTO ID: {this.state.id}</div>\n            <div\n              id=\"datacard-othernames\"\n              className={getGender(this.state.id) === \"\" ? \"no-display\" : \"\"}\n            >\n              Gender: {getGender(this.state.id)}\n            </div>\n            <p></p>\n            {/* If no data is available for the subject */}\n            <div\n              className={\n                checkNoRelations(this.state.relationships) ? \"\" : \"no-display\"\n              }\n            ></div>\n            {/* If current entity is an alternative name for an existing entity */}\n            <div>{this.getAlternativePage()}</div>\n            {/* If data is available for the subject */}\n            {this.state.relationships[\"MOTHERS\"].length +\n              this.state.relationships[\"FATHERS\"].length >\n            0 ? (\n              <div>{this.getGrandparentDataPoints()}</div>\n            ) : (\n              \"\"\n            )}\n            {entities[this.state.id][\"Type of entity\"] ===\n            \"Collective (genealogical)\"\n              ? this.getCollectiveSubheading(this.state.id)\n              : Object.keys(this.state.relationships).map(key => {\n                  return <div key={key}>{this.getDataPoints(key)}</div>;\n                })}\n            <div></div>\n            {this.state.members.super.length !== 0 ? (\n              <div>{this.getDataPoints(\"PART OF\")}</div>\n            ) : (\n              \"\"\n            )}\n            <div>{this.getCollectiveMembers()}</div>\n          </div>\n        </div>\n        <div\n          className={\n            entities[this.state.id][\"Type of entity\"] === \"Agent\"\n              ? \"\"\n              : \"no-display\"\n          }\n        >\n          {/* <EntityGraph\n            id={this.state.id}\n            relationshipClicked={this.handleNameClicked}\n            // disputeClicked={this.handleDisputeClicked}\n          ></EntityGraph> */}\n          <EntityGraph\n            relationshipClicked={this.handleNameClicked}\n            id={this.state.id}\n            unusual={this.state.unusual}\n          />\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default DataCards;\n","import React from \"react\";\nimport \"./App.css\";\nimport \"./Modal.scss\";\nimport Header from \"./Header\";\nimport Search from \"./Search\";\nimport DataCards from \"./DataCards\";\nimport ReactGA from \"react-ga\";\n\nimport {\n  HashRouter as Router,\n  Route,\n  Link,\n  Switch,\n  Redirect\n} from \"react-router-dom\";\n\nclass App extends React.Component<{}, { subjectID: string; show: boolean }> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      subjectID: \"\",\n      show: false\n    };\n  }\n\n  changeEntity(ID: string) {\n    this.setState({ subjectID: ID });\n  }\n\n  toggleModalState() {\n    if (this.state.show) {\n      this.setState({ show: false });\n    } else {\n      this.setState({\n        show: true\n      });\n    }\n  }\n\n  initializeReactGA() {\n    ReactGA.initialize(\"UA-151993194-1\");\n    ReactGA.pageview(\"/homepage\");\n  }\n\n  render() {\n    return (\n      <div className=\"homepageBackground\">\n        {/* Modal instructions popup */}\n        <div\n          style={{ margin: \"2rem 0 0 1rem\" }}\n          onClick={() => this.toggleModalState()}\n        >\n          <img\n            src={require(\"./images/help.png\")}\n            alt=\"How to use\"\n            className=\"help-icon\"\n          ></img>\n        </div>\n        <div className={this.state.show ? \"modal-body\" : \"no-display\"}>\n          <div>Testing me</div>\n          <div>\n            <button onClick={() => this.toggleModalState()}>Close</button>\n          </div>\n        </div>\n\n        {/* Router links */}\n        <Router>\n          <div style={{ paddingTop: \"4rem\", textAlign: \"center\" }}>\n            <Link to=\"/\">\n              <Header></Header>\n            </Link>\n          </div>\n\n          <Search></Search>\n          {/* <div style={{ marginLeft: \"3rem\" }}>\n            How to use the search tool:\n            <ol>\n              <li>Type the name of the entity requested in the field. </li>\n              <li>Click the entity that matches the request</li>\n              <li>\n                Press enter or click the arrow on the right of the search bar\n              </li>\n            </ol>\n            For information on how to use the data cards themselves, see this\n            page\n          </div> */}\n          <Switch>\n            {/* <Route exact path=\"/\" component={Home} /> */}\n            <Route path=\"/search\" component={Search} />\n            <Route path=\"/datacards\" component={DataCards} />\n            <Route component={() => <Redirect to=\"/\" />} />\n          </Switch>\n          <div style={{ textAlign: \"center\" }}></div>\n        </Router>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/arrow.1cd80763.svg\";","module.exports = __webpack_public_path__ + \"static/media/logo.1740fffd.svg\";"],"sourceRoot":""}