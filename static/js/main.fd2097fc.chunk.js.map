{"version":3,"sources":["images/arrow.svg","images/logo.svg","Header.tsx","Search.tsx","DataCardHandler.ts","GraphHandler.ts","EntityGraph.tsx","DataCards.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Header","style","paddingTop","textAlign","src","require","alt","width","Search","props","pageRedirect","state","redirect","to","targetID","handleSearch","bind","handleSearchKeyDown","getDescriptors","id","this","hasKey","entities","alternatives","ReactGA","event","category","action","currentInput","document","getElementById","value","split","currentInputName","trim","setState","which","keyCode","obj","key","Fragment","margin","placeholder","list","onKeyDown","fontSize","maxHeight","Object","values","map","entity","arrow","onClick","className","React","Component","familyDatums","updateComponent","connections","getAllConnections","sortConnectionsIntoRelationships","datum","forEach","datumRow","includes","Verb","passageInfo","start","startID","end","endID","genderData","gender","push","target","verb","passage","reversedVerb","name","type","members","relationships","MOTHERS","FATHERS","SIBLINGS","TWIN","WIVES","HUSBANDS","CHILDREN","d","checkAndRemoveDuplicates","alphabetize","validSearch","entityDuplicate","e","passageDuplicate","p","relation","length","sort","a","b","relationA","toUpperCase","relationB","dirObject","console","log","getNameString","parameter","stringSoFar","s","getAllLinks","g","depth","setNode","i","r","setEdge","edges","v","EntityGraph","Graph","getGraph","DataCards","author","passages","Author","title","Title","Passage","URN","URNsplit","rel","href","color","fontStyle","history","relationship","clear","fontWeight","textTransform","float","paddingRight","Pluralize","singular","handleNameClicked","getPassageLink","marginTop","textDecoration","marginBottom","member","params","queryString","parse","location","search","slice","newState","padding","display","border","getAlternativeNames","keys","getDataPoints","getCollectiveMembers","App","subjectID","ID","initialize","pageview","backgroundColor","height","path","component","Boolean","window","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.fd2097fc.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/arrow.1cd80763.svg\";","module.exports = __webpack_public_path__ + \"static/media/logo.1740fffd.svg\";","import React from \"react\";\nimport \"./App.css\";\n\nconst Header: React.FC = () => {\n  return (\n    <div style={{ paddingTop: \"4rem\", textAlign: \"center\" }}>\n      <img\n        src={require(\"./images/logo.svg\")}\n        alt=\"Manto logo\"\n        style={{ width: \"20%\" }}\n      ></img>\n    </div>\n  );\n};\n\nexport default Header;\n","import React from \"react\";\nimport \"./App.css\";\nimport entities from \"./data/entities.json\";\nimport { Redirect } from \"react-router-dom\";\nimport arrow from \"./images/arrow.svg\";\nimport ReactGA from \"react-ga\";\n\ntype SearchProps = {};\ntype SearchState = {\n  redirect: boolean;\n  targetID: string;\n};\n\nclass Search extends React.Component<SearchProps, SearchState> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      redirect: false,\n      targetID: \"\"\n    };\n    // this.onSearchSubmit = this.onSearchSubmit.bind(this);\n    this.handleSearch = this.handleSearch.bind(this);\n    this.handleSearchKeyDown = this.handleSearchKeyDown.bind(this);\n    this.getDescriptors = this.getDescriptors.bind(this);\n  }\n\n  getDescriptors(id: string) {\n    if (this.hasKey(entities, id)) {\n      let alternatives: string = \"\";\n      if (entities[id][\"Name (transliteration)\"] !== \"\") {\n        alternatives =\n          alternatives + \", \" + entities[id][\"Name (transliteration)\"];\n      }\n      if (entities[id][\"Name (Latinized)\"] !== \"\") {\n        alternatives = alternatives + \", \" + entities[id][\"Name (Latinized)\"];\n      }\n      if (entities[id][\"Name in Latin texts\"] !== \"\") {\n        alternatives =\n          alternatives + \", \" + entities[id][\"Name in Latin texts\"];\n      }\n      if (entities[id][\"Alternative names\"] !== \"\") {\n        alternatives = alternatives + \", \" + entities[id][\"Alternative names\"];\n      }\n      let inputText =\n        entities[id][\"Name (Smith & Trzaskoma)\"] +\n        alternatives +\n        \": \" +\n        entities[id][\"Identifying information\"];\n      return inputText;\n    }\n  }\n\n  pageRedirect = () => {\n    if (this.state.redirect) {\n      return <Redirect to={\"/datacards?id=\" + this.state.targetID} />;\n    }\n  };\n\n  handleSearch() {\n    ReactGA.event({\n      category: \"Search\",\n      action: \"User searched for an entity using the search bar\"\n    });\n    let currentInput = document.getElementById(\"input\") as HTMLInputElement;\n    if (currentInput.value !== \"\") {\n      //Search based on name and identifying information - super inefficient. TODO: fix this\n      for (let id in entities) {\n        if (this.hasKey(entities, id)) {\n          if (\n            entities[id][\"Identifying information\"] ===\n            currentInput.value.split(\": \")[1]\n          ) {\n            let currentInputName = currentInput.value\n              .split(\": \")[0]\n              .split(\",\")[0]\n              .trim();\n\n            if (\n              currentInputName === entities[id][\"Name (Smith & Trzaskoma)\"] ||\n              currentInputName === entities[id][\"Name (transliteration)\"] ||\n              currentInputName === entities[id][\"Name (Latinized)\"] ||\n              currentInputName === entities[id][\"Name in Latin texts\"] ||\n              currentInputName === entities[id][\"Alternative names\"]\n            ) {\n              this.setState({\n                redirect: true,\n                targetID: id\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n\n  handleSearchKeyDown(event: any) {\n    if (event.which === 13 || event.keyCode === 13) {\n      this.handleSearch();\n    }\n  }\n\n  /* Addresses typescript indexing objects error */\n  hasKey<O>(obj: O, key: keyof any): key is keyof O {\n    return key in obj;\n  }\n\n  render() {\n    /* const entitiesArray = Object.values(entities).map(entity => {\n      return {\n        // what to show to the user\n        label: entity.ID + \": \" + this.getDescriptors(entity.ID),\n        // key to identify the item within the array\n        key: entity.ID\n      };\n    }); */\n    return (\n      <React.Fragment>\n        {/* <h3 style={{ textAlign: \"center\" }}>SEARCH</h3> */}\n        {this.pageRedirect()}\n        <div\n          style={{\n            margin: \"1rem 0 1rem 0\",\n            textAlign: \"center\"\n          }}\n        >\n          {/* <DataListInput\n          placeholder={\"Search by entity name...\"}\n          items={entitiesArray}\n          onSelect={this.pageRedirect}\n          match={this.matchCurrentInput}\n        /> */}\n          <input\n            // type=\"search\"\n            placeholder=\"Search by name\"\n            id=\"input\"\n            list=\"entities\"\n            onKeyDown={this.handleSearchKeyDown}\n            style={{ width: \"50%\", textAlign: \"center\", fontSize: \"1rem\" }}\n          ></input>\n          <datalist id=\"entities\" style={{ maxHeight: \"100px\" }}>\n            {Object.values(entities).map(entity => {\n              return (\n                <option\n                  value={this.getDescriptors(entity[\"\\ufeffID\"])}\n                ></option>\n              );\n            })}\n          </datalist>\n          <div>\n            <img\n              alt=\"Submit search\"\n              src={arrow}\n              onClick={this.handleSearch}\n              className=\"search-arrow\"\n            ></img>\n          </div>\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default Search;\n","import datum from \"./data/datum.json\";\nimport entities from \"./data/entities.json\";\nimport genderData from \"./data/genderData.json\";\n\ntype passageInfo = {\n  start: string;\n  startID: string;\n  end: string;\n  endID: string;\n};\n\ntype entityInfo = {\n  target: string;\n  targetID: string;\n  passage: passageInfo[];\n  type: string;\n};\n\nexport type relationshipInfo = {\n  MOTHERS: entityInfo[];\n  FATHERS: entityInfo[];\n  SIBLINGS: entityInfo[];\n  TWIN: entityInfo[];\n  WIVES: entityInfo[];\n  HUSBANDS: entityInfo[];\n  CHILDREN: entityInfo[];\n};\n\nlet familyDatums = [\n  /* Parent */\n  \"is father of\",\n  \"is mother of\",\n  \"is parent of\",\n  /* Child */\n  \"is child of\",\n  \"is son of\",\n  \"is daughter of\",\n  /* Sibling */\n  \"is sister of\",\n  \"is brother of\",\n  \"is twin of\",\n  \"is older than\",\n  /* Spouse */\n  \"is wife of\",\n  \"is husband of\",\n  \"marries\",\n  \"gives in marriage [dir. obj.] [ind. obj.]\",\n  /* Ancestors - currently unused\n  \"is grandfather of\",\n  \"is grandmother of\",\n  \"is grandparent of\",\n  \"is grandson of\",\n  \"is granddaughter of\",\n  \"is grandchild of\",\n  */\n\n  /* Member of collective */\n  \"is part of\"\n];\n\n/******************************************************************************************/\n/* Returns the data card geneology information, interfaces with DataCards.tsx                \n/******************************************************************************************/\nexport const updateComponent = (id: string) => {\n  let connections = getAllConnections(id);\n  return sortConnectionsIntoRelationships(id, connections);\n};\n\n/******************************************************************************************/\n/* Find all relationships                                                                 */\n/* -------------------------------------------------------------------------------------- */\n/* This function changes all datums (X <verb> Y, Y <verb> X, Z <verb> Y X) to Y <verb> X. */\n/******************************************************************************************/\nconst getAllConnections = (id: string) => {\n  var connections: {\n    target: string;\n    targetID: string;\n    verb: string;\n    passage: passageInfo[];\n  }[] = [];\n\n  Object.values(datum).forEach(function(datumRow) {\n    // TODO: Fix this temporary solution for entities not existing in entities.csv\n    if (entities[datumRow[\"Subject ID\"]]) {\n      /*********************************************************/\n      /* If you are the direct object X, e.g. (Y (verb) X)     */\n      /*********************************************************/\n      if (\n        datumRow[\"Direct Object ID\"] === id &&\n        familyDatums.includes(datumRow.Verb)\n      ) {\n        let passageInfo: passageInfo[] = [\n          {\n            start: datumRow[\"Passage: start\"],\n            startID: datumRow[\"Passage: start ID\"],\n            end:\n              datumRow[\"Passage: end\"] === \"\" ? \"\" : datumRow[\"Passage: end\"],\n            endID: datumRow[\"Passage: end ID\"]\n          }\n        ];\n\n        // Genderized marriage for simplicity (WIFE vs HUSBAND in data card)\n        // TODO: Fix this temporary solution for gender data not existing for entity\n        if (genderData[datumRow[\"Subject ID\"]] && datumRow.Verb === \"marries\") {\n          if (genderData[datumRow[\"Subject ID\"]].gender === \"female\") {\n            datumRow.Verb = \"is wife of\";\n          } else if (genderData[datumRow[\"Subject ID\"]].gender === \"male\") {\n            datumRow.Verb = \"is husband of\";\n          }\n        }\n\n        // Push connections to the list of connections\n        connections.push({\n          target: entities[datumRow[\"Subject ID\"]][\"Name (Smith & Trzaskoma)\"],\n          targetID: datumRow[\"Subject ID\"],\n          verb: datumRow.Verb,\n          passage: passageInfo\n        });\n      }\n\n      /*********************************************************/\n      /* If you are the subject X, e.g. (X (verb) Y)           */\n      /*********************************************************/\n      if (\n        datumRow[\"Subject ID\"] === id &&\n        familyDatums.includes(datumRow.Verb)\n      ) {\n        let passageInfo: passageInfo[] = [\n          {\n            start: datumRow[\"Passage: start\"],\n            startID: datumRow[\"Passage: start ID\"],\n            end:\n              datumRow[\"Passage: end\"] === \"\" ? \"\" : datumRow[\"Passage: end\"],\n            endID: datumRow[\"Passage: end ID\"]\n          }\n        ];\n\n        // Push connections to the list of connections\n        connections.push({\n          target:\n            entities[datumRow[\"Direct Object ID\"]][\"Name (Smith & Trzaskoma)\"],\n          targetID: datumRow[\"Direct Object ID\"],\n          verb: reversedVerb(datumRow.Verb, datumRow[\"Direct Object ID\"]),\n          passage: passageInfo\n        });\n      }\n\n      /*********************************************************/\n      /* If you are the indirect object X, e.g. (Z (verb) Y X)\n    /*********************************************************/\n\n      // TODO: Fix this for using Indirect Object ID not name\n      if (\n        datumRow[\"Indirect Object (to/for)\"] === id &&\n        familyDatums.includes(datumRow.Verb)\n      ) {\n        let passageInfo: passageInfo[] = [\n          {\n            start: datumRow[\"Passage: start\"],\n            startID: datumRow[\"Passage: start ID\"],\n            end:\n              datumRow[\"Passage: end\"] === \"\" ? \"\" : datumRow[\"Passage: end\"],\n            endID: datumRow[\"Passage: end ID\"]\n          }\n        ];\n        connections.push({\n          target:\n            entities[datumRow[\"Direct Object ID\"]][\"Name (Smith & Trzaskoma)\"],\n          targetID: datumRow[\"Direct Object ID\"],\n          verb: reversedVerb(datumRow.Verb, datumRow[\"Direct Object ID\"]),\n          passage: passageInfo\n        });\n      }\n    }\n  });\n  return connections;\n};\n\n/******************************************************************************************/\n/* Sort relationships                                                                     */\n/* -------------------------------------------------------------------------------------- */\n/* This function sorts all of the found connections into existing geneological categories */\n/******************************************************************************************/\nconst sortConnectionsIntoRelationships = (id: string, connections: any) => {\n  /* Preliminary info about the entity */\n  let name = entities[id][\"Name (Smith & Trzaskoma)\"];\n  let type = entities[id][\"Type of entity\"];\n  let members: any[] = [];\n  let relationships: relationshipInfo = {\n    MOTHERS: [],\n    FATHERS: [],\n    SIBLINGS: [],\n    TWIN: [],\n    WIVES: [],\n    HUSBANDS: [],\n    CHILDREN: []\n  };\n\n  connections.forEach(datum => {\n    // For each of the connections already found,\n    // build the associated entity object, and\n    // populate with existing information\n    let d: entityInfo = {\n      target: datum.target,\n      targetID: datum.targetID,\n      passage: datum.passage,\n      type: entities[datum.targetID][\"Type of entity\"]\n    };\n\n    /* Categorising the connections, also checking for duplicates */\n\n    // X is your MOTHER\n    if (datum.verb === \"is mother of\") {\n      // If passage is a duplicate / already exists\n      // for this entity, or  in the list of connections\n      relationships.MOTHERS = checkAndRemoveDuplicates(\n        relationships.MOTHERS,\n        d\n      );\n    }\n\n    // X is your FATHER\n    else if (datum.verb === \"is father of\") {\n      relationships.FATHERS = checkAndRemoveDuplicates(\n        relationships.FATHERS,\n        d\n      );\n    }\n\n    // X is your CHILD\n    else if (\n      datum.verb === \"is son of\" ||\n      datum.verb === \"is daughter of\" ||\n      datum.verb === \"is child of\"\n    ) {\n      relationships.CHILDREN = checkAndRemoveDuplicates(\n        relationships.CHILDREN,\n        d\n      );\n    }\n\n    // X is your SIBLING\n    else if (\n      datum.verb === \"is sister of\" ||\n      datum.verb === \"is brother of\" ||\n      datum.verb === \"is older than\"\n    ) {\n      relationships.SIBLINGS = checkAndRemoveDuplicates(\n        relationships.SIBLINGS,\n        d\n      );\n    }\n\n    // X is your TWIN\n    else if (datum.verb === \"is twin of\") {\n      relationships.TWIN = checkAndRemoveDuplicates(relationships.TWIN, d);\n\n      // X is your WIFE / HUSBAND\n    } else if (datum.verb === \"is wife of\") {\n      relationships.WIVES = checkAndRemoveDuplicates(relationships.WIVES, d);\n    } else if (datum.verb === \"is husband of\") {\n      relationships.HUSBANDS = checkAndRemoveDuplicates(\n        relationships.HUSBANDS,\n        d\n      );\n    } else if (datum.verb === \"marries\") {\n      if (genderData) {\n        if (genderData[datum.targetID].gender === \"female\") {\n          relationships.WIVES = checkAndRemoveDuplicates(\n            relationships.WIVES,\n            d\n          );\n        } else if (genderData[datum.targetID].gender === \"male\") {\n          relationships.HUSBANDS = checkAndRemoveDuplicates(\n            relationships.HUSBANDS,\n            d\n          );\n        }\n      }\n\n      // X is a MEMBER of a collective\n    } else if (datum.verb === \"is part of\") {\n      members = checkAndRemoveDuplicates(members, d);\n    }\n  });\n\n  /* Alphabetize the relationships */\n  relationships.MOTHERS = alphabetize(relationships.MOTHERS);\n  relationships.FATHERS = alphabetize(relationships.FATHERS);\n  relationships.SIBLINGS = alphabetize(relationships.SIBLINGS);\n  relationships.TWIN = alphabetize(relationships.TWIN);\n  relationships.WIVES = alphabetize(relationships.WIVES);\n  relationships.HUSBANDS = alphabetize(relationships.HUSBANDS);\n  relationships.CHILDREN = alphabetize(relationships.CHILDREN);\n  members = alphabetize(members);\n\n  /* Return alphabetized, complete list of relationships */\n  return {\n    id: id,\n    relationships: relationships,\n    name: name,\n    members: members,\n    type: type,\n    validSearch: true\n  };\n};\n\n/******************************************************************************************/\n/* Check passage and entity duplicates                                                    */\n/* -------------------------------------------------------------------------------------- */\n/* This function removes duplicate datums (incl. after reversal) and duplicate passages   */\n/* for the same connected entity                                                          */\n/******************************************************************************************/\nconst checkAndRemoveDuplicates = (entities: any[], d: entityInfo) => {\n  let entityDuplicate = false;\n  entities.forEach(e => {\n    if (e.targetID === d.targetID) {\n      entityDuplicate = true;\n      let passageDuplicate = false;\n      e.passage.forEach(p => {\n        if (p === d.passage[0]) {\n          passageDuplicate = true;\n        }\n      });\n      if (!passageDuplicate) {\n        e.passage.push(d.passage[0]);\n      }\n    }\n  });\n  if (!entityDuplicate) {\n    entities.push(d);\n  }\n  return entities;\n};\n\n/******************************************************************************************/\n/* Alphabetize the list of names in each category                                         */\n/******************************************************************************************/\nconst alphabetize = (relation: any[]) => {\n  if (relation.length === 0) {\n    return [];\n  } else {\n    relation.sort(function(a, b) {\n      var relationA = a.target.toUpperCase();\n      var relationB = b.target.toUpperCase();\n      return relationA < relationB ? -1 : relationA > relationB ? 1 : 0;\n    });\n  }\n  return relation;\n};\n\n/******************************************************************************************/\n/* Datum reversals                                                   */\n/* -------------------------------------------------------------------------------------- */\n/* This function flips the verb so that X can become the direct object,                   */\n/* without compromising the validity of the datum                                         */\n/*                                                                                        */\n/* e.g. X <is mother of> Y, where Y is <male>                                             */\n/* => returns verb <is son of>, to let X become the direct object (Y is son of X)         */\n/******************************************************************************************/\nconst reversedVerb = (verb: string, dirObject: string) => {\n  // TODO: Fix this temporary solution for gender data not existing for entity\n  if (genderData[dirObject]) {\n    // PARENT -> CHILD\n    if (\n      verb === \"is mother of\" ||\n      verb === \"is father of\" ||\n      verb === \"is parent of\"\n    ) {\n      // Uses generic \"is child of\" since data cards do not show gender specificity for children\n      return \"is child of\";\n    }\n\n    // CHILD -> PARENT\n    else if (\n      verb === \"is son of\" ||\n      verb === \"is daughter of\" ||\n      verb === \"is child of\"\n    ) {\n      if (genderData[dirObject].gender === \"female\") {\n        return \"is mother of\";\n      } else if (genderData[dirObject].gender === \"male\") {\n        return \"is father of\";\n      } else {\n        // Placeholder since \"is parent of\" is not currently used in data cards\n        return \"\";\n      }\n    }\n\n    // TWIN -> TWIN\n    else if (verb === \"is twin of\") {\n      return \"is twin of\";\n    }\n\n    // SIBLING -> SIBLING\n    else if (\n      verb === \"is sister of\" ||\n      verb === \"is brother of\" ||\n      verb === \"is older than\"\n    ) {\n      if (genderData[dirObject].gender === \"female\") {\n        return \"is sister of\";\n      } else if (genderData[dirObject].gender === \"male\") {\n        return \"is brother of\";\n      } else {\n        // Placeholder since gender-unspecified siblings (e.g. \"is sibling of\")\n        // does not exist in datum.csv\n        return \"\";\n      }\n    }\n\n    // WIFE -> HUSBAND\n    // HUSBAND -> WIFE\n    // No cases of homosexual relationships in the mythology\n    else if (\n      verb === \"is wife of\" ||\n      verb === \"is husband of\" ||\n      verb === \"marries\"\n    ) {\n      if (genderData[dirObject].gender === \"female\") {\n        return \"is wife of\";\n      } else if (genderData[dirObject].gender === \"male\") {\n        return \"is husband of\";\n      } else {\n        // Placeholder since \"marries\" is not currently used in data cards\n        return \"marries\";\n      }\n    } else {\n      console.log(\n        \"Unsure of the \" +\n          verb +\n          \" \" +\n          dirObject +\n          \" connection, or connection is not relevant for the datacards.\",\n        verb,\n        dirObject\n      );\n      return \"\";\n    }\n  } else {\n    return \"Gender of \" + dirObject + \" does not exist in database\";\n  }\n};\n\n/******************************************************************************************/\n/* Check if no relations exist for this entity (used in DataCards.tsx)                    */\n/******************************************************************************************/\nexport const checkNoRelations = (relationships: any) => {\n  return (\n    relationships.MOTHERS.length === 0 &&\n    relationships.FATHERS.length === 0 &&\n    relationships.SIBLINGS.length === 0 &&\n    relationships.TWIN.length === 0 &&\n    relationships.WIVES.length === 0 &&\n    relationships.HUSBANDS.length === 0 &&\n    relationships.CHILDREN.length === 0\n  );\n};\n\n/******************************************************************************************/\n/* Return all alternative names for entity (used in DataCards.tsx)                        */\n/******************************************************************************************/\nexport const getAlternativeNames = (id: string) => {\n  let alternatives: string = \"\";\n  alternatives += getNameString(\"Name (transliteration)\", alternatives, id);\n  alternatives += getNameString(\"Name (Latinized)\", alternatives, id);\n  alternatives += getNameString(\"Name in Latin texts\", alternatives, id);\n  alternatives += getNameString(\"Alternative names\", alternatives, id);\n\n  if (alternatives === \"\") {\n    return alternatives;\n  } else {\n    return \"(Also known as: \" + alternatives + \")\";\n  }\n};\n\nconst getNameString = (parameter: string, stringSoFar: string, id: string) => {\n  let s = \"\";\n  if (entities[id][parameter] !== \"\") {\n    if (stringSoFar === \"\") {\n      s = entities[id][parameter];\n    } else {\n      s = stringSoFar + \", \" + entities[id][parameter];\n    }\n  }\n  return s;\n};\n","import entities from \"./data/entities.json\";\nimport { updateComponent } from \"./DataCardHandler\";\n\n/*\n\nexport type relationshipInfo = {\n  MOTHERS: entityInfo[];\n  FATHERS: entityInfo[];\n  SIBLINGS: entityInfo[];\n  WIVES: entityInfo[];\n  HUSBANDS: entityInfo[];\n  CHILDREN: entityInfo[];\n};\n\n*/\n\nexport const getGraph = (depth: number, id: string, relationships: any) => {\n  let Graph = require(\"@dagrejs/graphlib\").Graph;\n  let g = new Graph();\n\n  getAllLinks(g, depth, id, relationships);\n  /* TODO: How to address partners, e.g. fathers linked to mothers if have multiple fathers or multiple mothers */\n  console.log(\"Final edges\", g.edges());\n};\n\nconst getAllLinks = (g: any, depth: number, id: string, relationships: any) => {\n  g.setNode(id, entities[id][\"Name (Smith & Trzaskoma)\"]);\n\n  if (relationships.MOTHERS.length !== 0) {\n    console.log(relationships.MOTHERS);\n    for (let i = 0; i < relationships.MOTHERS.length; i++) {\n      let r = relationships.MOTHERS[i];\n      g.setNode(r.targetID, r.target);\n      g.setEdge(r.targetID, id, \"mother\");\n    }\n  }\n\n  if (relationships.FATHERS.length !== 0) {\n    console.log(relationships.FATHERS);\n    for (let i = 0; i < relationships.FATHERS.length; i++) {\n      let r = relationships.FATHERS[i];\n      g.setNode(r.targetID, r);\n      g.setEdge(r.targetID, id, \"father\");\n    }\n  }\n\n  if (relationships.SIBLINGS.length !== 0) {\n    console.log(relationships.SIBLINGS);\n    for (let i = 0; i < relationships.SIBLINGS.length; i++) {\n      let r = relationships.SIBLINGS[i];\n      g.setNode(r.targetID, r.target);\n      g.setEdge(r.targetID, id, \"sibling\");\n    }\n  }\n\n  if (relationships.WIVES.length !== 0) {\n    console.log(relationships.WIVES);\n    for (let i = 0; i < relationships.WIVES.length; i++) {\n      let r = relationships.WIVES[i];\n      g.setNode(r.targetID, r.target);\n      g.setEdge(r.targetID, id, \"wife\");\n    }\n  }\n\n  if (relationships.HUSBANDS.length !== 0) {\n    console.log(relationships.HUSBANDS);\n    for (let i = 0; i < relationships.HUSBANDS.length; i++) {\n      let r = relationships.HUSBANDS[i];\n      g.setNode(r.targetID, r.target);\n      g.setEdge(r.targetID, id, \"husband\");\n    }\n  }\n\n  if (relationships.CHILDREN.length !== 0) {\n    console.log(relationships.CHILDREN);\n    for (let i = 0; i < relationships.CHILDREN.length; i++) {\n      let r = relationships.CHILDREN[i];\n      g.setNode(r.targetID, r.target);\n      g.setEdge(r.targetID, id, \"child\");\n    }\n  }\n\n  let edges = g.edges();\n  console.log(depth);\n  if (depth > 1) {\n    for (let i = 0; i < edges.length; i++) {\n      // Does this actually update g?\n      // Recursive call to getAllLinks()\n      getAllLinks(\n        g,\n        depth - 1,\n        edges[i].v,\n        updateComponent(edges[i].v).relationships\n      );\n    }\n  }\n};\n","import React from \"react\";\nimport \"./App.css\";\nimport { getGraph } from \"./GraphHandler\";\nimport entities from \"./data/entities.json\";\n\ntype GraphProps = { id: string; relationships: any };\ntype GraphState = {};\n\nclass EntityGraph extends React.Component<GraphProps, GraphState> {\n  constructor(props: any) {\n    super(props);\n  }\n\n  getName(id: string) {\n    return entities[id][\"Name (Smith & Trzaskoma)\"];\n  }\n\n  render() {\n    getGraph(2, this.props.id, this.props.relationships);\n    return <div></div>;\n  }\n}\n\nexport default EntityGraph;\n","import React from \"react\";\nimport \"./App.css\";\nimport \"./DataCards.scss\";\nimport queryString from \"querystring\";\nimport passages from \"./data/passages.json\";\nimport EntityGraph from \"./EntityGraph\";\nimport ReactGA from \"react-ga\";\nimport {\n  relationshipInfo,\n  updateComponent,\n  checkNoRelations,\n  getAlternativeNames\n} from \"./DataCardHandler\";\nimport Pluralize from \"pluralize\";\n\ntype DatumProps = {\n  location: {\n    search: string;\n  };\n  history: {\n    push: ({}) => null;\n  };\n};\ntype DatumState = {\n  id: string;\n  name: string;\n  relationships: relationshipInfo;\n  members: any[];\n  type: string;\n  validSearch: boolean;\n};\n\nclass DataCards extends React.Component<DatumProps, DatumState> {\n  constructor(props: any) {\n    super(props);\n    // Dionysus is 8188175, use to test multiple names\n    // Atreus is 8187873\n    // Theseus is 8188822\n    // Agamemnon is 8182035\n    // Use Clytaimnestra example, 8188055\n    this.state = {\n      id: \"8182035\",\n      name: \"\",\n      relationships: {\n        MOTHERS: [],\n        FATHERS: [],\n        SIBLINGS: [],\n        TWIN: [],\n        WIVES: [],\n        HUSBANDS: [],\n        CHILDREN: []\n      },\n      members: [],\n      type: \"\",\n      validSearch: false\n    };\n    /* this.getNameFromID = this.getNameFromID.bind(this);\n    this.checkNoRelations = this.checkNoRelations.bind(this);\n    this.reversedVerb = this.reversedVerb.bind(this);\n    this.getDataPoints = this.getDataPoints.bind(this);\n    this.handleNameClicked = this.handleNameClicked.bind(this);\n    this.getAlternativeNames = this.getAlternativeNames.bind(this); */\n  }\n\n  /*******************/\n  /* HELPER FUNCTIONS */\n  /*******************/\n\n  getPassageLink(passage: any) {\n    let id = passage.startID;\n    let author: string = passages[id].Author;\n    let title: string = passages[id].Title;\n    let start: string = passages[id].Passage;\n    let end: string = passage.endID;\n\n    // Dealing with multiple URNs\n    let URN: string = \"\";\n    let URNsplit = passages[id][\"CTS URN\"].split(\", \");\n    if (URNsplit.length >= 2) {\n      URN = URNsplit[1];\n    } else {\n      URN = passages[id][\"CTS URN\"];\n    }\n\n    URN = \"https://scaife.perseus.org/reader/\" + URN;\n    if (passage.endID !== \"\") {\n      end = passages[end].Passage;\n      URN = URN + \"-\" + end;\n    }\n    URN = URN + \"/?right=perseus-eng2\";\n\n    return (\n      <span>\n        {\"  (\"}\n        <a\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          href={URN}\n          style={{\n            color: \"grey\",\n            fontSize: \"0.8rem\"\n          }}\n        >\n          {author + \", \"}\n          <span style={{ fontStyle: \"italic\" }}>{title}</span> {start}\n          {start !== end && end !== \"\" ? \"-\" + end : \"\"}\n        </a>\n        {\")\"}\n      </span>\n    );\n  }\n\n  handleNameClicked(targetID: string) {\n    ReactGA.event({\n      category: \"NameClicked\",\n      action: \"User clicked on a name within the data card\"\n    });\n    this.props.history.push(\"/datacards?id=\" + targetID);\n  }\n\n  getDataPoints(relationship: string) {\n    let that = this;\n    if (that.state.relationships[relationship].length !== 0) {\n      return (\n        <div style={{ clear: \"both\" }}>\n          <div\n            style={{\n              fontWeight: \"bold\",\n              textTransform: \"uppercase\",\n              float: \"left\",\n              paddingRight: \"1rem\"\n            }}\n          >\n            {this.state.relationships[relationship].length === 1 &&\n            this.state.relationships[relationship][0].type !== \"Collective\"\n              ? Pluralize.singular(relationship) + \": \"\n              : relationship + \": \"}\n          </div>\n          <div style={{ float: \"left\" }}>\n            {that.state.relationships[relationship].map(entity => {\n              return (\n                <div style={{ margin: \"0\" }}>\n                  <div\n                    className=\"entity-button\"\n                    onClick={() => this.handleNameClicked(entity.targetID)}\n                  >\n                    {entity.target}\n                  </div>\n                  {entity.passage.map(passage => {\n                    return this.getPassageLink(passage);\n                  })}\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  getCollectiveMembers() {\n    let that = this;\n    if (that.state.members.length !== 0) {\n      return (\n        <div style={{ marginTop: \"3rem\", textAlign: \"center\" }}>\n          <div\n            style={{\n              fontWeight: \"bold\",\n              textTransform: \"uppercase\",\n              textDecoration: \"underline\",\n              marginBottom: \"0.5rem\"\n            }}\n          >\n            MEMBERS:\n          </div>\n          {that.state.members.map(member => {\n            return (\n              <div style={{ margin: \"0\" }}>\n                <span\n                  className=\"collective-button\"\n                  onClick={() => this.handleNameClicked(member.targetID)}\n                >\n                  {member.target}\n                </span>\n                {member.passage.map(passage => {\n                  return this.getPassageLink(passage);\n                })}\n              </div>\n            );\n          })}\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  /*******************/\n  /* SETUP FUNCTIONS */\n  /*******************/\n\n  componentDidMount() {\n    const params = queryString.parse(this.props.location.search.slice(1));\n    const id = params.id as string;\n    if (!params.id) {\n      // Handle bad url\n      //@ts-ignore\n      this.setState({ validSearch: false });\n    } else {\n      //Substitute with ID\n      // this.updateComponent(this.state.id);\n      let newState = updateComponent(id);\n      this.setState({\n        id: newState.id,\n        relationships: newState.relationships,\n        members: newState.members,\n        name: newState.name,\n        type: newState.type,\n        validSearch: newState.validSearch\n      });\n    }\n  }\n\n  componentDidUpdate() {\n    const params = queryString.parse(this.props.location.search.slice(1));\n    const id = params.id as string;\n    if (!params.id) {\n      // Handle bad url\n      //@ts-ignore\n      this.setState({ validSearch: false });\n    } else if (this.state.id !== id) {\n      //Substitute with ID\n      // this.updateComponent(this.state.id);\n      let newState = updateComponent(id);\n      this.setState({\n        id: newState.id,\n        relationships: newState.relationships,\n        members: newState.members,\n        name: newState.name,\n        type: newState.type,\n        validSearch: newState.validSearch\n      });\n    }\n  }\n\n  /*************/\n  /* RENDERING */\n  /*************/\n\n  render() {\n    return (\n      <React.Fragment>\n        <div\n          className={this.state.validSearch ? \"no-display\" : \"\"}\n          style={{ textAlign: \"center\", padding: \"3rem\" }}\n        >\n          No profiles have been selected. Try using the Search function.\n        </div>\n        <div className={this.state.validSearch ? \"\" : \"no-display\"}>\n          <div\n            style={{\n              margin: \"1rem 6rem 3rem 6rem\",\n              padding: \"3rem\",\n              display: \"flow-root\",\n              border: \"solid 1px black\"\n            }}\n          >\n            <div id=\"datacard-heading\">{this.state.name}</div>\n            <div id=\"datacard-alternativenames\">\n              {getAlternativeNames(this.state.id)}\n            </div>\n            <div id=\"datacard-mantoID\">MANTO ID: {this.state.id}</div>\n            {/* If no data is available for the subject */}\n            <div\n              className={\n                checkNoRelations(this.state.relationships) ? \"\" : \"no-display\"\n              }\n            >\n              No relationship data is available for {this.state.name}.\n            </div>\n            {/* If data is available for the subject */}\n            {Object.keys(this.state.relationships).map(key => {\n              return <div key={key}>{this.getDataPoints(key)}</div>;\n            })}\n            <div>{this.getCollectiveMembers()}</div>\n          </div>\n        </div>\n\n        <EntityGraph\n          id={this.state.id}\n          relationships={this.state.relationships}\n        ></EntityGraph>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default DataCards;\n","import React from \"react\";\nimport \"./App.css\";\nimport Header from \"./Header\";\nimport Search from \"./Search\";\nimport DataCards from \"./DataCards\";\nimport ReactGA from \"react-ga\";\nimport {\n  HashRouter as Router,\n  Route,\n  Link,\n  Switch,\n  Redirect\n} from \"react-router-dom\";\n\nclass App extends React.Component<{}, {}> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      subjectID: \"\"\n    };\n  }\n\n  changeEntity(ID: string) {\n    this.setState({ subjectID: ID });\n  }\n\n  initializeReactGA() {\n    ReactGA.initialize(\"UA-151993194-1\");\n    ReactGA.pageview(\"/homepage\");\n  }\n\n  render() {\n    return (\n      <div\n        style={{ backgroundColor: \"#eeeeee\", height: \"100%\", width: \"100%\" }}\n      >\n        <Router>\n          <Link to=\"/\">\n            <Header></Header>\n          </Link>\n          <Search></Search>\n          <Switch>\n            {/* <Route exact path=\"/\" component={Home} /> */}\n            <Route path=\"/search\" component={Search} />\n            <Route path=\"/datacards\" component={DataCards} />\n            <Route component={() => <Redirect to=\"/\" />} />\n          </Switch>\n        </Router>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}