{"version":3,"sources":["images/arrow.svg","images/logo.svg","Header.tsx","Search.tsx","DataCardHandler.ts","GraphHandler.ts","EntityGraph.jsx","DataCards.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Header","style","paddingTop","textAlign","src","require","alt","width","Search","props","pageRedirect","state","redirect","to","targetID","handleSearch","bind","handleSearchKeyDown","getDescriptors","id","this","hasKey","entities","alternatives","ReactGA","event","category","action","currentInput","document","getElementById","value","split","currentInputName","trim","setState","which","keyCode","obj","key","Fragment","margin","placeholder","list","onKeyDown","fontSize","maxHeight","Object","values","map","entity","arrow","onClick","className","React","Component","familyTies","updateComponent","connections","getAllConnections","length","verb","relationships","MOTHERS","FATHERS","SIBLINGS","TWIN","SPOUSES","CHILDREN","name","getName","members","type","validSearch","alternativeName","passage","sortConnectionsIntoRelationships","ties","forEach","tieRow","passageInfo","start","startID","end","endID","target","includes","Verb","getGender","push","reversedVerb","childrenTemp","tie","d","checkAndRemoveDuplicates","m","mother_parthenogenesis","f","father_parthenogenesis","a","autochthony","getIndirectSiblings","alphabetize","getOtherParents","alphabetizeChildren","duplicate","e","passageDuplicate","p","checkAndRemoveParentDuplicates","parentID","newChild","children","parentDuplicate","childDuplicate","c","otherParentID","i","child","relation","sort","b","relationA","toUpperCase","relationB","r","mainGender","parentsGrouped","dirObject","console","log","mothers","fathers","siblings","newsiblings","testsibling","motherMatch","fatherMatch","info","testinfo","keys","k","checkNoRelations","getNameString","parameter","stringSoFar","s","entityRow","possibleNames","undefined","getGraph","depth","g","graphlib","Graph","setGraph","setDefaultEdgeLabel","getAllLinks","setNode","label","height","shape","setEdge","WIVES","HUSBANDS","j","edges","v","EntityGraph","handleClickedNode","render","dagreD3","svg","d3","nodeTree","nodeTreeGroup","attr","graph","selectAll","on","relationshipClicked","maxWidth","ref","DataCards","handleNameClicked","author","passages","Author","title","Title","Passage","URN","URNsplit","rel","href","color","fontStyle","history","relationship","showPassage","clear","fontWeight","textTransform","float","paddingRight","marginTop","Pluralize","singular","checkUnusualRelationship","textDecoration","getPassageLink","getChildParentGrouped","group","marginBottom","member","params","queryString","parse","location","search","slice","newState","padding","display","border","getAlternativeNames","getAlternativePage","getDataPoints","getCollectiveMembers","App","subjectID","ID","initialize","pageview","backgroundColor","path","component","Boolean","window","hostname","match","ReactDOM","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"irolCAAAA,EAAOC,QAAU,IAA0B,mC,gFCA3CD,EAAOC,QAAU,IAA0B,kC,uh8FCe5BC,G,MAZU,WACvB,OACE,yBAAKC,MAAO,CAAEC,WAAY,OAAQC,UAAW,WAC3C,yBACEC,IAAKC,EAAQ,KACbC,IAAI,aACJL,MAAO,CAAEM,MAAO,Y,iDCyJTC,E,YApJb,WAAYC,GAAa,IAAD,8BACtB,4CAAMA,KAqCRC,aAAe,WACb,GAAI,EAAKC,MAAMC,SACb,OAAO,kBAAC,IAAD,CAAUC,GAAI,iBAAmB,EAAKF,MAAMG,YAtCrD,EAAKH,MAAQ,CACXC,UAAU,EACVE,SAAU,IAGZ,EAAKC,aAAe,EAAKA,aAAaC,KAAlB,gBACpB,EAAKC,oBAAsB,EAAKA,oBAAoBD,KAAzB,gBAC3B,EAAKE,eAAiB,EAAKA,eAAeF,KAApB,gBATA,E,4EAYTG,GACb,GAAIC,KAAKC,OAAOC,EAAUH,GAAK,CAC7B,IAAII,EAAuB,GAoB3B,MAnB+C,KAA3CD,EAASH,GAAI,4BACfI,EACEA,EAAe,KAAOD,EAASH,GAAI,2BAEE,KAArCG,EAASH,GAAI,sBACfI,EAAeA,EAAe,KAAOD,EAASH,GAAI,qBAER,KAAxCG,EAASH,GAAI,yBACfI,EACEA,EAAe,KAAOD,EAASH,GAAI,wBAEG,KAAtCG,EAASH,GAAI,uBACfI,EAAeA,EAAe,KAAOD,EAASH,GAAI,sBAGlDG,EAASH,GAAI,4BACbI,EACA,KACAD,EAASH,GAAI,8B,qCAYjBK,IAAQC,MAAM,CACZC,SAAU,SACVC,OAAQ,qDAEV,IAAIC,EAAeC,SAASC,eAAe,SAC3C,GAA2B,KAAvBF,EAAaG,MAEf,IAAK,IAAIZ,KAAMG,EACb,GAAIF,KAAKC,OAAOC,EAAUH,IAEtBG,EAASH,GAAI,6BACbS,EAAaG,MAAMC,MAAM,MAAM,GAC/B,CACA,IAAIC,EAAmBL,EAAaG,MACjCC,MAAM,MAAM,GACZA,MAAM,KAAK,GACXE,OAGDD,IAAqBX,EAASH,GAAI,6BAClCc,IAAqBX,EAASH,GAAI,2BAClCc,IAAqBX,EAASH,GAAI,qBAClCc,IAAqBX,EAASH,GAAI,wBAClCc,IAAqBX,EAASH,GAAI,sBAElCC,KAAKe,SAAS,CACZvB,UAAU,EACVE,SAAUK,O,0CASJM,GACE,KAAhBA,EAAMW,OAAkC,KAAlBX,EAAMY,SAC9BjB,KAAKL,iB,6BAKCuB,EAAQC,GAChB,OAAOA,KAAOD,I,+BAGN,IAAD,OASP,OACE,kBAAC,IAAME,SAAP,KAEGpB,KAAKV,eACN,yBACET,MAAO,CACLwC,OAAQ,gBACRtC,UAAW,WASb,2BAEEuC,YAAY,iBACZvB,GAAG,QACHwB,KAAK,WACLC,UAAWxB,KAAKH,oBAChBhB,MAAO,CAAEM,MAAO,MAAOJ,UAAW,SAAU0C,SAAU,UAExD,8BAAU1B,GAAG,WAAWlB,MAAO,CAAE6C,UAAW,UACzCC,OAAOC,OAAO1B,GAAU2B,IAAI,SAAAC,GAC3B,OACE,4BACEnB,MAAO,EAAKb,eAAegC,EAAO,kBAK1C,6BACE,yBACE5C,IAAI,gBACJF,IAAK+C,IACLC,QAAShC,KAAKL,aACdsC,UAAU,wB,GA5IHC,IAAMC,W,0CCgCvBC,EAAa,CAEf,eACA,eACA,eAEA,cAEA,gBACA,aACA,gBAEA,eACA,UAWA,aACA,eAGA,kCACA,kCACA,qCAMWC,EAAkB,SAACtC,GAC9B,IAAIuC,EAAcC,EAAkBxC,GACpC,GACEuC,EAAYE,OAAS,GACG,4BAAxBF,EAAY,GAAGG,KACf,CAqBA,MAZuC,CACrC1C,GAAIA,EACJ2C,cAV4B,CAC5BC,QAAS,GACTC,QAAS,GACTC,SAAU,GACVC,KAAM,GACNC,QAAS,GACTC,SAAU,IAKVC,KAAMC,EAAQhD,EAASH,IACvBoD,QAAS,GACTC,KAAMlD,EAASH,GAAI,kBACnBsD,aAAa,EACbC,gBAAiB,CACf5D,SAAU4C,EAAY,GAAG5C,SACzB6D,QAASjB,EAAY,GAAGiB,UAK5B,OAAOC,EAAiCzD,EAAIuC,IAS1CC,EAAoB,SAACxC,GACzB,IAAIuC,EAKE,GA8JN,OA5JAX,OAAOC,OAAO6B,GAAMC,QAAQ,SAASC,GAEnC,GAAIzD,EAASyD,EAAO,eAIlB,GACqB,gBAAnBA,EAAM,MACyB,YAA/BA,EAAO,yBAGF,CACL,GACEA,EAAO,gBAAkB5D,GACN,4BAAnB4D,EAAM,KACN,CACA,IAAIC,EAA6B,CAC/B,CACEC,MAAOF,EAAO,kBACdG,QAASH,EAAO,qBAChBI,IAAgC,KAA3BJ,EAAO,gBAAyB,GAAKA,EAAO,gBACjDK,MACgC,KAA9BL,EAAO,mBACH,GACAA,EAAO,qBAWjB,OARArB,EAAc,CACZ,CACE2B,OAAQ,GACRvE,SAAUiE,EAAO,oBACjBlB,KAAM,0BACNc,QAASK,IASf,GACED,EAAO,sBAAwB5D,GAC/BqC,EAAW8B,SAASP,EAAOQ,MAC3B,CACA,IAAIP,EAA6B,CAC/B,CACEC,MAAOF,EAAO,kBACdG,QAASH,EAAO,qBAChBI,IAAgC,KAA3BJ,EAAO,gBAAyB,GAAKA,EAAO,gBACjDK,MACgC,KAA9BL,EAAO,mBACH,GACAA,EAAO,qBAKbS,EAAUT,EAAO,gBAAkC,YAAhBA,EAAOQ,OAC5CR,EAAOQ,KAAO,gBAIhB7B,EAAY+B,KAAK,CACfJ,OAAQf,EAAQhD,EAASyD,EAAO,gBAChCjE,SAAUiE,EAAO,cACjBlB,KAAMkB,EAAOQ,KACbZ,QAASK,IAOb,GAAID,EAAO,gBAAkB5D,GAAMqC,EAAW8B,SAASP,EAAOQ,MAAO,CACnE,IAAIP,EAA6B,CAC/B,CACEC,MAAOF,EAAO,kBACdG,QAASH,EAAO,qBAChBI,IAAgC,KAA3BJ,EAAO,gBAAyB,GAAKA,EAAO,gBACjDK,MAAOL,EAAO,qBAKE,sCAAhBA,EAAOQ,KACT7B,EAAY+B,KAAK,CACfJ,OAAQ,GACRvE,SAAU,GACV+C,KAAM,oCACNc,QAASK,IAIwB,YAA/BD,EAAO,qBACTrB,EAAY+B,KAAK,CACfJ,OAAQf,EAAQhD,EAASyD,EAAO,sBAChCjE,SAAUiE,EAAO,oBACjBlB,KAAM6B,EAAaX,EAAOQ,KAAMR,EAAO,qBACvCJ,QAASK,IAWjB,GACED,EAAO,gCACPA,EAAO,iCAAmC5D,GAC1B,8CAAhB4D,EAAOQ,KACP,CACA,IAAIP,EAA6B,CAC/B,CACEC,MAAOF,EAAO,kBACdG,QAASH,EAAO,qBAChBI,IAAgC,KAA3BJ,EAAO,gBAAyB,GAAKA,EAAO,gBACjDK,MAAOL,EAAO,qBAGlBrB,EAAY+B,KAAK,CACfJ,OAAQf,EAAQhD,EAASyD,EAAO,sBAChCjE,SAAUiE,EAAO,oBACjBlB,KAAM,eACNc,QAASK,SAKR,GACHD,EAAO,qBACPA,EAAO,sBAAwB5D,GACf,8CAAhB4D,EAAOQ,KACP,CACA,IAAIP,EAA6B,CAC/B,CACEC,MAAOF,EAAO,kBACdG,QAASH,EAAO,qBAChBI,IAAgC,KAA3BJ,EAAO,gBAAyB,GAAKA,EAAO,gBACjDK,MAAOL,EAAO,qBAGlBrB,EAAY+B,KAAK,CACfJ,OAAQf,EAAQhD,EAASyD,EAAO,iCAChCjE,SAAUiE,EAAO,+BACjBlB,KAAM,eACNc,QAASK,QAOZtB,GAQHkB,EAAmC,SAACzD,EAAYuC,GAEpD,IAAIW,EAAOC,EAAQhD,EAASH,IACxBqD,EAAOlD,EAASH,GAAI,kBACpBoD,EAAiB,GACjBT,EAAkC,CACpCC,QAAS,GACTC,QAAS,GACTC,SAAU,GACVC,KAAM,GACNC,QAAS,GACTC,SAAU,IAGRuB,EAA6B,GA4IjC,OA3IAjC,EAAYoB,QAAQ,SAAAc,GAIlB,IAAIC,EAAgB,CAClBR,OAAQO,EAAIP,OACZvE,SAAU8E,EAAI9E,SACd6D,QAASiB,EAAIjB,QACbH,KACe,sCAAboB,EAAI/B,KACA,GACAvC,EAASsE,EAAI9E,UAAU,mBAM/B,GAAiB,iBAAb8E,EAAI/B,KAGNC,EAAcC,QAAU+B,EACtBhC,EAAcC,QACd8B,QAKC,GAAiB,oCAAbD,EAAI/B,KAA4C,CACvD,IAAIkC,EAAgB,CAClBV,OAAQO,EAAIP,OACZvE,SAAU8E,EAAI9E,SACd6D,QAASiB,EAAIjB,QACbH,KAAMlD,EAASsE,EAAI9E,UAAU,kBAC7BkF,wBAAwB,GAG1BlC,EAAcC,QAAU+B,EACtBhC,EAAcC,QACdgC,QAKC,GAAiB,iBAAbH,EAAI/B,KACXC,EAAcE,QAAU8B,EACtBhC,EAAcE,QACd6B,QAKC,GAAiB,oCAAbD,EAAI/B,KAA4C,CACvD,IAAIoC,EAAgB,CAClBZ,OAAQO,EAAIP,OACZvE,SAAU8E,EAAI9E,SACd6D,QAASiB,EAAIjB,QACbH,KAAMlD,EAASsE,EAAI9E,UAAU,kBAC7BoF,wBAAwB,GAE1BpC,EAAcE,QAAU8B,EACtBhC,EAAcE,QACdiC,QAKC,GAAiB,gBAAbL,EAAI/B,KACX8B,EAAeG,EAAyBH,EAAcE,QAInD,GAAiB,kBAAbD,EAAI/B,MAAyC,kBAAb+B,EAAI/B,KAC3CC,EAAcG,SAAW6B,EACvBhC,EAAcG,SACd4B,QAKC,GAAiB,eAAbD,EAAI/B,KACXC,EAAcI,KAAO4B,EAAyBhC,EAAcI,KAAM2B,QAG/D,GAAiB,iBAAbD,EAAI/B,MAAwC,YAAb+B,EAAI/B,KAC1CC,EAAcK,QAAU2B,EACtBhC,EAAcK,QACd0B,QAIC,GAAiB,eAAbD,EAAI/B,MAAsC,iBAAb+B,EAAI/B,KACxCU,EAAUuB,EAAyBvB,EAASsB,QAGzC,GAAiB,sCAAbD,EAAI/B,KAA8C,CACzD,IAAIsC,EAAgB,CAClBd,OAAQ,GACRvE,SAAU,GACV6D,QAASiB,EAAIjB,QACbH,KAAMlD,EAASH,GAAI,kBACnBiF,aAAa,GAEftC,EAAcE,QAAU8B,EACtBhC,EAAcE,QACdmC,MAMNrC,EAAcG,SAAWoC,EACvBlF,EACA2C,EAAcC,QACdD,EAAcE,QACdF,EAAcG,UAIhBH,EAAcC,QAAUuC,EAAYxC,EAAcC,SAClDD,EAAcE,QAAUsC,EAAYxC,EAAcE,SAClDF,EAAcG,SAAWqC,EAAYxC,EAAcG,UACnDH,EAAcI,KAAOoC,EAAYxC,EAAcI,MAC/CJ,EAAcK,QAAUmC,EAAYxC,EAAcK,SAClDI,EAAU+B,EAAY/B,GAGtBT,EAAcM,SAAWmC,EAAgBpF,EAAIwE,GAC7C7B,EAAcM,SAAWoC,EAAoB1C,EAAcM,UAG3B,CAC9BjD,GAAIA,EACJ2C,cAAeA,EACfO,KAAMA,EACNE,QAASA,EACTC,KAAMA,EACNC,aAAa,EACbC,gBAAiB,CAAE5D,SAAU,GAAI6D,QAAS,MAWxCmB,EAA2B,SAACxE,EAAiBuE,GACjD,IAAIY,GAAY,EAqBhB,OApBAnF,EAASwD,QAAQ,SAAA4B,GACf,GAAIA,EAAE5F,WAAa+E,EAAE/E,SAAU,CAC7B2F,GAAY,EACZ,IAAIE,GAAmB,EACvBD,EAAE/B,QAAQG,QAAQ,SAAA8B,GAEdA,EAAE1B,UAAYW,EAAElB,QAAQ,GAAGO,SAC3B0B,EAAExB,QAAUS,EAAElB,QAAQ,GAAGS,QAEzBuB,GAAmB,KAGlBA,GACHD,EAAE/B,QAAQc,KAAKI,EAAElB,QAAQ,OAI1B8B,GACHnF,EAASmE,KAAKI,GAETvE,GAGHuF,EAAiC,SACrCC,EACAC,EACAC,GAIA,IAAIC,GAAkB,EAClBC,GAAiB,EAkBrB,OAjBAF,EAASlC,QAAQ,SAAAqC,GACf,GAAIA,EAAEC,gBAAkBN,EAAU,CAChCG,GAAkB,EAClB,IAAK,IAAII,EAAI,EAAGA,EAAIF,EAAEG,MAAM1D,OAAQyD,IAC9BF,EAAEG,MAAMD,GAAGvG,WAAaiG,EAASjG,WACnCoG,GAAiB,GAGhBA,GACHC,EAAEG,MAAM7B,KAAKsB,MAIdE,GACHD,EAASvB,KAAK,CAAE6B,MAAO,CAACP,GAAWK,cAAeN,IAG7CE,GAMHV,EAAc,SAACiB,GACnB,OAAwB,IAApBA,EAAS3D,OACJ,IAEP2D,EAASC,KAAK,SAASrB,EAAGsB,GACxB,IAAIC,EAAYvB,EAAEd,OAAOsC,cACrBC,EAAYH,EAAEpC,OAAOsC,cACzB,OAAOD,EAAYE,GAAa,EAAIF,EAAYE,EAAY,EAAI,IAG7DL,IAGHf,EAAsB,SAACe,GAC3B,OAAwB,IAApBA,EAAS3D,OACJ,IAEP2D,EAASzC,QAAQ,SAAA+C,GACfA,EAAEP,MAAQhB,EAAYuB,EAAEP,SAE1BC,EAASC,KAAK,SAASrB,EAAGsB,GACxB,IAAIC,EAAYpD,EAAQhD,EAAS6E,EAAEiB,gBAC/BQ,EAAYtD,EAAQhD,EAASmG,EAAEL,gBACnC,OAAOM,EAAYE,GAAa,EAAIF,EAAYE,EAAY,EAAI,IAG7DL,IAMHhB,EAAkB,SAACpF,EAAY6F,GACnC,IAAIc,EAAatC,EAAUrE,GACvB4G,EAAiC,GAuFrC,OAtFAf,EAASlC,QAAQ,SAAAqC,GACfpE,OAAOC,OAAO6B,GAAMC,QAAQ,SAASC,GAEA,YAA/BA,EAAO,sBAEU,WAAf+C,IAGA/C,EAAO,gBAAkBoC,EAAErG,UACR,gBAAnBiE,EAAM,MACNA,EAAO,sBAAwB5D,EAG7BG,EAASyD,EAAO,sBAC0B,SAA1CS,EAAUT,EAAO,sBAC0C,UAA3DzD,EAASyD,EAAO,qBAAqB,oBAErCgD,EAAiBlB,EACf9B,EAAO,oBACPoC,EACAY,IAMJhD,EAAO,sBAAwBoC,EAAErG,UACd,iBAAnBiE,EAAM,MACNA,EAAO,gBAAkB5D,GAGvBG,EAASyD,EAAO,gBACoB,SAApCS,EAAUT,EAAO,gBACoC,UAArDzD,EAASyD,EAAO,eAAe,oBAE/BgD,EAAiBlB,EACf9B,EAAO,cACPoC,EACAY,KAMW,SAAfD,IAGA/C,EAAO,gBAAkBoC,EAAErG,UACR,gBAAnBiE,EAAM,MACNA,EAAO,sBAAwB5D,EAG7BG,EAASyD,EAAO,sBAC0B,WAA1CS,EAAUT,EAAO,sBAC0C,UAA3DzD,EAASyD,EAAO,qBAAqB,oBAErCgD,EAAiBlB,EACf9B,EAAO,oBACPoC,EACAY,IAMJhD,EAAO,sBAAwBoC,EAAErG,UACd,iBAAnBiE,EAAM,MACNA,EAAO,gBAAkB5D,GAGvBG,EAASyD,EAAO,gBACoB,WAApCS,EAAUT,EAAO,gBACoC,UAArDzD,EAASyD,EAAO,eAAe,oBAE/BgD,EAAiBlB,EACf9B,EAAO,cACPoC,EACAY,UASPA,GAMIvC,EAAY,SAACrE,GACxB,MAAW,YAAPA,EACK,SAEAG,EAASH,GAAI,wBAalBuE,EAAe,SAAC7B,EAAcmE,GAGlC,MAAa,iBAATnE,EAEK,cAIS,gBAATA,EACsB,WAAzB2B,EAAUwC,GACL,eAC2B,SAAzBxC,EAAUwC,GACZ,eAGA,GAKO,eAATnE,EACA,aAIS,kBAATA,GAAqC,kBAATA,EAC5B,gBAMS,iBAATA,GAAoC,YAATA,EAC3B,eAIS,iBAATA,GAAoC,eAATA,GAClCoE,QAAQC,IAAI,oBAAqBF,EAAW,gBACrC,KAEPC,QAAQC,IACN,aACErE,EACA,IACAmE,EACA,gEACFnE,EACAmE,GAEK,KAWL3B,EAAsB,SAC1BlF,EACAgH,EACAC,EACAC,GAOA,IAAIC,EAAkB,GA+GtB,OA9GAvF,OAAOC,OAAO6B,GAAMC,QAAQ,SAASC,GACnC,IAAIwD,EAAc,CAChBC,aAAa,EACbC,aAAa,EACbC,KAAM,IAUJC,EAAuB,CACzBtD,OAAQ,GACRvE,SAAU,GACV6D,QAX+B,CAC/B,CACEM,MAAOF,EAAO,kBACdG,QAASH,EAAO,qBAChBI,IAAgC,KAA3BJ,EAAO,gBAAyB,GAAKA,EAAO,gBACjDK,MAAOL,EAAO,qBAOhBP,KAAMlD,EAASH,GAAI,mBAIH,mBAAhB4D,EAAOQ,MACS,cAAhBR,EAAOQ,MACS,gBAAhBR,EAAOQ,OAEP4C,EAAQrD,QAAQ,SAAAiB,GACVA,EAAEjF,WAAaiE,EAAO,sBACxBwD,EAAYC,aAAc,EAC1BG,EAAStD,OAASf,EAAQhD,EAASyD,EAAO,gBAC1C4D,EAAS7H,SAAWiE,EAAO,cAC3BwD,EAAYG,KAAOC,EACb5D,EAAO,gBAAiBuD,EAG5BA,EAAYvD,EAAO,eAAeyD,aAAc,EAFhDF,EAAYvD,EAAO,eAAiBwD,KAM1CH,EAAQtD,QAAQ,SAAAmB,GACVA,EAAEnF,WAAaiE,EAAO,sBACxBwD,EAAYE,aAAc,EAC1BE,EAAStD,OAASf,EAAQhD,EAASyD,EAAO,gBAC1C4D,EAAS7H,SAAWiE,EAAO,cAC3BwD,EAAYG,KAAOC,EACb5D,EAAO,gBAAiBuD,EAG5BA,EAAYvD,EAAO,eAAe0D,aAAc,EAFhDH,EAAYvD,EAAO,eAAiBwD,OAS1B,iBAAhBxD,EAAOQ,MACS,wBAAhBR,EAAOQ,MACU,iBAAhBR,EAAOQ,MACNjE,EAASyD,EAAO,gBAC0C,WAA1DzD,EAASyD,EAAO,eAAe,yBAEjCoD,EAAQrD,QAAQ,SAAAiB,GACVA,EAAEjF,WAAaiE,EAAO,gBACxBwD,EAAYC,aAAc,EAC1BG,EAAStD,OAASf,EAAQhD,EAASyD,EAAO,sBAC1C4D,EAAS7H,SAAWiE,EAAO,oBAC3BwD,EAAYG,KAAOC,EACb5D,EAAO,sBAAuBuD,EAGlCA,EAAYvD,EAAO,qBAAqByD,aAAc,EAFtDF,EAAYvD,EAAO,qBAAuBwD,MAShC,iBAAhBxD,EAAOQ,MACS,wBAAhBR,EAAOQ,MACU,iBAAhBR,EAAOQ,MACNjE,EAASyD,EAAO,gBAC0C,SAA1DzD,EAASyD,EAAO,eAAe,yBAEjCqD,EAAQtD,QAAQ,SAAAmB,GACVA,EAAEnF,WAAaiE,EAAO,gBACxBwD,EAAYE,aAAc,EAC1BE,EAAStD,OAASf,EAAQhD,EAASyD,EAAO,sBAC1C4D,EAAS7H,SAAWiE,EAAO,oBAC3BwD,EAAYG,KAAOC,EACb5D,EAAO,sBAAuBuD,EAGlCA,EAAYvD,EAAO,qBAAqB0D,aAAc,EAFtDH,EAAYvD,EAAO,qBAAuBwD,OAQlCxF,OAAO6F,KAAKN,GACzBxD,QAAQ,SAAA+D,GAERP,EAAYO,GAAGL,aACfF,EAAYO,GAAGJ,aAChBI,IAAM1H,EAINkH,EAAWvC,EAAyBuC,EAAUC,EAAYO,GAAGH,aAFtDJ,EAAYO,KAKhBR,GAMIS,EAAmB,SAAChF,GAC/B,OACmC,IAAjCA,EAAcC,QAAQH,QACW,IAAjCE,EAAcE,QAAQJ,QACY,IAAlCE,EAAcG,SAASL,QACO,IAA9BE,EAAcI,KAAKN,QACc,IAAjCE,EAAcK,QAAQP,QACY,IAAlCE,EAAcM,SAASR,QAqBrBmF,EAAgB,SAACC,EAAmBC,EAAqB9H,GAC7D,IAAI+H,EAAI,GAQR,MAPgC,KAA5B5H,EAASH,GAAI6H,KAEbE,EADkB,KAAhBD,EACE3H,EAASH,GAAI6H,GAEbC,EAAc,KAAO3H,EAASH,GAAI6H,IAGnCE,GAMI5E,EAAU,SAAC6E,GAQtB,IAPA,IAAIC,EAAgB,CAClB,2BACA,yBACA,mBACA,sBACA,qBAEO/B,EAAI,EAAGA,EAAI+B,EAAcxF,OAAQyD,IACxC,GACE8B,EAAUC,EAAc/B,KACQ,KAAhC8B,EAAUC,EAAc/B,UACQgC,IAAhCF,EAAUC,EAAc/B,IAExB,OAAO8B,EAAUC,EAAc/B,KCp3BxBiC,G,OAAW,SAACC,EAAepI,EAAY2C,GAGlD,IAKI0F,GAAI,IALMnJ,EAAQ,IAKFoJ,SAASC,QAAQC,SAAS,CAC5CtF,KAAMC,EAAQhD,EAASH,IAAO,mBAmBhC,OAjBAqI,EAAEI,oBAAoB,WACpB,MAAO,KAGTC,EAAYL,EAAGD,EAAOpI,EAAI2C,GAanB0F,IAGHK,EAAc,SAAdA,EAAeL,EAAQD,EAAepI,EAAY2C,GAGtD,GAFA0F,EAAEM,QAAQ3I,EAAI,CAAE4I,MAAOzF,EAAQhD,EAASH,IAAMZ,MAAO,IAAKyJ,OAAQ,MAE9DlG,EAAcC,SAA4C,IAAjCD,EAAcC,QAAQH,OACjD,IAAK,IAAIyD,EAAI,EAAGA,EAAIvD,EAAcC,QAAQH,OAAQyD,IAAK,CACrD,IAAIQ,EAAI/D,EAAcC,QAAQsD,GAC9BmC,EAAEM,QAAQjC,EAAE/G,SAAU,CACpBiJ,MAAOlC,EAAExC,OACT9E,MAAO,IACPyJ,OAAQ,IACRC,MAAO,YAETT,EAAEU,QAAQrC,EAAE/G,SAAUK,EAAI,CAAE4I,MAAO,SAAU9J,MAAO,gBAKxD,GAAI6D,EAAcE,SAA4C,IAAjCF,EAAcE,QAAQJ,OACjD,IAAK,IAAIyD,EAAI,EAAGA,EAAIvD,EAAcE,QAAQJ,OAAQyD,IAAK,CACrD,IAAIQ,EAAI/D,EAAcE,QAAQqD,GAC9BmC,EAAEM,QAAQjC,EAAE/G,SAAU,CACpBiJ,MAAOlC,EAAExC,OACT9E,MAAO,IACPyJ,OAAQ,IACRC,MAAO,YAETT,EAAEU,QAAQrC,EAAE/G,SAAUK,EAAI,CAAE4I,MAAO,SAAU9J,MAAO,iBAKxD,GACG6D,EAAcG,UAA8C,IAAlCH,EAAcG,SAASL,QACjDE,EAAcI,MAAsC,IAA9BJ,EAAcI,KAAKN,OAE1C,IAAK,IAAIyD,EAAI,EAAGA,EAAIvD,EAAcG,SAASL,OAAQyD,IAAK,CACtD,IAAIQ,EAAI/D,EAAcG,SAASoD,GAC/BmC,EAAEM,QAAQjC,EAAE/G,SAAU,CACpBiJ,MAAOlC,EAAExC,OACT9E,MAAO,IACPyJ,OAAQ,IACRC,MAAO,YAETT,EAAEU,QAAQrC,EAAE/G,SAAUK,EAAI,CAAE4I,MAAO,UAAW9J,MAAO,kBACrDuJ,EAAEU,QAAQpG,EAAcC,QAAQ,GAAGjD,SAAU+G,EAAE/G,UAC/C0I,EAAEU,QAAQpG,EAAcE,QAAQ,GAAGlD,SAAU+G,EAAE/G,UAInD,GAAIgD,EAAcqG,OAAwC,IAA/BrG,EAAcqG,MAAMvG,OAC7C,IAAK,IAAIyD,EAAI,EAAGA,EAAIvD,EAAcqG,MAAMvG,OAAQyD,IAAK,CACnD,IAAIQ,EAAI/D,EAAcqG,MAAM9C,GAC5BmC,EAAEM,QAAQjC,EAAE/G,SAAU,CACpBiJ,MAAOlC,EAAExC,OACT9E,MAAO,IACPyJ,OAAQ,IACRC,MAAO,YAETT,EAAEU,QAAQrC,EAAE/G,SAAUK,EAAI,CAAE4I,MAAO,OAAQ9J,MAAO,kBAItD,GAAI6D,EAAcsG,UAA8C,IAAlCtG,EAAcsG,SAASxG,OACnD,IAAK,IAAIyD,EAAI,EAAGA,EAAIvD,EAAcsG,SAASxG,OAAQyD,IAAK,CACtD,IAAIQ,EAAI/D,EAAcsG,SAAS/C,GAC/BmC,EAAEM,QAAQjC,EAAE/G,SAAU,CACpBiJ,MAAOlC,EAAExC,OACT9E,MAAO,IACPyJ,OAAQ,IACRC,MAAO,YAETT,EAAEU,QAAQrC,EAAE/G,SAAUK,EAAI,CAAE4I,MAAO,UAAW9J,MAAO,kBAKzD,GAAI6D,EAAcM,UAA8C,IAAlCN,EAAcM,SAASR,OACnD,IAAK,IAAIyD,EAAI,EAAGA,EAAIvD,EAAcM,SAASR,OAAQyD,IAEjD,IADA,IAAIQ,EAAI/D,EAAcM,SAASiD,GAAGC,MACzB+C,EAAI,EAAGA,EAAIxC,EAAEjE,OAAQyG,IAE1B/I,EAASuG,EAAEwC,GAAGvJ,WACgC,UAA9CQ,EAASuG,EAAEwC,GAAGvJ,UAAU,mBAExB0I,EAAEM,QAAQjC,EAAEwC,GAAGvJ,SAAU,CACvBiJ,MAAOlC,EAAEwC,GAAGhF,OACZ9E,MAAO,IACPyJ,OAAQ,IACRC,MAAO,YAETT,EAAEU,QAAQ/I,EAAI0G,EAAEwC,GAAGvJ,SAAU,CAC3BiJ,MAAO,QACP9J,MAAO,qBAGTqB,EAASuG,EAAEwC,GAAGvJ,WACiC,uBAA9CQ,EAASuG,EAAEwC,GAAGvJ,UAAU,mBAErB,8BADFQ,EAASuG,EAAEwC,GAAGvJ,UAAU,oBAG1B0I,EAAEM,QAAQjC,EAAEwC,GAAGvJ,SAAU,CACvBiJ,MAAOlC,EAAEwC,GAAGhF,OACZ9E,MAAO,IACPyJ,OAAQ,IACRC,MAAO,UACPhK,MAAO,gBAETuJ,EAAEU,QAAQ/I,EAAI0G,EAAEwC,GAAGvJ,SAAU,CAC3BiJ,MAAO,QACP9J,MAAO,oBAGXuJ,EAAEM,QAAQhG,EAAcM,SAASiD,GAAGD,cAAe,CACjD2C,MAAOzF,EAAQhD,EAASwC,EAAcM,SAASiD,GAAGD,gBAClD7G,MAAO,IACPyJ,OAAQ,IACRC,MAAO,YAETT,EAAEU,QAAQpG,EAAcM,SAASiD,GAAGD,cAAeS,EAAEwC,GAAGvJ,SAAU,CAChEiJ,MAAO,eACP9J,MAAO,iBAMf,IAAIqK,EAAQd,EAAEc,QACd,GAAIf,EAAQ,EACV,IAAK,IAAIlC,EAAI,EAAGA,EAAIiD,EAAM1G,OAAQyD,IAGhCwC,EACEL,EACAD,EAAQ,EACRe,EAAMjD,GAAGkD,EACT9G,EAAgB6G,EAAMjD,GAAGkD,GAAGzG,gB,yBC6BrB0G,E,YAtMb,WAAY/J,GAAQ,IAAD,8BACjB,4CAAMA,KACDgK,kBAAoB,EAAKA,kBAAkBzJ,KAAvB,gBAFR,E,iFAKjB,IAAK8H,EAAiB1H,KAAKX,MAAMqD,eAAgB,CAC/C,IAAI0F,EAAIF,EAAS,EAAGlI,KAAKX,MAAMU,GAAIC,KAAKX,MAAMqD,eAC9CmE,QAAQC,IAAI,0BAA2BsB,GACvC,IAAIkB,EAAS,IAAIC,IAAQD,OACrBE,EAAMC,SAAUzJ,KAAK0J,UACzBJ,EAAOG,SAAUzJ,KAAK2J,eAAgBvB,GACtCoB,EAAII,KAAK,SAAUxB,EAAEyB,QAAQjB,OAAS,O,2CAaxC,IAAKlB,EAAiB1H,KAAKX,MAAMqD,eAAgB,CAC/C,IAAI0F,EAAIF,EAAS,EAAGlI,KAAKX,MAAMU,GAAIC,KAAKX,MAAMqD,eAC9CmE,QAAQC,IAAI,0BAA2BsB,EAAEc,SAezC,IAAII,EAAS,IAAIC,IAAQD,OAGrBE,EAAMC,SAAUzJ,KAAK0J,UAMzBJ,EAAOG,SAAUzJ,KAAK2J,eAAgBvB,GAMtCoB,EAAII,KAAK,SAAUxB,EAAEyB,QAAQjB,OAAS,IAEtC/B,QAAQC,IAAI,QAAS9G,KAAKX,OAEPmK,EAAIM,UAAU,UACpBC,GAAG,QAAS/J,KAAKqJ,sB,wCAIhBtJ,GAChBC,KAAKX,MAAM2K,oBAAoBjK,K,+BAGvB,IAAD,OACP,OA6BE,yBACElB,MAAO,CAAEoL,SAAU,OAAQvI,UAAW,QAAS3C,UAAW,WAE1D,yBACEgB,GAAG,WACHmK,IAAK,SAAAA,GACH,EAAKR,SAAWQ,GAElB/K,MAAM,OACNyJ,OAAO,QAEP,uBACEsB,IAAK,SAAAzD,GACH,EAAKkD,cAAgBlD,W,GAtHTvE,IAAMC,W,kBCocjBgI,E,YAvab,WAAY9K,GAAa,IAAD,8BACtB,4CAAMA,KAMDE,MAAQ,CACXQ,GAAI,UACJkD,KAAM,GACNP,cAAe,CACbC,QAAS,GACTC,QAAS,GACTC,SAAU,GACVC,KAAM,GACNC,QAAS,GACTC,SAAU,IAEZG,QAAS,GACTC,KAAM,GACNC,aAAa,EACbC,gBAAiB,CAAE5D,SAAU,GAAI6D,QAAS,KAM5C,EAAK6G,kBAAoB,EAAKA,kBAAkBxK,KAAvB,gBA3BH,E,4EAmCT2D,GACb,IAAIxD,EAAKwD,EAAQO,QACbuG,EAAiBC,EAASvK,GAAIwK,OAC9BC,EAAgBF,EAASvK,GAAI0K,MAC7B5G,EAAgByG,EAASvK,GAAI2K,QAC7B3G,EAAcR,EAAQS,MAGtB2G,EAAc,GACdC,EAAWN,EAASvK,GAAI,WAAWa,MAAM,MAc7C,OAPA+J,EAAM,sCALJA,EADEC,EAASpI,QAAU,EACfoI,EAAS,GAETN,EAASvK,GAAI,YAIC,KAAlBwD,EAAQS,QAEV2G,EAAMA,EAAM,KADZ5G,EAAMuG,EAASvG,GAAK2G,UAGtBC,GAAY,uBAGV,8BACG,MACD,uBACE1G,OAAO,SACP4G,IAAI,sBACJC,KAAMH,EACN9L,MAAO,CACLkM,MAAO,OACPtJ,SAAU,WAGX4I,EAAS,KACV,0BAAMxL,MAAO,CAAEmM,UAAW,WAAaR,GAVzC,IAUwD3G,EACrDA,IAAUE,GAAe,KAARA,EAAa,IAAMA,EAAM,IAE5C,O,wCAKWrE,GAChBmH,QAAQC,IAAI,UAAWpH,EAAUM,KAAKX,OACtCe,IAAQC,MAAM,CACZC,SAAU,cACVC,OAAQ,gDAEVP,KAAKX,MAAM4L,QAAQ5G,KAAK,iBAAmB3E,K,oCAG/BwL,EAAsBC,GAAuB,IAAD,OAExD,OAAsD,IAD3CnL,KACFT,MAAMmD,cAAcwI,GAAc1I,OAEvC,yBAAK3D,MAAO,CAAEuM,MAAO,SACnB,yBACEvM,MAAO,CACLwM,WAAY,OACZC,cAAe,YACfC,MAAO,OACPC,aAAc,OACdC,UAAW,WAGsC,IAAlDzL,KAAKT,MAAMmD,cAAcwI,GAAc1I,QACW,eAAnDxC,KAAKT,MAAMmD,cAAcwI,GAAc,GAAG9H,KACtCsI,IAAUC,SAAST,GAAgB,KACnCA,EAAe,MAErB,yBAAKrM,MAAO,CAAE0M,MAAO,OAAQE,UAAW,WAlBnCzL,KAmBGT,MAAMmD,cAAcwI,GAAcrJ,IAAI,SAAAC,GAC1C,OACE,yBAAKjD,MAAO,CAAEwC,OAAQ,MACnB,EAAKuK,yBACJ9J,EACAoJ,EACAC,QASP,O,+CAKTrJ,EACAoJ,EACAC,GACC,IAAD,OAGA,MACoB,YAAjBD,GAA8BpJ,EAAO8C,wBACpB,YAAjBsG,GAA8BpJ,EAAOgD,uBAGpC,8BACE,yBACE7C,UAAU,gBACVD,QAAS,kBAAM,EAAKoI,kBAAkBtI,EAAOpC,YAE5CoC,IAZE9B,KAYcT,MAAMmD,cAAcwI,GAAc,GACjD,qCAEA,GAEF,0BAAMrM,MAAO,CAAEgN,eAAgB,cAAgB/J,EAAOmC,SAExD,qDACCkH,EACGrJ,EAAOyB,QAAQ1B,IAAI,SAAA0B,GACjB,OAAO,EAAKuI,eAAevI,KAE7B,IAGkB,YAAjB2H,GAA8BpJ,EAAOkD,YAE5C,8BACGlD,IA9BI9B,KA8BYT,MAAMmD,cAAcwI,GAAc,GACjD,qCAEA,GAEF,iDACCC,EACGrJ,EAAOyB,QAAQ1B,IAAI,SAAA0B,GACjB,OAAO,EAAKuI,eAAevI,KAE7B,IAGkB,aAAjB2H,EAEP,yBAAKjJ,UAAU,wBACb,yBAAKA,UAAU,yBA9CVjC,KA+CG+L,sBAAsBjK,IAE9B,yBAAKG,UAAU,0BAAf,OACO,IACL,0BACEA,UAAU,sBACVpD,MAAO,CAAEwC,OAAQ,GACjBW,QAAS,kBAAM,EAAKoI,kBAAkBtI,EAAOkE,iBAE5C9C,EAAQhD,EAAS4B,EAAOkE,mBAO/B,8BACE,yBACE/D,UAAU,gBACVD,QAAS,kBAAM,EAAKoI,kBAAkBtI,EAAOpC,YAE5CoC,IApEE9B,KAoEcT,MAAMmD,cAAcwI,GAAc,IAClC,aAAjBA,GACiB,aAAjBA,GACiB,YAAjBA,EACE,qCAEA,GAEF,0BAAMrM,MAAO,CAAEgN,eAAgB,cAAgB/J,EAAOmC,SAEvDkH,EACCrJ,EAAOyB,QAAQ1B,IAAI,SAAA0B,GACjB,OAAO,EAAKuI,eAAevI,KAG7B,0BAAM1E,MAAO,CAAE2M,aAAc,c,4CAOjBQ,GAAa,IAAD,OAChC,OAAOA,EAAM9F,MAAMrE,IAAI,SAAAkE,GACrB,OACE,yBACE9D,UAAU,sBACVD,QAAS,kBAAM,EAAKoI,kBAAkBrE,EAAErG,YAEvCqG,EAAE9B,Y,6CAMa,IAAD,OAErB,GAAkC,IADvBjE,KACFT,MAAM4D,QAAQX,OACrB,OACE,yBAAK3D,MAAO,CAAE4M,UAAW,OAAQ1M,UAAW,WAC1C,yBACEF,MAAO,CACLwM,WAAY,OACZC,cAAe,YACfO,eAAgB,YAChBI,aAAc,WALlB,YAJKjM,KAcCT,MAAM4D,QAAQtB,IAAI,SAAAqK,GACtB,OACE,yBAAKrN,MAAO,CAAEwC,OAAQ,MACpB,0BACEY,UAAU,oBACVD,QAAS,kBAAM,EAAKoI,kBAAkB8B,EAAOxM,YAE5CwM,EAAOjI,QAETiI,EAAO3I,QAAQ1B,IAAI,SAAA0B,GAClB,OAAO,EAAKuI,eAAevI,W,2CAUrB,IAAD,OACnB,MAC0C,KAAxCvD,KAAKT,MAAM+D,gBAAgB5D,UAC3BM,KAAKT,MAAM+D,gBAAgBC,UAAY,GAGrC,yBACExD,GAAG,2BACHkC,UAC0C,KAAxCjC,KAAKT,MAAM+D,gBAAgB5D,UAC3BM,KAAKT,MAAM+D,gBAAgBC,UAAY,GACnC,aACA,IANR,uBASuB,IACoB,KAAxCvD,KAAKT,MAAM+D,gBAAgB5D,SAC1B,GAEA,8BACE,0BACEuC,UAAU,oBACVD,QAAS,kBACP,EAAKoI,kBAAkB,EAAK7K,MAAM+D,gBAAgB5D,YAGnDwD,EAAQhD,EAASF,KAAKT,MAAM+D,gBAAgB5D,YAE9CM,KAAKT,MAAM+D,gBAAgBC,QAAQ1B,IAAI,SAAA0B,GACtC,OAAO,EAAKuI,eAAevI,OAO9B,O,0CAST,IAAM4I,EAASC,IAAYC,MAAMrM,KAAKX,MAAMiN,SAASC,OAAOC,MAAM,IAC5DzM,EAAKoM,EAAOpM,GAClB,GAAKoM,EAAOpM,GAIL,CAEL,IAAI0M,EAAWpK,EAAgBtC,GAC/BC,KAAKe,SAAS,CACZhB,GAAI0M,EAAS1M,GACb2C,cAAe+J,EAAS/J,cACxBS,QAASsJ,EAAStJ,QAClBF,KAAMwJ,EAASxJ,KACfG,KAAMqJ,EAASrJ,KACfC,YAAaoJ,EAASpJ,YACtBC,gBAAiBmJ,EAASnJ,uBAX5BtD,KAAKe,SAAS,CAAEsC,aAAa,M,2CAiB/B,IAAM8I,EAASC,IAAYC,MAAMrM,KAAKX,MAAMiN,SAASC,OAAOC,MAAM,IAC5DzM,EAAKoM,EAAOpM,GAClB,GAAKoM,EAAOpM,IAIL,GAAIC,KAAKT,MAAMQ,KAAOA,EAAI,CAG/B,IAAI0M,EAAWpK,EAAgBtC,GAC/BC,KAAKe,SAAS,CACZhB,GAAI0M,EAAS1M,GACb2C,cAAe+J,EAAS/J,cACxBS,QAASsJ,EAAStJ,QAClBF,KAAMwJ,EAASxJ,KACfG,KAAMqJ,EAASrJ,KACfC,YAAaoJ,EAASpJ,YACtBC,gBAAiBmJ,EAASnJ,wBAZ5BtD,KAAKe,SAAS,CAAEsC,aAAa,M,+BAqBvB,IAAD,OACP,OACE,kBAAC,IAAMjC,SAAP,KACE,yBACEa,UAAWjC,KAAKT,MAAM8D,YAAc,aAAe,GACnDxE,MAAO,CAAEE,UAAW,SAAU2N,QAAS,SAFzC,kEAMA,yBAAKzK,UAAWjC,KAAKT,MAAM8D,YAAc,GAAK,cAC5C,yBACExE,MAAO,CACLwC,OAAQ,sBACRqL,QAAS,OACTC,QAAS,YACTC,OAAQ,oBAGV,yBAAK7M,GAAG,oBAAoBC,KAAKT,MAAM0D,MACvC,yBAAKlD,GAAG,uBHube,SAACA,GAClC,IAAII,EAAuB,GAM3B,OALAA,GAAgBwH,EAAc,yBAA0BxH,EAAcJ,GACtEI,GAAgBwH,EAAc,mBAAoBxH,EAAcJ,GAChEI,GAAgBwH,EAAc,sBAAuBxH,EAAcJ,GAG9C,MAFrBI,GAAgBwH,EAAc,oBAAqBxH,EAAcJ,IAGxDI,EAEA,mBAAqBA,EAAe,IGhchC0M,CAAoB7M,KAAKT,MAAMQ,KAElC,yBAAKA,GAAG,oBAAR,aAAsCC,KAAKT,MAAMQ,IACjD,yBACEA,GAAG,sBACHkC,UAAwC,KAA7BmC,EAAUpE,KAAKT,MAAMQ,IAAa,aAAe,IAF9D,WAIWqE,EAAUpE,KAAKT,MAAMQ,KAGhC,yBACEkC,UACEyF,EAAiB1H,KAAKT,MAAMmD,eAAiB,GAAK,eAItD,6BAAM1C,KAAK8M,sBAGVnL,OAAO6F,KAAKxH,KAAKT,MAAMmD,eAAeb,IAAI,SAAAV,GACzC,MAAY,YAARA,GAA6B,YAARA,GAA6B,YAARA,EACrC,yBAAKA,IAAKA,GAAM,EAAK4L,cAAc5L,GAAK,IAExC,yBAAKA,IAAKA,GAAM,EAAK4L,cAAc5L,GAAK,MAGnD,6BAAMnB,KAAKgN,0BAIf,kBAAC,EAAD,CACEjN,GAAIC,KAAKT,MAAMQ,GACf2C,cAAe1C,KAAKT,MAAMmD,cAC1BsH,oBAAqBhK,KAAKoK,yB,GAjaZlI,IAAMC,W,QCiBf8K,E,YAtCb,WAAY5N,GAAa,IAAD,8BACtB,4CAAMA,KACDE,MAAQ,CACX2N,UAAW,IAHS,E,0EAOXC,GACXnN,KAAKe,SAAS,CAAEmM,UAAWC,M,0CAI3B/M,IAAQgN,WAAW,kBACnBhN,IAAQiN,SAAS,e,+BAIjB,OACE,yBACExO,MAAO,CAAEyO,gBAAiB,UAAW1E,OAAQ,OAAQzJ,MAAO,SAE5D,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAMM,GAAG,KACP,kBAAC,EAAD,OAEF,kBAAC,EAAD,MACA,kBAAC,IAAD,KAEE,kBAAC,IAAD,CAAO8N,KAAK,UAAUC,UAAWpO,IACjC,kBAAC,IAAD,CAAOmO,KAAK,aAAaC,UAAWrD,IACpC,kBAAC,IAAD,CAAOqD,UAAW,kBAAM,kBAAC,IAAD,CAAU/N,GAAG,gB,GA/B/ByC,IAAMC,WCFJsL,QACW,cAA7BC,OAAOpB,SAASqB,UAEe,UAA7BD,OAAOpB,SAASqB,UAEhBD,OAAOpB,SAASqB,SAASC,MACvB,2DCZNC,IAASvE,OAAO,kBAAC,EAAD,MAAS7I,SAASC,eAAe,SDmI3C,kBAAmBoN,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC,gB","file":"static/js/main.9d8b7ef8.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/arrow.1cd80763.svg\";","module.exports = __webpack_public_path__ + \"static/media/logo.1740fffd.svg\";","import React from \"react\";\nimport \"./App.css\";\n\nconst Header: React.FC = () => {\n  return (\n    <div style={{ paddingTop: \"4rem\", textAlign: \"center\" }}>\n      <img\n        src={require(\"./images/logo.svg\")}\n        alt=\"Manto logo\"\n        style={{ width: \"20%\" }}\n      ></img>\n    </div>\n  );\n};\n\nexport default Header;\n","import React from \"react\";\nimport \"./App.css\";\nimport entities from \"./data/entities.json\";\nimport { Redirect } from \"react-router-dom\";\nimport arrow from \"./images/arrow.svg\";\nimport ReactGA from \"react-ga\";\n\ntype SearchProps = {};\ntype SearchState = {\n  redirect: boolean;\n  targetID: string;\n};\n\nclass Search extends React.Component<SearchProps, SearchState> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      redirect: false,\n      targetID: \"\"\n    };\n    // this.onSearchSubmit = this.onSearchSubmit.bind(this);\n    this.handleSearch = this.handleSearch.bind(this);\n    this.handleSearchKeyDown = this.handleSearchKeyDown.bind(this);\n    this.getDescriptors = this.getDescriptors.bind(this);\n  }\n\n  getDescriptors(id: string) {\n    if (this.hasKey(entities, id)) {\n      let alternatives: string = \"\";\n      if (entities[id][\"Name (transliteration)\"] !== \"\") {\n        alternatives =\n          alternatives + \", \" + entities[id][\"Name (transliteration)\"];\n      }\n      if (entities[id][\"Name (Latinized)\"] !== \"\") {\n        alternatives = alternatives + \", \" + entities[id][\"Name (Latinized)\"];\n      }\n      if (entities[id][\"Name in Latin texts\"] !== \"\") {\n        alternatives =\n          alternatives + \", \" + entities[id][\"Name in Latin texts\"];\n      }\n      if (entities[id][\"Alternative names\"] !== \"\") {\n        alternatives = alternatives + \", \" + entities[id][\"Alternative names\"];\n      }\n      let inputText =\n        entities[id][\"Name (Smith & Trzaskoma)\"] +\n        alternatives +\n        \": \" +\n        entities[id][\"Identifying information\"];\n      return inputText;\n    }\n  }\n\n  pageRedirect = () => {\n    if (this.state.redirect) {\n      return <Redirect to={\"/datacards?id=\" + this.state.targetID} />;\n    }\n  };\n\n  handleSearch() {\n    ReactGA.event({\n      category: \"Search\",\n      action: \"User searched for an entity using the search bar\"\n    });\n    let currentInput = document.getElementById(\"input\") as HTMLInputElement;\n    if (currentInput.value !== \"\") {\n      //Search based on name and identifying information - super inefficient. TODO: fix this\n      for (let id in entities) {\n        if (this.hasKey(entities, id)) {\n          if (\n            entities[id][\"Identifying information\"] ===\n            currentInput.value.split(\": \")[1]\n          ) {\n            let currentInputName = currentInput.value\n              .split(\": \")[0]\n              .split(\",\")[0]\n              .trim();\n\n            if (\n              currentInputName === entities[id][\"Name (Smith & Trzaskoma)\"] ||\n              currentInputName === entities[id][\"Name (transliteration)\"] ||\n              currentInputName === entities[id][\"Name (Latinized)\"] ||\n              currentInputName === entities[id][\"Name in Latin texts\"] ||\n              currentInputName === entities[id][\"Alternative names\"]\n            ) {\n              this.setState({\n                redirect: true,\n                targetID: id\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n\n  handleSearchKeyDown(event: any) {\n    if (event.which === 13 || event.keyCode === 13) {\n      this.handleSearch();\n    }\n  }\n\n  /* Addresses typescript indexing objects error */\n  hasKey<O>(obj: O, key: keyof any): key is keyof O {\n    return key in obj;\n  }\n\n  render() {\n    /* const entitiesArray = Object.values(entities).map(entity => {\n      return {\n        // what to show to the user\n        label: entity.ID + \": \" + this.getDescriptors(entity.ID),\n        // key to identify the item within the array\n        key: entity.ID\n      };\n    }); */\n    return (\n      <React.Fragment>\n        {/* <h3 style={{ textAlign: \"center\" }}>SEARCH</h3> */}\n        {this.pageRedirect()}\n        <div\n          style={{\n            margin: \"1rem 0 1rem 0\",\n            textAlign: \"center\"\n          }}\n        >\n          {/* <DataListInput\n          placeholder={\"Search by entity name...\"}\n          items={entitiesArray}\n          onSelect={this.pageRedirect}\n          match={this.matchCurrentInput}\n        /> */}\n          <input\n            // type=\"search\"\n            placeholder=\"Search by name\"\n            id=\"input\"\n            list=\"entities\"\n            onKeyDown={this.handleSearchKeyDown}\n            style={{ width: \"50%\", textAlign: \"center\", fontSize: \"1rem\" }}\n          ></input>\n          <datalist id=\"entities\" style={{ maxHeight: \"100px\" }}>\n            {Object.values(entities).map(entity => {\n              return (\n                <option\n                  value={this.getDescriptors(entity[\"\\ufeffID\"])}\n                ></option>\n              );\n            })}\n          </datalist>\n          <div>\n            <img\n              alt=\"Submit search\"\n              src={arrow}\n              onClick={this.handleSearch}\n              className=\"search-arrow\"\n            ></img>\n          </div>\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default Search;\n","import ties from \"./data/ties.json\";\nimport entities from \"./data/entities.json\";\n\ntype passageInfo = {\n  start: string;\n  startID: string;\n  end: string;\n  endID: string;\n};\n\ntype entityInfo = {\n  target: string;\n  targetID: string;\n  passage: passageInfo[];\n  type: string;\n  autochthony?: boolean;\n  mother_parthenogenesis?: boolean;\n  father_parthenogenesis?: boolean;\n};\n\ntype childrenInfo = {\n  child: entityInfo[];\n  otherParentID: string;\n  divineParentID?: string;\n};\n\nexport type relationshipInfo = {\n  MOTHERS: entityInfo[];\n  FATHERS: entityInfo[];\n  SIBLINGS: entityInfo[];\n  TWIN: entityInfo[];\n  SPOUSES: entityInfo[];\n  CHILDREN: childrenInfo[];\n};\n\ntype returningInfo = {\n  id: string;\n  relationships: relationshipInfo;\n  name: string;\n  members: any[];\n  type: string;\n  validSearch: boolean;\n  alternativeName: { targetID: string; passage: passageInfo[] };\n};\n\nlet familyTies = [\n  /* Parent */\n  \"is father of\",\n  \"is mother of\",\n  \"is parent of\",\n  /* Child */\n  \"is child of\",\n  /* Sibling */\n  \"is sibling of\",\n  \"is twin of\",\n  \"is older than\",\n  /* Spouse */\n  \"is spouse of\",\n  \"marries\",\n  /* Ancestors - currently unused\n  \"is grandfather of\",\n  \"is grandmother of\",\n  \"is grandparent of\",\n  \"is grandson of\",\n  \"is granddaughter of\",\n  \"is grandchild of\",\n  */\n\n  /* Member of collective */\n  \"is part of\",\n  \"is member of\",\n\n  /* Unusual relationships */\n  \"is mother by parthenogenesis of\",\n  \"is father by parthenogenesis of\",\n  \"is born by autochthony [in/on/at]\"\n];\n\n/******************************************************************************************/\n/* Returns the data card geneology information, interfaces with DataCards.tsx                \n/******************************************************************************************/\nexport const updateComponent = (id: string) => {\n  let connections = getAllConnections(id);\n  if (\n    connections.length > 0 &&\n    connections[0].verb === \"is alternative name for\"\n  ) {\n    let empty: relationshipInfo = {\n      MOTHERS: [],\n      FATHERS: [],\n      SIBLINGS: [],\n      TWIN: [],\n      SPOUSES: [],\n      CHILDREN: []\n    };\n    let altNameConnection: returningInfo = {\n      id: id,\n      relationships: empty,\n      name: getName(entities[id]),\n      members: [],\n      type: entities[id][\"Type of entity\"],\n      validSearch: true,\n      alternativeName: {\n        targetID: connections[0].targetID,\n        passage: connections[0].passage\n      }\n    };\n    return altNameConnection;\n  } else {\n    return sortConnectionsIntoRelationships(id, connections);\n  }\n};\n\n/******************************************************************************************/\n/* Find all relationships                                                                 */\n/* -------------------------------------------------------------------------------------- */\n/* This function changes all ties (X <verb> Y, Y <verb> X, Z <verb> Y X) to Y <verb> X. */\n/******************************************************************************************/\nconst getAllConnections = (id: string) => {\n  var connections: {\n    target: string;\n    targetID: string;\n    verb: string;\n    passage: passageInfo[];\n  }[] = [];\n\n  Object.values(ties).forEach(function(tieRow) {\n    // TODO: Fix this temporary solution for entities not existing in entities.csv\n    if (entities[tieRow[\"Subject ID\"]]) {\n      //check if the entity is just an \"alternative name for\"\n      //if so, ignore all geneological data gathered so far and just return connections = [{target: \"\", targetID: \"\", verb: \"is alternative name for\", passage:[]}]\n\n      if (\n        tieRow[\"Verb\"] === \"is child of\" &&\n        tieRow[\"Direct Object ID\"] === \"8188818\"\n      ) {\n        // Temporary fix for Is Child Of Crete issue\n      } else {\n        if (\n          tieRow[\"Subject ID\"] === id &&\n          tieRow[\"Verb\"] === \"is alternative name for\"\n        ) {\n          let passageInfo: passageInfo[] = [\n            {\n              start: tieRow[\"Passage: start\"],\n              startID: tieRow[\"Passage: start ID\"],\n              end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n              endID:\n                tieRow[\"Passage: end ID\"] === \"\"\n                  ? \"\"\n                  : tieRow[\"Passage: end ID\"]\n            }\n          ];\n          connections = [\n            {\n              target: \"\",\n              targetID: tieRow[\"Direct Object ID\"],\n              verb: \"is alternative name for\",\n              passage: passageInfo\n            }\n          ];\n          return connections;\n        }\n\n        /*********************************************************/\n        /* If you are the direct object X, e.g. (Y (verb) X)     */\n        /*********************************************************/\n        if (\n          tieRow[\"Direct Object ID\"] === id &&\n          familyTies.includes(tieRow.Verb)\n        ) {\n          let passageInfo: passageInfo[] = [\n            {\n              start: tieRow[\"Passage: start\"],\n              startID: tieRow[\"Passage: start ID\"],\n              end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n              endID:\n                tieRow[\"Passage: end ID\"] === \"\"\n                  ? \"\"\n                  : tieRow[\"Passage: end ID\"]\n            }\n          ];\n\n          // TODO: Fix this temporary solution for gender data not existing for entity\n          if (getGender(tieRow[\"Subject ID\"]) && tieRow.Verb === \"marries\") {\n            tieRow.Verb = \"is spouse of\";\n          }\n\n          // Push connections to the list of connections\n          connections.push({\n            target: getName(entities[tieRow[\"Subject ID\"]]),\n            targetID: tieRow[\"Subject ID\"],\n            verb: tieRow.Verb,\n            passage: passageInfo\n          });\n        }\n\n        /*********************************************************/\n        /* If you are the subject X, e.g. (X (verb) Y)           */\n        /*********************************************************/\n        if (tieRow[\"Subject ID\"] === id && familyTies.includes(tieRow.Verb)) {\n          let passageInfo: passageInfo[] = [\n            {\n              start: tieRow[\"Passage: start\"],\n              startID: tieRow[\"Passage: start ID\"],\n              end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n              endID: tieRow[\"Passage: end ID\"]\n            }\n          ];\n\n          // Push connections to the list of connections\n          if (tieRow.Verb === \"is born by autochthony [in/on/at]\") {\n            connections.push({\n              target: \"\",\n              targetID: \"\",\n              verb: \"is born by autochthony [in/on/at]\",\n              passage: passageInfo\n            });\n          } else {\n            //TODO: Find better fix for this Minos is child of Crete (object) issue\n            if (tieRow[\"Direct Object ID\"] !== \"8188818\") {\n              connections.push({\n                target: getName(entities[tieRow[\"Direct Object ID\"]]),\n                targetID: tieRow[\"Direct Object ID\"],\n                verb: reversedVerb(tieRow.Verb, tieRow[\"Direct Object ID\"]),\n                passage: passageInfo\n              });\n            }\n          }\n        }\n\n        /***********************************************************************/\n        /* For \"Gives in marriage:\" - parent gives child in marriage to person */\n        /*************************************************************************/\n\n        // If you are the indirect object X, e.g. (Z (verb) Y X)\n        if (\n          tieRow[\"Indirect Object (to/for) ID\"] &&\n          tieRow[\"Indirect Object (to/for) ID\"] === id &&\n          tieRow.Verb === \"gives in marriage [dir. obj.] [ind. obj.]\"\n        ) {\n          let passageInfo: passageInfo[] = [\n            {\n              start: tieRow[\"Passage: start\"],\n              startID: tieRow[\"Passage: start ID\"],\n              end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n              endID: tieRow[\"Passage: end ID\"]\n            }\n          ];\n          connections.push({\n            target: getName(entities[tieRow[\"Direct Object ID\"]]),\n            targetID: tieRow[\"Direct Object ID\"],\n            verb: \"is spouse of\",\n            passage: passageInfo\n          });\n        }\n\n        // If you are the direct object X, e.g. (Z (verb) X Y)\n        else if (\n          tieRow[\"Direct Object ID\"] &&\n          tieRow[\"Direct Object ID\"] === id &&\n          tieRow.Verb === \"gives in marriage [dir. obj.] [ind. obj.]\"\n        ) {\n          let passageInfo: passageInfo[] = [\n            {\n              start: tieRow[\"Passage: start\"],\n              startID: tieRow[\"Passage: start ID\"],\n              end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n              endID: tieRow[\"Passage: end ID\"]\n            }\n          ];\n          connections.push({\n            target: getName(entities[tieRow[\"Indirect Object (to/for) ID\"]]),\n            targetID: tieRow[\"Indirect Object (to/for) ID\"],\n            verb: \"is spouse of\",\n            passage: passageInfo\n          });\n        }\n      }\n    }\n  });\n\n  return connections;\n};\n\n/******************************************************************************************/\n/* Sort relationships                                                                     */\n/* -------------------------------------------------------------------------------------- */\n/* This function sorts all of the found connections into existing geneological categories */\n/******************************************************************************************/\nconst sortConnectionsIntoRelationships = (id: string, connections: any) => {\n  /* Preliminary info about the entity */\n  let name = getName(entities[id]);\n  let type = entities[id][\"Type of entity\"];\n  let members: any[] = [];\n  let relationships: relationshipInfo = {\n    MOTHERS: [],\n    FATHERS: [],\n    SIBLINGS: [],\n    TWIN: [],\n    SPOUSES: [],\n    CHILDREN: []\n  };\n\n  let childrenTemp: entityInfo[] = [];\n  connections.forEach(tie => {\n    // For each of the connections already found,\n    // build the associated entity object, and\n    // populate with existing information\n    let d: entityInfo = {\n      target: tie.target,\n      targetID: tie.targetID,\n      passage: tie.passage,\n      type:\n        tie.verb === \"is born by autochthony [in/on/at]\"\n          ? \"\"\n          : entities[tie.targetID][\"Type of entity\"]\n    };\n\n    /* Categorising the connections, also checking for duplicates */\n\n    // X is your MOTHER\n    if (tie.verb === \"is mother of\") {\n      // If passage is a duplicate / already exists\n      // for this entity, or  in the list of connections\n      relationships.MOTHERS = checkAndRemoveDuplicates(\n        relationships.MOTHERS,\n        d\n      );\n    }\n\n    // X is your MOTHER by parthenogenesis\n    else if (tie.verb === \"is mother by parthenogenesis of\") {\n      let m: entityInfo = {\n        target: tie.target,\n        targetID: tie.targetID,\n        passage: tie.passage,\n        type: entities[tie.targetID][\"Type of entity\"],\n        mother_parthenogenesis: true\n      };\n\n      relationships.MOTHERS = checkAndRemoveDuplicates(\n        relationships.MOTHERS,\n        m\n      );\n    }\n\n    // X is your FATHER\n    else if (tie.verb === \"is father of\") {\n      relationships.FATHERS = checkAndRemoveDuplicates(\n        relationships.FATHERS,\n        d\n      );\n    }\n\n    // X is your FATHER by parthenogenesis\n    else if (tie.verb === \"is father by parthenogenesis of\") {\n      let f: entityInfo = {\n        target: tie.target,\n        targetID: tie.targetID,\n        passage: tie.passage,\n        type: entities[tie.targetID][\"Type of entity\"],\n        father_parthenogenesis: true\n      };\n      relationships.FATHERS = checkAndRemoveDuplicates(\n        relationships.FATHERS,\n        f\n      );\n    }\n\n    // X is your CHILD\n    else if (tie.verb === \"is child of\") {\n      childrenTemp = checkAndRemoveDuplicates(childrenTemp, d);\n    }\n\n    // X is your SIBLING\n    else if (tie.verb === \"is sibling of\" || tie.verb === \"is older than\") {\n      relationships.SIBLINGS = checkAndRemoveDuplicates(\n        relationships.SIBLINGS,\n        d\n      );\n    }\n\n    // X is your TWIN\n    else if (tie.verb === \"is twin of\") {\n      relationships.TWIN = checkAndRemoveDuplicates(relationships.TWIN, d);\n    }\n    // X is your WIFE / HUSBAND\n    else if (tie.verb === \"is spouse of\" || tie.verb === \"marries\") {\n      relationships.SPOUSES = checkAndRemoveDuplicates(\n        relationships.SPOUSES,\n        d\n      );\n    }\n    // X is a MEMBER of a collective\n    else if (tie.verb === \"is part of\" || tie.verb === \"is member of\") {\n      members = checkAndRemoveDuplicates(members, d);\n    }\n    // X is born by autochthony\n    else if (tie.verb === \"is born by autochthony [in/on/at]\") {\n      let a: entityInfo = {\n        target: \"\",\n        targetID: \"\",\n        passage: tie.passage,\n        type: entities[id][\"Type of entity\"],\n        autochthony: true\n      };\n      relationships.FATHERS = checkAndRemoveDuplicates(\n        relationships.FATHERS,\n        a\n      );\n    }\n  });\n\n  /* TODO: Check for any indirect siblings in the ties */\n  relationships.SIBLINGS = getIndirectSiblings(\n    id,\n    relationships.MOTHERS,\n    relationships.FATHERS,\n    relationships.SIBLINGS\n  );\n\n  /* Alphabetize the relationships */\n  relationships.MOTHERS = alphabetize(relationships.MOTHERS);\n  relationships.FATHERS = alphabetize(relationships.FATHERS);\n  relationships.SIBLINGS = alphabetize(relationships.SIBLINGS);\n  relationships.TWIN = alphabetize(relationships.TWIN);\n  relationships.SPOUSES = alphabetize(relationships.SPOUSES);\n  members = alphabetize(members);\n\n  // Currently very inefficient, but finds the other parent of the child\n  relationships.CHILDREN = getOtherParents(id, childrenTemp);\n  relationships.CHILDREN = alphabetizeChildren(relationships.CHILDREN);\n\n  /* Return alphabetized, complete list of relationships */\n  let connection: returningInfo = {\n    id: id,\n    relationships: relationships,\n    name: name,\n    members: members,\n    type: type,\n    validSearch: true,\n    alternativeName: { targetID: \"\", passage: [] }\n  };\n  return connection;\n};\n\n/******************************************************************************************/\n/* Check passage and entity duplicates                                                    */\n/* -------------------------------------------------------------------------------------- */\n/* This function removes duplicate ties (incl. after reversal) and duplicate passages   */\n/* for the same connected entity                                                          */\n/******************************************************************************************/\nconst checkAndRemoveDuplicates = (entities: any[], d: entityInfo) => {\n  let duplicate = false;\n  entities.forEach(e => {\n    if (e.targetID === d.targetID) {\n      duplicate = true;\n      let passageDuplicate = false;\n      e.passage.forEach(p => {\n        if (\n          p.startID === d.passage[0].startID &&\n          p.endID === d.passage[0].endID\n        ) {\n          passageDuplicate = true;\n        }\n      });\n      if (!passageDuplicate) {\n        e.passage.push(d.passage[0]);\n      }\n    }\n  });\n  if (!duplicate) {\n    entities.push(d);\n  }\n  return entities;\n};\n\nconst checkAndRemoveParentDuplicates = (\n  parentID: string, //parent\n  newChild: entityInfo, //child entity info\n  children: childrenInfo[] //parentsGrouped - existing parents list\n) => {\n  // This function removes duplicates but also groups children by the \"other\" parent\n  // returns childrenInfo object: {child: <list of associated children>, otherParentID}\n  let parentDuplicate = false;\n  let childDuplicate = false;\n  children.forEach(c => {\n    if (c.otherParentID === parentID) {\n      parentDuplicate = true;\n      for (let i = 0; i < c.child.length; i++) {\n        if (c.child[i].targetID === newChild.targetID) {\n          childDuplicate = true;\n        }\n      }\n      if (!childDuplicate) {\n        c.child.push(newChild);\n      }\n    }\n  });\n  if (!parentDuplicate) {\n    children.push({ child: [newChild], otherParentID: parentID });\n  }\n\n  return children;\n};\n\n/******************************************************************************************/\n/* Alphabetize the list of names in each category                                         */\n/******************************************************************************************/\nconst alphabetize = (relation: any[]) => {\n  if (relation.length === 0) {\n    return [];\n  } else {\n    relation.sort(function(a, b) {\n      var relationA = a.target.toUpperCase();\n      var relationB = b.target.toUpperCase();\n      return relationA < relationB ? -1 : relationA > relationB ? 1 : 0;\n    });\n  }\n  return relation;\n};\n\nconst alphabetizeChildren = (relation: childrenInfo[]) => {\n  if (relation.length === 0) {\n    return [];\n  } else {\n    relation.forEach(r => {\n      r.child = alphabetize(r.child);\n    });\n    relation.sort(function(a, b) {\n      var relationA = getName(entities[a.otherParentID]);\n      var relationB = getName(entities[b.otherParentID]);\n      return relationA < relationB ? -1 : relationA > relationB ? 1 : 0;\n    });\n  }\n  return relation;\n};\n\n/******************************************************************************************/\n/* TODO: Fix this very VERY inefficient method of finding the other parent                */\n/******************************************************************************************/\nconst getOtherParents = (id: string, children: entityInfo[]) => {\n  let mainGender = getGender(id);\n  let parentsGrouped: childrenInfo[] = [];\n  children.forEach(c => {\n    Object.values(ties).forEach(function(tieRow) {\n      // Attempting to fix child of Crete issue\n      if (tieRow[\"Direct Object ID\"] !== \"8188818\") {\n        // rudimentary solution for entities causing errors\n        if (mainGender === \"Female\") {\n          // Y is CHILD of Z, where Y is child of X and X != Z\n          if (\n            tieRow[\"Subject ID\"] === c.targetID &&\n            tieRow[\"Verb\"] === \"is child of\" &&\n            tieRow[\"Direct Object ID\"] !== id\n          ) {\n            if (\n              entities[tieRow[\"Direct Object ID\"]] &&\n              getGender(tieRow[\"Direct Object ID\"]) === \"Male\" &&\n              entities[tieRow[\"Direct Object ID\"]][\"Type of entity\"] === \"Agent\"\n            ) {\n              parentsGrouped = checkAndRemoveParentDuplicates(\n                tieRow[\"Direct Object ID\"],\n                c,\n                parentsGrouped\n              );\n            }\n          }\n          // Z is FATHER of Y, where Y is child of X and X != Z\n          else if (\n            tieRow[\"Direct Object ID\"] === c.targetID &&\n            tieRow[\"Verb\"] === \"is father of\" &&\n            tieRow[\"Subject ID\"] !== id\n          ) {\n            if (\n              entities[tieRow[\"Subject ID\"]] &&\n              getGender(tieRow[\"Subject ID\"]) === \"Male\" &&\n              entities[tieRow[\"Subject ID\"]][\"Type of entity\"] === \"Agent\"\n            ) {\n              parentsGrouped = checkAndRemoveParentDuplicates(\n                tieRow[\"Subject ID\"],\n                c,\n                parentsGrouped\n              );\n            }\n          }\n        }\n        // rudimentary solution for entities causing errors\n        if (mainGender === \"Male\") {\n          // Y is CHILD of Z, where Y is child of X and X != Z\n          if (\n            tieRow[\"Subject ID\"] === c.targetID &&\n            tieRow[\"Verb\"] === \"is child of\" &&\n            tieRow[\"Direct Object ID\"] !== id\n          ) {\n            if (\n              entities[tieRow[\"Direct Object ID\"]] &&\n              getGender(tieRow[\"Direct Object ID\"]) === \"Female\" &&\n              entities[tieRow[\"Direct Object ID\"]][\"Type of entity\"] === \"Agent\"\n            ) {\n              parentsGrouped = checkAndRemoveParentDuplicates(\n                tieRow[\"Direct Object ID\"],\n                c,\n                parentsGrouped\n              );\n            }\n          }\n          // Z is MOTHER of Y, where Y is child of X and X != Z\n          else if (\n            tieRow[\"Direct Object ID\"] === c.targetID &&\n            tieRow[\"Verb\"] === \"is mother of\" &&\n            tieRow[\"Subject ID\"] !== id\n          ) {\n            if (\n              entities[tieRow[\"Subject ID\"]] &&\n              getGender(tieRow[\"Subject ID\"]) === \"Female\" &&\n              entities[tieRow[\"Subject ID\"]][\"Type of entity\"] === \"Agent\"\n            ) {\n              parentsGrouped = checkAndRemoveParentDuplicates(\n                tieRow[\"Subject ID\"],\n                c,\n                parentsGrouped\n              );\n            }\n          }\n        }\n      }\n    });\n  });\n  // TODO: FIX PARENTS NOT SHOWING UP\n  return parentsGrouped;\n};\n\n/******************************************************************************************/\n/* Get the gender of the entity                                                           */\n/******************************************************************************************/\nexport const getGender = (id: string) => {\n  if (id === \"8188818\") {\n    return \"Female\";\n  } else {\n    return entities[id][\"Agent/Coll.: gender\"];\n  }\n};\n\n/******************************************************************************************/\n/* Tie reversals                                                   */\n/* -------------------------------------------------------------------------------------- */\n/* This function flips the verb so that X can become the direct object,                   */\n/* without compromising the validity of the tie                                         */\n/*                                                                                        */\n/* e.g. X <is mother of> Y, where Y is <male>                                             */\n/* => returns verb <is son of>, to let X become the direct object (Y is son of X)         */\n/******************************************************************************************/\nconst reversedVerb = (verb: string, dirObject: string) => {\n  // TODO: Fix this temporary solution for gender data not existing for entity\n  // PARENT -> CHILD\n  if (verb === \"is parent of\") {\n    // Uses generic \"is child of\" since data cards do not show gender specificity for children\n    return \"is child of\";\n  }\n\n  // CHILD -> PARENT\n  else if (verb === \"is child of\") {\n    if (getGender(dirObject) === \"Female\") {\n      return \"is mother of\";\n    } else if (getGender(dirObject) === \"Male\") {\n      return \"is father of\";\n    } else {\n      // Placeholder since \"is parent of\" is not currently used in data cards\n      return \"\";\n    }\n  }\n\n  // TWIN -> TWIN\n  else if (verb === \"is twin of\") {\n    return \"is twin of\";\n  }\n\n  // SIBLING -> SIBLING\n  else if (verb === \"is sibling of\" || verb === \"is older than\") {\n    return \"is sibling of\";\n  }\n\n  // WIFE -> HUSBAND\n  // HUSBAND -> WIFE\n  // No cases of homosexual relationships in the mythology\n  else if (verb === \"is spouse of\" || verb === \"marries\") {\n    return \"is spouse of\";\n  }\n\n  // TODO: Deal with IS MEMBER OF verb here.\n  else if (verb === \"is member of\" || verb === \"is part of\") {\n    console.log(\"Trying to reverse\", dirObject, \"is member of\");\n    return \"\";\n  } else {\n    console.log(\n      \"Unsure of \" +\n        verb +\n        \" \" +\n        dirObject +\n        \" connection, or connection is not relevant for the datacards.\",\n      verb,\n      dirObject\n    );\n    return \"\";\n  }\n};\n\n/******************************************************************************************/\n/* Populate an array of siblings based on matching parents                                */\n/* -------------------------------------------------------------------------------------- */\n/* This function checks through the list of ties and pushes to the list of siblings:    */\n/*                                                                                        */\n/* e.g. X is <child> of A, X is <child> of B, Y is <child> of A, Y is <child> of B        */\n/******************************************************************************************/\nconst getIndirectSiblings = (\n  id: string,\n  mothers: any[],\n  fathers: any[],\n  siblings: any[]\n) => {\n  // CURRENTLY A VERY SLOW SOLUTION - OPTIMIZE IT LATER\n  // CHANGE TO POPULATING A DATABASE OF RELATIONS AND READING OFF THAT DATABASE\n  // RATHER THAN DYNAMICALLY GENERATING IT HERE (CHANGE TO O(N) NOT LEAVE AS O(N^3))\n  // ALTERNATIVELY: Use Nodegoat ID to determine those in the same datum ID, and then match those\n\n  let newsiblings: {} = {};\n  Object.values(ties).forEach(function(tieRow) {\n    let testsibling = {\n      motherMatch: false,\n      fatherMatch: false,\n      info: {}\n    };\n    let passageInfo: passageInfo[] = [\n      {\n        start: tieRow[\"Passage: start\"],\n        startID: tieRow[\"Passage: start ID\"],\n        end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n        endID: tieRow[\"Passage: end ID\"]\n      }\n    ];\n    let testinfo: entityInfo = {\n      target: \"\",\n      targetID: \"\",\n      passage: passageInfo,\n      type: entities[id][\"Type of entity\"]\n    };\n    // Firstly, determine where Y is <child> of A,B\n    if (\n      tieRow.Verb === \"is daughter of\" ||\n      tieRow.Verb === \"is son of\" ||\n      tieRow.Verb === \"is child of\"\n    ) {\n      mothers.forEach(m => {\n        if (m.targetID === tieRow[\"Direct Object ID\"]) {\n          testsibling.motherMatch = true;\n          testinfo.target = getName(entities[tieRow[\"Subject ID\"]]);\n          testinfo.targetID = tieRow[\"Subject ID\"];\n          testsibling.info = testinfo;\n          if (!(tieRow[\"Subject ID\"] in newsiblings)) {\n            newsiblings[tieRow[\"Subject ID\"]] = testsibling;\n          } else {\n            newsiblings[tieRow[\"Subject ID\"]].motherMatch = true;\n          }\n        }\n      });\n      fathers.forEach(f => {\n        if (f.targetID === tieRow[\"Direct Object ID\"]) {\n          testsibling.fatherMatch = true;\n          testinfo.target = getName(entities[tieRow[\"Subject ID\"]]);\n          testinfo.targetID = tieRow[\"Subject ID\"];\n          testsibling.info = testinfo;\n          if (!(tieRow[\"Subject ID\"] in newsiblings)) {\n            newsiblings[tieRow[\"Subject ID\"]] = testsibling;\n          } else {\n            newsiblings[tieRow[\"Subject ID\"]].fatherMatch = true;\n          }\n        }\n      });\n    }\n    // Then, determine where A is mother of Y, or if parent of Y where A is female\n    if (\n      tieRow.Verb === \"is mother of\" ||\n      tieRow.Verb === \"is divine mother of\" ||\n      (tieRow.Verb === \"is parent of\" &&\n        entities[tieRow[\"Subject ID\"]] &&\n        entities[tieRow[\"Subject ID\"]][\"Agent/Coll.: gender\"] === \"Female\")\n    ) {\n      mothers.forEach(m => {\n        if (m.targetID === tieRow[\"Subject ID\"]) {\n          testsibling.motherMatch = true;\n          testinfo.target = getName(entities[tieRow[\"Direct Object ID\"]]);\n          testinfo.targetID = tieRow[\"Direct Object ID\"];\n          testsibling.info = testinfo;\n          if (!(tieRow[\"Direct Object ID\"] in newsiblings)) {\n            newsiblings[tieRow[\"Direct Object ID\"]] = testsibling;\n          } else {\n            newsiblings[tieRow[\"Direct Object ID\"]].motherMatch = true;\n          }\n        }\n      });\n    }\n    // Then, determine where A is father of Y, or if parent of Y where A is male\n    if (\n      tieRow.Verb === \"is father of\" ||\n      tieRow.Verb === \"is divine father of\" ||\n      (tieRow.Verb === \"is parent of\" &&\n        entities[tieRow[\"Subject ID\"]] &&\n        entities[tieRow[\"Subject ID\"]][\"Agent/Coll.: gender\"] === \"Male\")\n    ) {\n      fathers.forEach(f => {\n        if (f.targetID === tieRow[\"Subject ID\"]) {\n          testsibling.fatherMatch = true;\n          testinfo.target = getName(entities[tieRow[\"Direct Object ID\"]]);\n          testinfo.targetID = tieRow[\"Direct Object ID\"];\n          testsibling.info = testinfo;\n          if (!(tieRow[\"Direct Object ID\"] in newsiblings)) {\n            newsiblings[tieRow[\"Direct Object ID\"]] = testsibling;\n          } else {\n            newsiblings[tieRow[\"Direct Object ID\"]].fatherMatch = true;\n          }\n        }\n      });\n    }\n  });\n  let keys: any[] = Object.keys(newsiblings);\n  keys.forEach(k => {\n    if (\n      !newsiblings[k].motherMatch ||\n      !newsiblings[k].fatherMatch ||\n      k === id\n    ) {\n      delete newsiblings[k];\n    } else {\n      siblings = checkAndRemoveDuplicates(siblings, newsiblings[k].info);\n    }\n  });\n  return siblings;\n};\n\n/******************************************************************************************/\n/* Check if no relations exist for this entity (used in DataCards.tsx)                    */\n/******************************************************************************************/\nexport const checkNoRelations = (relationships: any) => {\n  return (\n    relationships.MOTHERS.length === 0 &&\n    relationships.FATHERS.length === 0 &&\n    relationships.SIBLINGS.length === 0 &&\n    relationships.TWIN.length === 0 &&\n    relationships.SPOUSES.length === 0 &&\n    relationships.CHILDREN.length === 0\n  );\n};\n\n/******************************************************************************************/\n/* Return all alternative names for entity (used in DataCards.tsx)                        */\n/******************************************************************************************/\nexport const getAlternativeNames = (id: string) => {\n  let alternatives: string = \"\";\n  alternatives += getNameString(\"Name (transliteration)\", alternatives, id);\n  alternatives += getNameString(\"Name (Latinized)\", alternatives, id);\n  alternatives += getNameString(\"Name in Latin texts\", alternatives, id);\n  alternatives += getNameString(\"Alternative names\", alternatives, id);\n\n  if (alternatives === \"\") {\n    return alternatives;\n  } else {\n    return \"(Also known as: \" + alternatives + \")\";\n  }\n};\n\nconst getNameString = (parameter: string, stringSoFar: string, id: string) => {\n  let s = \"\";\n  if (entities[id][parameter] !== \"\") {\n    if (stringSoFar === \"\") {\n      s = entities[id][parameter];\n    } else {\n      s = stringSoFar + \", \" + entities[id][parameter];\n    }\n  }\n  return s;\n};\n\n/******************************************************************************************/\n/* Get the entity's name                                                                  */\n/******************************************************************************************/\nexport const getName = (entityRow: any) => {\n  let possibleNames = [\n    \"Name (Smith & Trzaskoma)\",\n    \"Name (transliteration)\",\n    \"Name (Latinized)\",\n    \"Name in Latin texts\",\n    \"Alternative names\"\n  ];\n  for (let i = 0; i < possibleNames.length; i++) {\n    if (\n      entityRow[possibleNames[i]] &&\n      entityRow[possibleNames[i]] !== \"\" &&\n      entityRow[possibleNames[i]] !== undefined\n    ) {\n      return entityRow[possibleNames[i]];\n    }\n  }\n};\n","import entities from \"./data/entities.json\";\nimport { updateComponent, getName } from \"./DataCardHandler\";\nimport \"./EntityGraph.scss\";\n\n/*\n\nexport type relationshipInfo = {\n  MOTHERS: entityInfo[];\n  FATHERS: entityInfo[];\n  SIBLINGS: entityInfo[];\n  WIVES: entityInfo[];\n  HUSBANDS: entityInfo[];\n  CHILDREN: entityInfo[];\n};\n\n*/\n\nexport const getGraph = (depth: number, id: string, relationships: any) => {\n  // ignores initial empty relationship graph generation\n  // Generate all connections in GraphLib form\n  var dagreD3 = require(\"dagre-d3\");\n  // let Graph = require(\"@dagrejs/graphlib\").Graph;\n  // var g = new Graph({ directed: true, multigraph: true, compound: true });\n\n  // Establish the graph and set the graph's name\n  let g = new dagreD3.graphlib.Graph().setGraph({\n    name: getName(entities[id]) + \" relationships\"\n  });\n  g.setDefaultEdgeLabel(function() {\n    return {};\n  });\n\n  getAllLinks(g, depth, id, relationships);\n\n  /* TODO: How to address partners, e.g. fathers linked to mothers if have multiple fathers or multiple mothers */\n\n  /*\n    var svg = d3.select(\"svg\"),\n      inner = svg.select(\"g\");\n\n    // Create the renderer\n    let render = new dagreD3.render();\n    // Run the renderer and draw the final graph\n    render.run(inner, g);\n    */\n  return g;\n};\n\nconst getAllLinks = (g: any, depth: number, id: string, relationships: any) => {\n  g.setNode(id, { label: getName(entities[id]), width: 144, height: 100 });\n\n  if (relationships.MOTHERS && relationships.MOTHERS.length !== 0) {\n    for (let i = 0; i < relationships.MOTHERS.length; i++) {\n      let r = relationships.MOTHERS[i];\n      g.setNode(r.targetID, {\n        label: r.target,\n        width: 144,\n        height: 100,\n        shape: \"ellipse\"\n      });\n      g.setEdge(r.targetID, id, { label: \"mother\", style: \"stroke: red\" });\n      // g.setParent(id, r.targetID); //make compound subgraphs, r.targetID is parent of id\n    }\n  }\n\n  if (relationships.FATHERS && relationships.FATHERS.length !== 0) {\n    for (let i = 0; i < relationships.FATHERS.length; i++) {\n      let r = relationships.FATHERS[i];\n      g.setNode(r.targetID, {\n        label: r.target,\n        width: 144,\n        height: 100,\n        shape: \"ellipse\"\n      });\n      g.setEdge(r.targetID, id, { label: \"father\", style: \"stroke: blue\" });\n      // g.setParent(id, r.targetID); //make compound subgraphs, r.targetID is parent of id\n    }\n  }\n\n  if (\n    (relationships.SIBLINGS && relationships.SIBLINGS.length !== 0) ||\n    (relationships.TWIN && relationships.TWIN.length !== 0)\n  ) {\n    for (let i = 0; i < relationships.SIBLINGS.length; i++) {\n      let r = relationships.SIBLINGS[i];\n      g.setNode(r.targetID, {\n        label: r.target,\n        width: 144,\n        height: 100,\n        shape: \"ellipse\"\n      });\n      g.setEdge(r.targetID, id, { label: \"sibling\", style: \"stroke: green\" });\n      g.setEdge(relationships.MOTHERS[0].targetID, r.targetID);\n      g.setEdge(relationships.FATHERS[0].targetID, r.targetID);\n    }\n  }\n\n  if (relationships.WIVES && relationships.WIVES.length !== 0) {\n    for (let i = 0; i < relationships.WIVES.length; i++) {\n      let r = relationships.WIVES[i];\n      g.setNode(r.targetID, {\n        label: r.target,\n        width: 144,\n        height: 100,\n        shape: \"ellipse\"\n      });\n      g.setEdge(r.targetID, id, { label: \"wife\", style: \"stroke: black\" });\n    }\n  }\n\n  if (relationships.HUSBANDS && relationships.HUSBANDS.length !== 0) {\n    for (let i = 0; i < relationships.HUSBANDS.length; i++) {\n      let r = relationships.HUSBANDS[i];\n      g.setNode(r.targetID, {\n        label: r.target,\n        width: 144,\n        height: 100,\n        shape: \"ellipse\"\n      });\n      g.setEdge(r.targetID, id, { label: \"husband\", style: \"stroke: black\" });\n    }\n  }\n\n  // Add nodes for children, and add links for other parents of children (aka. mistresses but not spouses)\n  if (relationships.CHILDREN && relationships.CHILDREN.length !== 0) {\n    for (let i = 0; i < relationships.CHILDREN.length; i++) {\n      let r = relationships.CHILDREN[i].child;\n      for (let j = 0; j < r.length; j++) {\n        if (\n          entities[r[j].targetID] &&\n          entities[r[j].targetID][\"Type of entity\"] === \"Agent\"\n        ) {\n          g.setNode(r[j].targetID, {\n            label: r[j].target,\n            width: 144,\n            height: 100,\n            shape: \"ellipse\"\n          });\n          g.setEdge(id, r[j].targetID, {\n            label: \"child\",\n            style: \"stroke: yellow\"\n          });\n        } else if (\n          entities[r[j].targetID] &&\n          (entities[r[j].targetID][\"Type of entity\"] === \"Collective (misc.)\" ||\n            entities[r[j].targetID][\"Type of entity\"] ===\n              \"Collective (genealogical)\")\n        ) {\n          g.setNode(r[j].targetID, {\n            label: r[j].target,\n            width: 144,\n            height: 100,\n            shape: \"ellipse\",\n            style: \"stroke: red\"\n          });\n          g.setEdge(id, r[j].targetID, {\n            label: \"child\",\n            style: \"stroke: yellow\"\n          });\n        }\n        g.setNode(relationships.CHILDREN[i].otherParentID, {\n          label: getName(entities[relationships.CHILDREN[i].otherParentID]),\n          width: 144,\n          height: 100,\n          shape: \"ellipse\"\n        });\n        g.setEdge(relationships.CHILDREN[i].otherParentID, r[j].targetID, {\n          label: \"other parent\",\n          style: \"stroke: grey\"\n        });\n      }\n    }\n  }\n\n  let edges = g.edges();\n  if (depth > 1) {\n    for (let i = 0; i < edges.length; i++) {\n      // Does this actually update g?\n      // Recursive call to getAllLinks()\n      getAllLinks(\n        g,\n        depth - 1,\n        edges[i].v,\n        updateComponent(edges[i].v).relationships\n      );\n    }\n  }\n};\n","import React from \"react\";\nimport \"./App.css\";\nimport { getGraph } from \"./GraphHandler\";\nimport { checkNoRelations, getName } from \"./DataCardHandler\";\nimport entities from \"./data/entities.json\";\nimport * as d3 from \"d3\";\nimport dagreD3 from \"dagre-d3\";\n\nclass EntityGraph extends React.Component {\n  // For Refs, see: https://stackoverflow.com/questions/33796267/how-to-use-refs-in-react-with-typescript\n  // For general setup, see: https://stackoverflow.com/questions/32292622/react-component-with-dagre-d3-not-drawing-correctly/32293469#32293469\n  // For findDOMNode in Typescript, see: https://stackoverflow.com/questions/32480321/using-react-finddomnode-in-typescript\n  // How to use DagreJS https://dagrejs.github.io/project/dagre-d3/latest/demo/interactive-demo.html\n\n  constructor(props) {\n    super(props);\n    this.handleClickedNode = this.handleClickedNode.bind(this);\n  }\n  componentDidMount() {\n    if (!checkNoRelations(this.props.relationships)) {\n      let g = getGraph(1, this.props.id, this.props.relationships);\n      console.log(\"Final connections found\", g);\n      var render = new dagreD3.render();\n      let svg = d3.select(this.nodeTree);\n      render(d3.select(this.nodeTreeGroup), g);\n      svg.attr(\"height\", g.graph().height + 40);\n    }\n  }\n\n  componentDidUpdate() {\n    /* d3.select(this.state.ref)\n      .append(\"circle\")\n      .attr(\"r\", 5)\n      .attr(\"cx\", \"500px\")\n      .attr(\"cy\", \"500px\")\n      .attr(\"fill\", \"red\"); */\n\n    // Return the graph with populated nodes\n    if (!checkNoRelations(this.props.relationships)) {\n      let g = getGraph(1, this.props.id, this.props.relationships);\n      console.log(\"Final connections found\", g.edges());\n\n      /*\n      // Create the renderer\n      var renderer = new dagreD3.render();\n\n      // Set up an SVG group so that we can translate the final graph.\n      var svg = d3.select(\"svg\"),\n        svgGroup = svg.append(\"g\");\n\n      //Run the renderer, draw the final graph\n      renderer(d3.select(\"svg g\"), g);\n      */\n\n      // Create the renderer\n      var render = new dagreD3.render();\n\n      // Set up an SVG group so that we can translate the final graph.\n      let svg = d3.select(this.nodeTree);\n\n      /* var svg = d3.select(ReactDOM.findDOMNode(this.nodeTreeRef));\n      var svgGroup = d3.select(ReactDOM.findDOMNode(this.nodeTreeGroupRef)); */\n\n      // Run the renderer. This is what draws the final graph.\n      render(d3.select(this.nodeTreeGroup), g);\n\n      // Center the graph\n      // var xCenterOffset = 10; // svg.attr(\"width\") - g.graph().width) / 2;\n      // svgGroup.attr(\"transform\", \"translate(\" + xCenterOffset + \", 20)\");\n\n      svg.attr(\"height\", g.graph().height + 40);\n\n      console.log(\"first\", this.props);\n\n      var nodeSelected = svg.selectAll(\"g.node\");\n      nodeSelected.on(\"click\", this.handleClickedNode);\n    }\n  }\n\n  handleClickedNode(id) {\n    this.props.relationshipClicked(id);\n  }\n\n  render() {\n    return (\n      /* <svg\n        className=\"container\"\n        ref={this.setRef(new SVGSVGElement())}\n        width={\"500px\"}\n        height={\"500px\"}\n      ></svg> */\n\n      /* <div>\n        <div style={{ border: \"1px solid red\" }}>\n          <svg id=\"nodeTree\" ref=\"nodeTreeRef\" width=\"960\" height=\"600\">\n            <g ref=\"nodeTreeGroupRef\" />\n          </svg>\n        </div>\n        <svg\n          viewBox=\"0 0 300 100\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          stroke=\"red\"\n          fill=\"grey\"\n        >\n          <circle cx=\"50\" cy=\"50\" r=\"40\" />\n          <circle cx=\"150\" cy=\"50\" r=\"4\" />\n\n          <svg viewBox=\"0 0 10 10\" x=\"200\" width=\"100\">\n            <circle cx=\"5\" cy=\"5\" r=\"4\" />\n          </svg>\n        </svg>\n      </div> */\n\n      <div\n        style={{ maxWidth: \"100%\", maxHeight: \"20rem\", textAlign: \"center\" }}\n      >\n        <svg\n          id=\"nodeTree\"\n          ref={ref => {\n            this.nodeTree = ref;\n          }}\n          width=\"150%\"\n          height=\"1000\"\n        >\n          <g\n            ref={r => {\n              this.nodeTreeGroup = r;\n            }}\n          />\n        </svg>\n      </div>\n    );\n  }\n}\n//   constructor() {\n//     super();\n//   }\n\n//   componentDidUpdate() {\n//     if (!checkNoRelations(this.props.relationships)) {\n//       // Create the input graph\n//       let g = new dagreD3.graphlib.Graph().setGraph({\n//         name: getName(entities[this.props.id]) + \" relationships\"\n//       });\n//       // Set an object for the graph label\n//       // g.setGraph({});\n\n//       // Default to assigning a new object as a label for each new edge.\n//       g.setDefaultEdgeLabel(function() {\n//         return {};\n//       });\n\n//       // Add nodes to the graph. The first argument is the node id. The second is\n//       // metadata about the node. In this case we're going to add labels to each of\n//       // our nodes.\n\n//       //     let g = getGraph(1, this.props.id, this.props.relationships);\n\n//       g.setNode(\"kspacey\", { label: \"Kevin Spacey\", width: 144, height: 100 });\n//       g.setNode(\"swilliams\", {\n//         label: \"Saul Williams\",\n//         width: 160,\n//         height: 100\n//       });\n//       g.setNode(\"bpitt\", { label: \"Brad Pitt\", width: 108, height: 100 });\n//       g.setNode(\"hford\", { label: \"Harrison Ford\", width: 168, height: 100 });\n//       g.setNode(\"lwilson\", { label: \"Luke Wilson\", width: 144, height: 100 });\n//       g.setNode(\"kbacon\", { label: \"Kevin Bacon\", width: 121, height: 100 });\n\n//       // Add edges to the graph.\n//       g.setEdge(\"kspacey\", \"swilliams\");\n//       g.setEdge(\"swilliams\", \"kbacon\");\n//       g.setEdge(\"bpitt\", \"kbacon\");\n//       g.setEdge(\"hford\", \"lwilson\");\n//       g.setEdge(\"lwilson\", \"kbacon\");\n\n//       // don't know where is dagre coming from\n//       //dagre.layout(g);\n\n//       // Create the renderer\n//       let render = new dagreD3.render();\n\n//       // Set up an SVG group so that we can translate the final graph.\n//       let svg = d3.select(this.nodeTree);\n\n//       // Run the renderer. This is what draws the final graph.\n//       render(d3.select(this.nodeTreeGroup), g);\n\n//       svg.attr(\"height\", g.graph().height + 40);\n//     }\n//   }\n\n//   render() {\n//     return (\n//       <svg\n//         id=\"nodeTree\"\n//         ref={ref => {\n//           this.nodeTree = ref;\n//         }}\n//         width=\"960\"\n//         height=\"600\"\n//       >\n//         <g\n//           ref={r => {\n//             this.nodeTreeGroup = r;\n//           }}\n//         />\n//       </svg>\n//     );\n//   }\n// }\n\nexport default EntityGraph;\n","import React from \"react\";\nimport \"./App.css\";\nimport \"./DataCards.scss\";\nimport queryString from \"querystring\";\nimport passages from \"./data/passages.json\";\nimport EntityGraph from \"./EntityGraph.jsx\";\nimport ReactGA from \"react-ga\";\nimport entities from \"./data/entities.json\";\nimport {\n  relationshipInfo,\n  updateComponent,\n  checkNoRelations,\n  getAlternativeNames,\n  getGender,\n  getName\n} from \"./DataCardHandler\";\nimport Pluralize from \"pluralize\";\n\ntype DatumProps = {\n  location: {\n    search: string;\n  };\n  history: {\n    push: ({}) => null;\n  };\n};\ntype DatumState = {\n  id: string;\n  name: string;\n  relationships: relationshipInfo;\n  members: any[];\n  type: string;\n  validSearch: boolean;\n  alternativeName: { targetID: string; passage: any[] };\n};\n\nclass DataCards extends React.Component<DatumProps, DatumState> {\n  constructor(props: any) {\n    super(props);\n    // Dionysus is 8188175, use to test multiple names\n    // Atreus is 8187873\n    // Theseus is 8188822\n    // Agamemnon is 8182035\n    // Use Clytaimnestra example, 8188055\n    this.state = {\n      id: \"8182035\", // placeholder\n      name: \"\",\n      relationships: {\n        MOTHERS: [],\n        FATHERS: [],\n        SIBLINGS: [],\n        TWIN: [],\n        SPOUSES: [],\n        CHILDREN: []\n      },\n      members: [],\n      type: \"\",\n      validSearch: false,\n      alternativeName: { targetID: \"\", passage: [] }\n    };\n    /* this.getNameFromID = this.getNameFromID.bind(this);\n    this.checkNoRelations = this.checkNoRelations.bind(this);\n    this.reversedVerb = this.reversedVerb.bind(this);\n    this.getDataPoints = this.getDataPoints.bind(this); */\n    this.handleNameClicked = this.handleNameClicked.bind(this);\n    /* this.getAlternativeNames = this.getAlternativeNames.bind(this); */\n  }\n\n  /*******************/\n  /* HELPER FUNCTIONS */\n  /*******************/\n\n  getPassageLink(passage: any) {\n    let id = passage.startID;\n    let author: string = passages[id].Author;\n    let title: string = passages[id].Title;\n    let start: string = passages[id].Passage;\n    let end: string = passage.endID;\n\n    // Dealing with multiple URNs\n    let URN: string = \"\";\n    let URNsplit = passages[id][\"CTS URN\"].split(\", \");\n    if (URNsplit.length >= 2) {\n      URN = URNsplit[1];\n    } else {\n      URN = passages[id][\"CTS URN\"];\n    }\n\n    URN = \"https://scaife.perseus.org/reader/\" + URN;\n    if (passage.endID !== \"\") {\n      end = passages[end].Passage;\n      URN = URN + \"-\" + end;\n    }\n    URN = URN + \"/?right=perseus-eng2\";\n\n    return (\n      <span>\n        {\"  (\"}\n        <a\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          href={URN}\n          style={{\n            color: \"grey\",\n            fontSize: \"0.8rem\"\n          }}\n        >\n          {author + \", \"}\n          <span style={{ fontStyle: \"italic\" }}>{title}</span> {start}\n          {start !== end && end !== \"\" ? \"-\" + end : \"\"}\n        </a>\n        {\")\"}\n      </span>\n    );\n  }\n\n  handleNameClicked(targetID: string) {\n    console.log(\"clicked\", targetID, this.props);\n    ReactGA.event({\n      category: \"NameClicked\",\n      action: \"User clicked on a name within the data card\"\n    });\n    this.props.history.push(\"/datacards?id=\" + targetID);\n  }\n\n  getDataPoints(relationship: string, showPassage: boolean) {\n    let that = this;\n    if (that.state.relationships[relationship].length !== 0) {\n      return (\n        <div style={{ clear: \"both\" }}>\n          <div\n            style={{\n              fontWeight: \"bold\",\n              textTransform: \"uppercase\",\n              float: \"left\",\n              paddingRight: \"1rem\",\n              marginTop: \"0.5rem\"\n            }}\n          >\n            {this.state.relationships[relationship].length === 1 &&\n            this.state.relationships[relationship][0].type !== \"Collective\"\n              ? Pluralize.singular(relationship) + \": \"\n              : relationship + \": \"}\n          </div>\n          <div style={{ float: \"left\", marginTop: \"0.5rem\" }}>\n            {that.state.relationships[relationship].map(entity => {\n              return (\n                <div style={{ margin: \"0\" }}>\n                  {this.checkUnusualRelationship(\n                    entity,\n                    relationship,\n                    showPassage\n                  )}\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  checkUnusualRelationship(\n    entity: any,\n    relationship: any,\n    showPassage: boolean\n  ) {\n    let that = this;\n\n    if (\n      (relationship === \"MOTHERS\" && entity.mother_parthenogenesis) ||\n      (relationship === \"FATHERS\" && entity.father_parthenogenesis)\n    ) {\n      return (\n        <span>\n          <div\n            className=\"entity-button\"\n            onClick={() => this.handleNameClicked(entity.targetID)}\n          >\n            {entity !== that.state.relationships[relationship][0] ? (\n              <span>OR </span>\n            ) : (\n              \"\"\n            )}\n            <span style={{ textDecoration: \"underline\" }}>{entity.target}</span>\n          </div>\n          <span> by pathenogenesis </span>\n          {showPassage\n            ? entity.passage.map(passage => {\n                return this.getPassageLink(passage);\n              })\n            : \"\"}\n        </span>\n      );\n    } else if (relationship === \"FATHERS\" && entity.autochthony) {\n      return (\n        <span>\n          {entity !== that.state.relationships[relationship][0] ? (\n            <span>OR </span>\n          ) : (\n            \"\"\n          )}\n          <span>By autochthony </span>\n          {showPassage\n            ? entity.passage.map(passage => {\n                return this.getPassageLink(passage);\n              })\n            : \"\"}\n        </span>\n      );\n    } else if (relationship === \"CHILDREN\") {\n      return (\n        <div className=\"entity-child-wrapper\">\n          <div className=\"entity-child-grouping\">\n            {that.getChildParentGrouped(entity)}\n          </div>\n          <div className=\"entity-parent-grouping\">\n            with{\" \"}\n            <span\n              className=\"entity-child-button\"\n              style={{ margin: 0 }}\n              onClick={() => this.handleNameClicked(entity.otherParentID)}\n            >\n              {getName(entities[entity.otherParentID])}\n            </span>\n          </div>\n        </div>\n      );\n    } else {\n      return (\n        <span>\n          <div\n            className=\"entity-button\"\n            onClick={() => this.handleNameClicked(entity.targetID)}\n          >\n            {entity !== that.state.relationships[relationship][0] &&\n            relationship !== \"CHILDREN\" &&\n            relationship !== \"SIBLINGS\" &&\n            relationship !== \"SPOUSES\" ? (\n              <span>OR </span>\n            ) : (\n              \"\"\n            )}\n            <span style={{ textDecoration: \"underline\" }}>{entity.target}</span>\n          </div>\n          {showPassage ? (\n            entity.passage.map(passage => {\n              return this.getPassageLink(passage);\n            })\n          ) : (\n            <span style={{ paddingRight: \"10rem\" }}></span>\n          )}\n        </span>\n      );\n    }\n  }\n\n  getChildParentGrouped(group: any) {\n    return group.child.map(c => {\n      return (\n        <div\n          className=\"entity-child-button\"\n          onClick={() => this.handleNameClicked(c.targetID)}\n        >\n          {c.target}\n        </div>\n      );\n    });\n  }\n\n  getCollectiveMembers() {\n    let that = this;\n    if (that.state.members.length !== 0) {\n      return (\n        <div style={{ marginTop: \"3rem\", textAlign: \"center\" }}>\n          <div\n            style={{\n              fontWeight: \"bold\",\n              textTransform: \"uppercase\",\n              textDecoration: \"underline\",\n              marginBottom: \"0.5rem\"\n            }}\n          >\n            MEMBERS:\n          </div>\n          {that.state.members.map(member => {\n            return (\n              <div style={{ margin: \"0\" }}>\n                <span\n                  className=\"collective-button\"\n                  onClick={() => this.handleNameClicked(member.targetID)}\n                >\n                  {member.target}\n                </span>\n                {member.passage.map(passage => {\n                  return this.getPassageLink(passage);\n                })}\n              </div>\n            );\n          })}\n        </div>\n      );\n    }\n  }\n\n  getAlternativePage() {\n    if (\n      this.state.alternativeName.targetID !== \"\" &&\n      this.state.alternativeName.passage !== []\n    ) {\n      return (\n        <div\n          id=\"datacard-alternativename\"\n          className={\n            this.state.alternativeName.targetID === \"\" ||\n            this.state.alternativeName.passage === []\n              ? \"no-display\"\n              : \"\"\n          }\n        >\n          Alternative name for{\" \"}\n          {this.state.alternativeName.targetID === \"\" ? (\n            \"\"\n          ) : (\n            <span>\n              <span\n                className=\"entity-alt-button\"\n                onClick={() =>\n                  this.handleNameClicked(this.state.alternativeName.targetID)\n                }\n              >\n                {getName(entities[this.state.alternativeName.targetID])}\n              </span>\n              {this.state.alternativeName.passage.map(passage => {\n                return this.getPassageLink(passage);\n              })}\n            </span>\n          )}\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  /*******************/\n  /* SETUP FUNCTIONS */\n  /*******************/\n\n  componentDidMount() {\n    const params = queryString.parse(this.props.location.search.slice(1));\n    const id = params.id as string;\n    if (!params.id) {\n      // Handle bad url\n      //@ts-ignore\n      this.setState({ validSearch: false });\n    } else {\n      //Substitute with ID\n      let newState = updateComponent(id);\n      this.setState({\n        id: newState.id,\n        relationships: newState.relationships,\n        members: newState.members,\n        name: newState.name,\n        type: newState.type,\n        validSearch: newState.validSearch,\n        alternativeName: newState.alternativeName\n      });\n    }\n  }\n\n  componentDidUpdate() {\n    const params = queryString.parse(this.props.location.search.slice(1));\n    const id = params.id as string;\n    if (!params.id) {\n      // Handle bad url\n      //@ts-ignore\n      this.setState({ validSearch: false });\n    } else if (this.state.id !== id) {\n      //Substitute with ID\n      // this.updateComponent(this.state.id);\n      let newState = updateComponent(id);\n      this.setState({\n        id: newState.id,\n        relationships: newState.relationships,\n        members: newState.members,\n        name: newState.name,\n        type: newState.type,\n        validSearch: newState.validSearch,\n        alternativeName: newState.alternativeName\n      });\n    }\n  }\n\n  /*************/\n  /* RENDERING */\n  /*************/\n\n  render() {\n    return (\n      <React.Fragment>\n        <div\n          className={this.state.validSearch ? \"no-display\" : \"\"}\n          style={{ textAlign: \"center\", padding: \"3rem\" }}\n        >\n          No profiles have been selected. Try using the Search function.\n        </div>\n        <div className={this.state.validSearch ? \"\" : \"no-display\"}>\n          <div\n            style={{\n              margin: \"1rem 6rem 3rem 6rem\",\n              padding: \"3rem\",\n              display: \"flow-root\",\n              border: \"solid 1px black\"\n            }}\n          >\n            <div id=\"datacard-heading\">{this.state.name}</div>\n            <div id=\"datacard-othernames\">\n              {getAlternativeNames(this.state.id)}\n            </div>\n            <div id=\"datacard-mantoID\">MANTO ID: {this.state.id}</div>\n            <div\n              id=\"datacard-othernames\"\n              className={getGender(this.state.id) === \"\" ? \"no-display\" : \"\"}\n            >\n              Gender: {getGender(this.state.id)}\n            </div>\n            {/* If no data is available for the subject */}\n            <div\n              className={\n                checkNoRelations(this.state.relationships) ? \"\" : \"no-display\"\n              }\n            ></div>\n            {/* If current entity is an alternative name for an existing entity */}\n            <div>{this.getAlternativePage()}</div>\n\n            {/* If data is available for the subject */}\n            {Object.keys(this.state.relationships).map(key => {\n              if (key === \"MOTHERS\" || key === \"FATHERS\" || key === \"SPOUSES\") {\n                return <div key={key}>{this.getDataPoints(key, true)}</div>;\n              } else {\n                return <div key={key}>{this.getDataPoints(key, false)}</div>;\n              }\n            })}\n            <div>{this.getCollectiveMembers()}</div>\n          </div>\n        </div>\n\n        <EntityGraph\n          id={this.state.id}\n          relationships={this.state.relationships}\n          relationshipClicked={this.handleNameClicked}\n        ></EntityGraph>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default DataCards;\n","import React from \"react\";\nimport \"./App.css\";\nimport Header from \"./Header\";\nimport Search from \"./Search\";\nimport DataCards from \"./DataCards\";\nimport ReactGA from \"react-ga\";\nimport {\n  HashRouter as Router,\n  Route,\n  Link,\n  Switch,\n  Redirect\n} from \"react-router-dom\";\n\nclass App extends React.Component<{}, {}> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      subjectID: \"\"\n    };\n  }\n\n  changeEntity(ID: string) {\n    this.setState({ subjectID: ID });\n  }\n\n  initializeReactGA() {\n    ReactGA.initialize(\"UA-151993194-1\");\n    ReactGA.pageview(\"/homepage\");\n  }\n\n  render() {\n    return (\n      <div\n        style={{ backgroundColor: \"#eeeeee\", height: \"100%\", width: \"100%\" }}\n      >\n        <Router>\n          <Link to=\"/\">\n            <Header></Header>\n          </Link>\n          <Search></Search>\n          <Switch>\n            {/* <Route exact path=\"/\" component={Home} /> */}\n            <Route path=\"/search\" component={Search} />\n            <Route path=\"/datacards\" component={DataCards} />\n            <Route component={() => <Redirect to=\"/\" />} />\n          </Switch>\n        </Router>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}