{"version":3,"sources":["images/arrow.svg","images/logo.svg","Header.tsx","Search.tsx","EntityGraph.tsx","DataCards.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Header","style","paddingTop","textAlign","src","require","alt","width","Search","props","pageRedirect","state","redirect","to","targetID","handleSearch","bind","handleSearchKeyDown","getDescriptors","id","this","hasKey","entities","alternatives","document","getElementById","value","setState","split","event","which","keyCode","obj","key","Fragment","margin","placeholder","list","onKeyDown","fontSize","maxHeight","Object","values","map","entity","ID","arrow","onClick","className","React","Component","EntityGraph","familyDatums","DataCards","name","relationships","MOTHERS","FATHERS","SIBLINGS","WIVES","HUSBANDS","CHILDREN","validSearch","getNameFromID","checkNoRelations","reversedVerb","getDataPoints","handleNameClicked","getAlternativeNames","params","queryString","parse","location","search","slice","updateComponent","that","connections","datum","forEach","datumRow","includes","Verb","passageInfo","start","startID","end","endID","push","target","verb","passage","d","wasDuplicate","mother","father","children","siblings","wives","husbands","genderData","gender","fathers","passages","author","Author","title","Title","Passage","URN","URNsplit","length","rel","href","color","fontStyle","dirObject","console","log","history","relationship","clear","fontWeight","textTransform","float","paddingRight","Pluralize","singular","getPassageLink","padding","display","border","keys","App","subjectID","backgroundColor","height","path","component","Boolean","window","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.908e30dd.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/arrow.1cd80763.svg\";","module.exports = __webpack_public_path__ + \"static/media/logo.1740fffd.svg\";","import React from \"react\";\nimport \"./App.css\";\n\nconst Header: React.FC = () => {\n  return (\n    <div style={{ paddingTop: \"4rem\", textAlign: \"center\" }}>\n      <img\n        src={require(\"./images/logo.svg\")}\n        alt=\"Manto logo\"\n        style={{ width: \"20%\" }}\n      ></img>\n    </div>\n  );\n};\n\nexport default Header;\n","import React from \"react\";\nimport \"./App.css\";\nimport entities from \"./data/entities.json\";\nimport { Redirect } from \"react-router-dom\";\nimport arrow from \"./images/arrow.svg\";\n\ntype SearchProps = {};\ntype SearchState = {\n  redirect: boolean;\n  targetID: string;\n};\n\nclass Search extends React.Component<SearchProps, SearchState> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      redirect: false,\n      targetID: \"\"\n    };\n    // this.onSearchSubmit = this.onSearchSubmit.bind(this);\n    this.handleSearch = this.handleSearch.bind(this);\n    this.handleSearchKeyDown = this.handleSearchKeyDown.bind(this);\n    this.getDescriptors = this.getDescriptors.bind(this);\n  }\n\n  /* getMatches(oginput: string) {\n    // Rudimentary name-exact search algorithm, to update with search-by-subject-ID, as well as mistyping of certain names\n    let matches: string[] = [];\n    let inputLC = oginput.toLowerCase();\n    let input = inputLC.charAt(0).toUpperCase() + inputLC.slice(1);\n    Object.values(entities).forEach(entity => {\n      if (\n        entity[\"Type of entity\"] === \"Agent\" ||\n        entity[\"Type of entity\"] === \"Collective\"\n      ) {\n        if (\n          entity[\"Name (Smith & Trzaskoma)\"] === input ||\n          entity[\"Name (transliteration)\"] === input ||\n          entity[\"Name (Latinized)\"] === input ||\n          entity[\"Name in Latin texts\"] === input ||\n          entity[\"Alternative names\"] === input\n        ) {\n          matches.push(entity[\"ID\"]);\n        }\n      }\n    });\n    return matches;\n  } \n\n  matchCurrentInput = (currentInput: string, item: any) => {\n    return item.label.toUpperCase().includes(currentInput.toUpperCase());\n  };\n  */\n\n  getDescriptors(id: string) {\n    /* \n    \n    For a more comprehensive search:\n\n    if (this.hasKey(entities, id)) {\n      let alternatives = \"\";\n      if (entities[id][\"Name (transliteration)\"] !== \"\") {\n        alternatives = alternatives + entities[id][\"Name (transliteration)\"];\n      }\n      if (entities[id][\"Name (Latinized)\"] !== \"\") {\n        alternatives = alternatives + \", \" + entities[id][\"Name (Latinized)\"];\n      }\n      if (entities[id][\"Name in Latin texts\"] !== \"\") {\n        alternatives =\n          alternatives + \", \" + entities[id][\"Name in Latin texts\"];\n      }\n      if (entities[id][\"Alternative names\"] !== \"\") {\n        alternatives = alternatives + \", \" + entities[id][\"Alternative names\"];\n      }\n\n      let descriptorSplit = entities[id][\"Name\"].split(\"(\");\n      let descriptor = descriptorSplit[1].substr(\n        0,\n        descriptorSplit[1].length - 1\n      );\n      let name = entities[id][\"Name (Smith & Trzaskoma)\"];\n      if (alternatives === \"\") {\n        return id + \": \" + name + \", \" + descriptor;\n      } else {\n        return id + \": \" + name + alternatives + \", \" + descriptor;\n      }\n    } \n    \n    */\n\n    if (this.hasKey(entities, id)) {\n      let alternatives: string = \"\";\n      if (entities[id][\"Name (transliteration)\"] !== \"\") {\n        alternatives =\n          alternatives + \", \" + entities[id][\"Name (transliteration)\"];\n      }\n      if (entities[id][\"Name (Latinized)\"] !== \"\") {\n        alternatives = alternatives + \", \" + entities[id][\"Name (Latinized)\"];\n      }\n      if (entities[id][\"Name in Latin texts\"] !== \"\") {\n        alternatives =\n          alternatives + \", \" + entities[id][\"Name in Latin texts\"];\n      }\n      if (entities[id][\"Alternative names\"] !== \"\") {\n        alternatives = alternatives + \", \" + entities[id][\"Alternative names\"];\n      }\n      return (\n        id + \": \" + entities[id][\"Name (Smith & Trzaskoma)\"] + alternatives\n      );\n    }\n  }\n\n  pageRedirect = () => {\n    if (this.state.redirect) {\n      return <Redirect to={\"/datacards?id=\" + this.state.targetID} />;\n    }\n  };\n\n  handleSearch() {\n    let entities = document.getElementById(\"input\") as HTMLInputElement;\n    if (entities.value !== \"\") {\n      this.setState({ redirect: true, targetID: entities.value.split(\":\")[0] });\n    }\n  }\n\n  handleSearchKeyDown(event: any) {\n    if (event.which === 13 || event.keyCode === 13) {\n      this.handleSearch();\n    }\n  }\n\n  /* Addresses typescript indexing objects error */\n  hasKey<O>(obj: O, key: keyof any): key is keyof O {\n    return key in obj;\n  }\n\n  render() {\n    /* const entitiesArray = Object.values(entities).map(entity => {\n      return {\n        // what to show to the user\n        label: entity.ID + \": \" + this.getDescriptors(entity.ID),\n        // key to identify the item within the array\n        key: entity.ID\n      };\n    }); */\n    return (\n      <React.Fragment>\n        {/* <h3 style={{ textAlign: \"center\" }}>SEARCH</h3> */}\n        {this.pageRedirect()}\n        <div\n          style={{\n            margin: \"1rem 0 1rem 0\",\n            textAlign: \"center\"\n          }}\n        >\n          {/* <DataListInput\n          placeholder={\"Search by entity name...\"}\n          items={entitiesArray}\n          onSelect={this.pageRedirect}\n          match={this.matchCurrentInput}\n        /> */}\n          <input\n            // type=\"search\"\n            placeholder=\"Search by entity name\"\n            id=\"input\"\n            list=\"entities\"\n            onKeyDown={this.handleSearchKeyDown}\n            style={{ width: \"50%\", textAlign: \"center\", fontSize: \"1rem\" }}\n          ></input>\n          <datalist id=\"entities\" style={{ maxHeight: \"100px\" }}>\n            {Object.values(entities).map(entity => {\n              return <option value={this.getDescriptors(entity.ID)}></option>;\n            })}\n          </datalist>\n          <div>\n            <img\n              alt=\"Submit search\"\n              src={arrow}\n              onClick={this.handleSearch}\n              className=\"search-arrow\"\n            ></img>\n          </div>\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default Search;\n","import React from \"react\";\nimport \"./App.css\";\n\ntype GraphProps = { id: string };\ntype GraphState = {};\n\nclass EntityGraph extends React.Component<GraphProps, GraphState> {\n  constructor(props: any) {\n    super(props);\n  }\n\n  render() {\n    return <div style={{ paddingTop: \"4rem\", textAlign: \"center\" }}></div>;\n  }\n}\n\nexport default EntityGraph;\n","import React from \"react\";\nimport \"./App.css\";\nimport \"./DataCards.scss\";\nimport datum from \"./data/datum.json\";\nimport entities from \"./data/entities.json\";\nimport genderData from \"./data/genderData.json\";\nimport passages from \"./data/passages.json\";\nimport Pluralize from \"pluralize\";\nimport queryString from \"querystring\";\nimport EntityGraph from \"./EntityGraph\";\n\ntype DatumProps = {\n  location: {\n    search: string;\n  };\n  history: {\n    push: ({}) => null;\n  };\n};\ntype DatumState = {\n  id: string;\n  name: string;\n  relationships: relationshipInfo;\n  validSearch: boolean;\n};\ntype relationshipInfo = {\n  MOTHERS: entityInfo[];\n  FATHERS: entityInfo[];\n  SIBLINGS: entityInfo[];\n  WIVES: entityInfo[];\n  HUSBANDS: entityInfo[];\n  CHILDREN: entityInfo[];\n};\ntype passageInfo = {\n  start: string;\n  startID: string;\n  end: string;\n  endID: string;\n};\ntype entityInfo = {\n  target: string;\n  targetID: string;\n  passage: passageInfo[];\n};\n\n/* TODO:\nGet gender from subject ID\n*/\n\nlet familyDatums = [\n  \"is father of\",\n  \"is mother of\",\n  \"is parent of\",\n  \"is child of\",\n  \"is son of\",\n  \"is daughter of\",\n  \"is sister of\",\n  \"is brother of\",\n  \"is twin of\",\n  \"is wife of\",\n  \"is husband of\",\n  \"marries\",\n  \"is grandfather of\",\n  \"is grandmother of\",\n  \"is grandparent of\",\n  \"is grandson of\",\n  \"is granddaughter of\",\n  \"is grandchild of\"\n];\n\nclass DataCards extends React.Component<DatumProps, DatumState> {\n  constructor(props: any) {\n    super(props);\n    // Dionysus is 8188175, use to test multiple names\n    // Atreus is 8187873\n    // Theseus is 8188822\n    // Agamemnon is 8182035\n    // Use Clytaimnestra example, 8188055\n    this.state = {\n      id: \"8182035\",\n      name: \"\",\n      relationships: {\n        MOTHERS: [],\n        FATHERS: [],\n        SIBLINGS: [],\n        WIVES: [],\n        HUSBANDS: [],\n        CHILDREN: []\n      },\n      validSearch: false\n    };\n    this.getNameFromID = this.getNameFromID.bind(this);\n    this.checkNoRelations = this.checkNoRelations.bind(this);\n    this.reversedVerb = this.reversedVerb.bind(this);\n    this.getDataPoints = this.getDataPoints.bind(this);\n    this.handleNameClicked = this.handleNameClicked.bind(this);\n    this.getAlternativeNames = this.getAlternativeNames.bind(this);\n  }\n\n  /*******************/\n  /* SETUP FUNCTIONS */\n  /*******************/\n\n  componentDidMount() {\n    const params = queryString.parse(this.props.location.search.slice(1));\n    const id = params.id as string;\n    if (!params.id) {\n      // Handle bad url\n      //@ts-ignore\n      this.setState({ validSearch: false });\n    } else {\n      //Substitute with ID\n      // this.updateComponent(this.state.id);\n      this.updateComponent(id);\n    }\n  }\n\n  componentDidUpdate() {\n    const params = queryString.parse(this.props.location.search.slice(1));\n    const id = params.id as string;\n    if (!params.id) {\n      // Handle bad url\n      //@ts-ignore\n      this.setState({ validSearch: false });\n    } else if (this.state.id !== id) {\n      //Substitute with ID\n      // this.updateComponent(this.state.id);\n      this.updateComponent(id);\n    }\n  }\n\n  updateComponent(id: string) {\n    const that = this;\n    if (that.hasKey(entities, id)) {\n      /* Preliminary information (i.e. name) about the entity */\n      let name = this.getNameFromID(id);\n\n      /*******************/\n      /* Find all relationships */\n      /*******************/\n\n      var connections: {\n        target: string;\n        targetID: string;\n        verb: string;\n        passage: passageInfo[];\n      }[] = [];\n\n      // Populate \"connections\" array with all family connections\n      Object.values(datum).forEach(function(datumRow) {\n        if (\n          datumRow[\"Direct Object ID\"] === id &&\n          familyDatums.includes(datumRow.Verb)\n        ) {\n          // i.e. X <verb> Y where Y is your name\n          let passageInfo: passageInfo[] = [\n            {\n              start: datumRow[\"Passage: start\"],\n              startID: datumRow[\"Passage: start ID\"],\n              end:\n                datumRow[\"Passage: end\"] === \"\" ? \"\" : datumRow[\"Passage: end\"],\n              endID: datumRow[\"Passage: end ID\"]\n            }\n          ];\n          connections.push({\n            target: datumRow[\"Subject\"],\n            targetID: datumRow[\"Subject ID\"],\n            verb: datumRow.Verb,\n            passage: passageInfo\n          });\n        }\n        if (\n          datumRow[\"Subject ID\"] === id &&\n          familyDatums.includes(datumRow.Verb)\n        ) {\n          // Add the logic reversals here\n          // i.e. Y <verb> X where Y is your name\n          let passageInfo: passageInfo[] = [\n            {\n              start: datumRow[\"Passage: start\"],\n              startID: datumRow[\"Passage: start ID\"],\n              end:\n                datumRow[\"Passage: end\"] === \"\" ? \"\" : datumRow[\"Passage: end\"],\n              endID: datumRow[\"Passage: end ID\"]\n            }\n          ];\n          connections.push({\n            target: datumRow[\"Direct Object\"],\n            targetID: datumRow[\"Direct Object ID\"],\n            verb: that.reversedVerb(\n              datumRow.Verb,\n              datumRow[\"Direct Object ID\"]\n            ),\n            passage: passageInfo\n          });\n        }\n      });\n\n      // Sort family relationships into their relevant relationship state categories\n      //TODO: deal with duplicates\n      let relationships: relationshipInfo = {\n        MOTHERS: [],\n        FATHERS: [],\n        SIBLINGS: [],\n        WIVES: [],\n        HUSBANDS: [],\n        CHILDREN: []\n      };\n      connections.forEach(datum => {\n        let d: entityInfo = {\n          target: datum.target,\n          targetID: datum.targetID,\n          passage: datum.passage\n        };\n\n        //Assign thenm to their relevant categories\n        if (datum.verb === \"is mother of\") {\n          // Address duplicates: same person, different passages\n          let wasDuplicate = false;\n          relationships.MOTHERS.forEach(mother => {\n            if (mother.targetID === d.targetID) {\n              mother.passage.push(d.passage[0]);\n              wasDuplicate = true;\n            }\n          });\n          if (!wasDuplicate) {\n            relationships.MOTHERS.push(d);\n          }\n        } else if (datum.verb === \"is father of\") {\n          // Address duplicates: same person, different passages\n          let wasDuplicate = false;\n          relationships.FATHERS.forEach(father => {\n            if (father.targetID === d.targetID) {\n              father.passage.push(d.passage[0]);\n              wasDuplicate = true;\n            }\n          });\n          if (!wasDuplicate) {\n            relationships.FATHERS.push(d);\n          }\n        } else if (\n          datum.verb === \"is son of\" ||\n          datum.verb === \"is daughter of\" ||\n          datum.verb === \"is child of\"\n        ) {\n          let wasDuplicate = false;\n          relationships.CHILDREN.forEach(children => {\n            if (children.targetID === d.targetID) {\n              children.passage.push(d.passage[0]);\n              wasDuplicate = true;\n            }\n          });\n          if (!wasDuplicate) {\n            relationships.CHILDREN.push(d);\n          }\n        } else if (\n          datum.verb === \"is sister of\" ||\n          datum.verb === \"is brother of\" ||\n          datum.verb === \"is twin of\"\n        ) {\n          let wasDuplicate = false;\n          relationships.SIBLINGS.forEach(siblings => {\n            if (siblings.targetID === d.targetID) {\n              siblings.passage.push(d.passage[0]);\n              wasDuplicate = true;\n            }\n          });\n          if (!wasDuplicate) {\n            relationships.SIBLINGS.push(d);\n          }\n        } else if (datum.verb === \"is wife of\") {\n          let wasDuplicate = false;\n          relationships.WIVES.forEach(wives => {\n            if (wives.targetID === d.targetID) {\n              wives.passage.push(d.passage[0]);\n              wasDuplicate = true;\n            }\n          });\n          if (!wasDuplicate) {\n            relationships.WIVES.push(d);\n          }\n        } else if (datum.verb === \"is husband of\") {\n          let wasDuplicate = false;\n          relationships.HUSBANDS.forEach(husbands => {\n            if (husbands.targetID === d.targetID) {\n              husbands.passage.push(d.passage[0]);\n              wasDuplicate = true;\n            }\n          });\n          if (!wasDuplicate) {\n            relationships.HUSBANDS.push(d);\n          }\n        } else if (datum.verb === \"marries\") {\n          if (\n            this.hasKey(genderData, datum.targetID) &&\n            genderData[datum.targetID].gender === \"female\"\n          ) {\n            let wasDuplicate = false;\n            relationships.WIVES.forEach(wives => {\n              if (wives.targetID === d.targetID) {\n                wives.passage.push(d.passage[0]);\n                wasDuplicate = true;\n              }\n            });\n            if (!wasDuplicate) {\n              relationships.WIVES.push(d);\n            }\n          } else if (\n            this.hasKey(genderData, datum.targetID) &&\n            genderData[datum.targetID].gender === \"male\"\n          ) {\n            let wasDuplicate = false;\n            relationships.FATHERS.forEach(fathers => {\n              if (fathers.targetID === d.targetID) {\n                fathers.passage.push(d.passage[0]);\n                wasDuplicate = true;\n              }\n            });\n            if (!wasDuplicate) {\n              relationships.FATHERS.push(d);\n            }\n          }\n        }\n      });\n      this.setState({ id, relationships, name, validSearch: true });\n    }\n    // Modify the relationship and name\n  }\n\n  /********************/\n  /* HELPER FUNCTIONS */\n  /********************/\n\n  /* Use the entity CSV instead when receive it */\n  getNameFromID(id: string) {\n    let that = this;\n    if (that.hasKey(entities, id)) {\n      return entities[id][\"Name (Smith & Trzaskoma)\"];\n    } else {\n      return \"unknown\";\n    }\n  }\n\n  getPassageLink(passage: any) {\n    let id = passage.startID;\n    if (this.hasKey(passages, id)) {\n      let author: string = passages[id].Author;\n      let title: string = passages[id].Title;\n      let start: string = passages[id].Passage;\n      let end: string = passage.endID;\n\n      // Dealing with multiple URNs\n      let URN: string = \"\";\n      let URNsplit = passages[id][\"CTS URN\"].split(\", \");\n      if (URNsplit.length >= 2) {\n        URN = URNsplit[1];\n      } else {\n        URN = passages[id][\"CTS URN\"];\n      }\n\n      URN = \"https://scaife.perseus.org/reader/\" + URN;\n      if (passage.endID !== \"\" && this.hasKey(passages, end)) {\n        end = passages[end].Passage;\n        URN = URN + \"-\" + end;\n      }\n      URN = URN + \"/?right=perseus-eng2\";\n\n      return (\n        <span>\n          {\"  (\"}\n          <a\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            href={URN}\n            style={{\n              color: \"grey\",\n              fontSize: \"0.8rem\"\n            }}\n          >\n            {author + \", \"}\n            <span style={{ fontStyle: \"italic\" }}>{title}</span> {start}\n            {start !== end && end !== \"\" ? \"-\" + end : \"\"}\n          </a>\n          {\")\"}\n        </span>\n      );\n    }\n  }\n\n  checkNoRelations() {\n    let that = this;\n    return (\n      that.state.relationships.MOTHERS.length === 0 &&\n      that.state.relationships.FATHERS.length === 0 &&\n      that.state.relationships.SIBLINGS.length === 0 &&\n      that.state.relationships.WIVES.length === 0 &&\n      that.state.relationships.HUSBANDS.length === 0 &&\n      that.state.relationships.CHILDREN.length === 0\n    );\n  }\n\n  reversedVerb(verb: string, dirObject: string) {\n    if (\n      verb === \"is mother of\" ||\n      verb === \"is father of\" ||\n      verb === \"is parent of\"\n    ) {\n      return \"is child of\"; // Uses generic \"is child of\" at the moment since data cards do not need gender specificity for children\n    } else if (\n      verb === \"is son of\" ||\n      verb === \"is daughter of\" ||\n      verb === \"is child of\"\n    ) {\n      if (\n        this.hasKey(genderData, dirObject) &&\n        genderData[dirObject].gender === \"female\"\n      ) {\n        return \"is mother of\";\n      } else if (\n        this.hasKey(genderData, dirObject) &&\n        genderData[dirObject].gender === \"male\"\n      ) {\n        return \"is father of\";\n      } else {\n        return \"is parent of\";\n      }\n    } else if (\n      verb === \"is sister of\" ||\n      verb === \"is brother of\" ||\n      verb === \"is twin of\"\n    ) {\n      return \"is sister of\";\n    } else if (\n      verb === \"is wife of\" ||\n      verb === \"is husband of\" ||\n      verb === \"marries\"\n    ) {\n      if (\n        this.hasKey(genderData, dirObject) &&\n        genderData[dirObject].gender === \"female\"\n      ) {\n        return \"is wife of\";\n      } else if (\n        this.hasKey(genderData, dirObject) &&\n        genderData[dirObject].gender === \"male\"\n      ) {\n        return \"is husband of\";\n      } else {\n        return \"marries\";\n      }\n    } else {\n      console.log(\n        \"Unsure of this connection, or connection is not relevant for the datacards-\",\n        verb,\n        dirObject\n      );\n      return \"\";\n    }\n  }\n\n  handleNameClicked(targetID: string) {\n    this.props.history.push(\"/datacards?id=\" + targetID);\n  }\n\n  getDataPoints(relationship: string) {\n    let that = this;\n    if (\n      that.hasKey(that.state.relationships, relationship) &&\n      that.state.relationships[relationship].length !== 0\n    ) {\n      return (\n        <div style={{ clear: \"both\" }}>\n          <div\n            style={{\n              fontWeight: \"bold\",\n              textTransform: \"uppercase\",\n              float: \"left\",\n              paddingRight: \"1rem\"\n            }}\n          >\n            {this.state.relationships[relationship].length === 1\n              ? Pluralize.singular(relationship) + \": \"\n              : relationship + \": \"}\n          </div>\n          <div style={{ float: \"left\" }}>\n            {that.state.relationships[relationship].map(entity => {\n              return (\n                <div style={{ margin: \"0\" }}>\n                  <div\n                    className=\"entity-button\"\n                    onClick={() => this.handleNameClicked(entity.targetID)}\n                  >\n                    {entity.target}\n                  </div>\n                  {entity.passage.map(passage => {\n                    return this.getPassageLink(passage);\n                  })}\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  getAlternativeNames(id: string) {\n    if (this.hasKey(entities, id)) {\n      let alternatives: string = \"\";\n      if (entities[id][\"Name (transliteration)\"] !== \"\") {\n        if (alternatives === \"\") {\n          alternatives = entities[id][\"Name (transliteration)\"];\n        } else {\n          alternatives =\n            alternatives + \", \" + entities[id][\"Name (transliteration)\"];\n        }\n      }\n      if (entities[id][\"Name (Latinized)\"] !== \"\") {\n        if (alternatives === \"\") {\n          alternatives = entities[id][\"Name (Latinized)\"];\n        } else {\n          alternatives = alternatives + \", \" + entities[id][\"Name (Latinized)\"];\n        }\n      }\n      if (entities[id][\"Name in Latin texts\"] !== \"\") {\n        if (alternatives === \"\") {\n          alternatives = entities[id][\"Name in Latin texts\"];\n        } else {\n          alternatives =\n            alternatives + \", \" + entities[id][\"Name in Latin texts\"];\n        }\n      }\n      if (entities[id][\"Alternative names\"] !== \"\") {\n        if (alternatives === \"\") {\n          alternatives = entities[id][\"Alternative names\"];\n        } else {\n          alternatives =\n            alternatives + \", \" + entities[id][\"Alternative names\"];\n        }\n      }\n      if (alternatives === \"\") {\n        return alternatives;\n      } else {\n        return \"(Also known as: \" + alternatives + \")\";\n      }\n    }\n  }\n\n  /* Addresses typescript indexing objects error */\n  hasKey<O>(obj: O, key: keyof any): key is keyof O {\n    return key in obj;\n  }\n\n  /*************/\n  /* RENDERING */\n  /*************/\n\n  render() {\n    return (\n      <React.Fragment>\n        <div\n          className={this.state.validSearch ? \"no-display\" : \"\"}\n          style={{ textAlign: \"center\", padding: \"3rem\" }}\n        >\n          No profiles have been selected. Try using the Search function.\n        </div>\n        <div className={this.state.validSearch ? \"\" : \"no-display\"}>\n          <div\n            style={{\n              margin: \"1rem 6rem 3rem 6rem\",\n              padding: \"3rem\",\n              display: \"flow-root\",\n              border: \"solid 1px black\"\n            }}\n          >\n            <div id=\"datacard-heading\">{this.state.name}</div>\n            <div id=\"datacard-alternativenames\">\n              {this.getAlternativeNames(this.state.id)}\n            </div>\n            {/* If no data is available for the subject */}\n            <div className={this.checkNoRelations() ? \"\" : \"no-display\"}>\n              No relationship data is available for {this.state.name}.\n            </div>\n            {/* If data is available for the subject */}\n            {Object.keys(this.state.relationships).map(key => {\n              return <div key={key}>{this.getDataPoints(key)}</div>;\n            })}\n          </div>\n        </div>\n        {/* <EntityGraph id={this.state.targetID}></EntityGraph> */}\n        <EntityGraph id={this.state.id}></EntityGraph>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default DataCards;\n","import React from \"react\";\nimport \"./App.css\";\nimport Header from \"./Header\";\nimport Search from \"./Search\";\nimport DataCards from \"./DataCards\";\nimport {\n  HashRouter as Router,\n  Route,\n  Link,\n  Switch,\n  Redirect\n} from \"react-router-dom\";\n\nclass App extends React.Component<{}, {}> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      subjectID: \"\"\n    };\n  }\n\n  changeEntity(ID: string) {\n    this.setState({ subjectID: ID });\n  }\n\n  render() {\n    return (\n      <div\n        style={{ backgroundColor: \"#eeeeee\", height: \"100%\", width: \"100%\" }}\n      >\n        <Router>\n          <Link to=\"/\">\n            <Header></Header>\n          </Link>\n          <Search></Search>\n          <Switch>\n            {/* <Route exact path=\"/\" component={Home} /> */}\n            <Route path=\"/search\" component={Search} />\n            <Route path=\"/datacards\" component={DataCards} />\n            <Route component={() => <Redirect to=\"/\" />} />\n          </Switch>\n        </Router>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}