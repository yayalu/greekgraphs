{"version":3,"sources":["images/arrow.svg","images/logo.svg","Header.tsx","Search.tsx","DataCardHandler.ts","GraphHandler.ts","EntityGraph.jsx","DataCards.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Header","style","paddingTop","textAlign","src","require","alt","width","Search","props","pageRedirect","state","redirect","to","targetID","handleSearch","bind","handleSearchKeyDown","getDescriptors","id","this","hasKey","entities","alternatives","ReactGA","event","category","action","currentInput","document","getElementById","value","split","currentInputName","trim","setState","which","keyCode","obj","key","Fragment","margin","placeholder","list","onKeyDown","fontSize","maxHeight","Object","values","map","entity","arrow","onClick","className","React","Component","getGender","checkNoRelations","relationships","MOTHERS","length","FATHERS","SIBLINGS","TWIN","SPOUSES","CHILDREN","getNameString","parameter","stringSoFar","s","getName","entityRow","possibleNames","i","undefined","getAllRelationshipLinks","nodes","edges","mainnode","depth","location","x","y","node","edge","from","relation","console","log","target","j","child","otherParentIDs","disputed","EntityGraph","openInfoPage","showDisputePage","showUnusualPage","nodeWidth","nodeHeight","nodeHorizontalSpacing","nodeVerticalSpacing","verticalOffset","ctx","text","strokeStyle","setLineDash","strokeRect","fillText","fromX","fromY","toX","toY","beginPath","moveTo","lineTo","stroke","nodePositions","parent1","parent2","siblings","parent1X","x1","parent2X","centrePoint","forEach","y1","parents","children","nodeYOffset","newNodeYOffset","mainLocation","push","otherParentLocation","middle","JSON","parse","graphContent","allRelationships","getGraph","refs","canvasOuterDiv","scrollLeft","graphCanvas","getContext","mainNodeWidth","x2","y2","extension","level","fathers","mothers","rightX","rightY","leftX","leftY","depth0Nodes","middleIndex","Math","floor","xPosition","numChildren","numParents","createUnknownNode","c","startingX","startingY","connectedSiblings","parentGroupings","m","f","p","parentEdge","childEdge","marginBottom","marginTop","ref","overflow","border","maxWidth","height","DataCards","name","members","sub","super","type","validSearch","alternativeName","passage","handleNameClicked","startID","author","passages","Author","title","Title","start","Passage","end","endID","URN","URNsplit","rel","href","color","fontStyle","history","relationship","showPassage","focus","clear","fontWeight","textTransform","float","paddingRight","getPluralization","checkUnusualRelationship","Pluralize","singular","mother_parthenogenesis","father_parthenogenesis","textDecoration","getPassageLink","autochthony","getChildParentGrouped","getOtherParentText","group","pID","indexOf","member","divineParents","params","queryString","search","slice","newState","padding","display","getAlternativeNames","getAlternativePage","getCollectiveSubheading","keys","getDataPoints","getCollectiveMembers","relationshipClicked","App","subjectID","ID","initialize","pageview","backgroundColor","path","component","Boolean","window","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"wi8sCAAAA,EAAOC,QAAU,IAA0B,mC,kzyhGCA3CD,EAAOC,QAAU,IAA0B,kC,g1g1ECe5BC,G,MAZU,WACvB,OACE,yBAAKC,MAAO,CAAEC,WAAY,OAAQC,UAAW,WAC3C,yBACEC,IAAKC,EAAQ,IACbC,IAAI,aACJL,MAAO,CAAEM,MAAO,Y,gDCuJTC,E,YAlJb,WAAYC,GAAa,IAAD,8BACtB,4CAAMA,KAqCRC,aAAe,WACb,GAAI,EAAKC,MAAMC,SACb,OAAO,kBAAC,IAAD,CAAUC,GAAI,iBAAmB,EAAKF,MAAMG,YAtCrD,EAAKH,MAAQ,CACXC,UAAU,EACVE,SAAU,IAGZ,EAAKC,aAAe,EAAKA,aAAaC,KAAlB,gBACpB,EAAKC,oBAAsB,EAAKA,oBAAoBD,KAAzB,gBAC3B,EAAKE,eAAiB,EAAKA,eAAeF,KAApB,gBATA,E,4EAYTG,GACb,GAAIC,KAAKC,OAAOC,EAAUH,GAAK,CAC7B,IAAII,EAAuB,GAoB3B,MAnB+C,KAA3CD,EAASH,GAAI,4BACfI,EACEA,EAAe,KAAOD,EAASH,GAAI,2BAEE,KAArCG,EAASH,GAAI,sBACfI,EAAeA,EAAe,KAAOD,EAASH,GAAI,qBAER,KAAxCG,EAASH,GAAI,yBACfI,EACEA,EAAe,KAAOD,EAASH,GAAI,wBAEG,KAAtCG,EAASH,GAAI,uBACfI,EAAeA,EAAe,KAAOD,EAASH,GAAI,sBAGlDG,EAASH,GAAI,4BACbI,EACA,KACAD,EAASH,GAAI,8B,qCAYjBK,IAAQC,MAAM,CACZC,SAAU,SACVC,OAAQ,qDAEV,IAAIC,EAAeC,SAASC,eAAe,SAC3C,GAA2B,KAAvBF,EAAaG,MAEf,IAAK,IAAIZ,KAAMG,EACb,GAAIF,KAAKC,OAAOC,EAAUH,IAEtBG,EAASH,GAAI,6BACbS,EAAaG,MAAMC,MAAM,MAAM,GAC/B,CACA,IAAIC,EAAmBL,EAAaG,MACjCC,MAAM,MAAM,GACZA,MAAM,KAAK,GACXE,OAGDD,IAAqBX,EAASH,GAAI,6BAClCc,IAAqBX,EAASH,GAAI,2BAClCc,IAAqBX,EAASH,GAAI,qBAClCc,IAAqBX,EAASH,GAAI,wBAClCc,IAAqBX,EAASH,GAAI,sBAElCC,KAAKe,SAAS,CACZvB,UAAU,EACVE,SAAUK,O,0CASJM,GACE,KAAhBA,EAAMW,OAAkC,KAAlBX,EAAMY,SAC9BjB,KAAKL,iB,6BAKCuB,EAAQC,GAChB,OAAOA,KAAOD,I,+BAGN,IAAD,OASP,OACE,kBAAC,IAAME,SAAP,KAEGpB,KAAKV,eACN,yBACET,MAAO,CACLwC,OAAQ,gBACRtC,UAAW,WASb,2BAEEuC,YAAY,iBACZvB,GAAG,QACHwB,KAAK,WACLC,UAAWxB,KAAKH,oBAChBhB,MAAO,CAAEM,MAAO,MAAOJ,UAAW,SAAU0C,SAAU,UAExD,8BAAU1B,GAAG,WAAWlB,MAAO,CAAE6C,UAAW,UACzCC,OAAOC,OAAO1B,GAAU2B,IAAI,SAAAC,GAC3B,OACE,4BAAQnB,MAAO,EAAKb,eAAegC,EAAM,SAI/C,6BACE,yBACE5C,IAAI,gBACJF,IAAK+C,IACLC,QAAShC,KAAKL,aACdsC,UAAU,wB,GA1IHC,IAAMC,W,wCCZvBjC,GADOjB,EAAQ,IACJA,EAAQ,IAqmBVmD,GApmBOnD,EAAQ,GAomBH,SAACc,GACxB,OAAOG,EAASH,GAAMG,EAASH,GAAI,uBAAyB,KAyMjDsC,EAAmB,SAACC,GAC/B,OACmC,IAAjCA,EAAcC,QAAQC,QACW,IAAjCF,EAAcG,QAAQD,QACY,IAAlCF,EAAcI,SAASF,QACO,IAA9BF,EAAcK,KAAKH,QACc,IAAjCF,EAAcM,QAAQJ,QACY,IAAlCF,EAAcO,SAASL,QAyBrBM,EAAgB,SAACC,EAAmBC,EAAqBjD,GAC7D,IAAIkD,EAAI,GAQR,MAPgC,KAA5B/C,EAASH,GAAIgD,KAEbE,EADkB,KAAhBD,EACE9C,EAASH,GAAIgD,GAEbC,EAAc,KAAO9C,EAASH,GAAIgD,IAGnCE,GAMIC,EAAU,SAACC,GACtB,IAAIC,EAAgB,CAClB,2BACA,yBACA,mBACA,sBACA,qBAEF,IAAID,EAYF,MAAO,GAXP,IAAK,IAAIE,EAAI,EAAGA,EAAID,EAAcZ,OAAQa,IACxC,OACEF,EAAUC,EAAcC,KACQ,KAAhCF,EAAUC,EAAcC,UACQC,IAAhCH,EAAUC,EAAcC,IAEjBF,EAAUC,EAAcC,IAE1B,ICp2BPE,G,MAA0B,SAACxD,EAAYuC,GAC3C,IAAIkB,EAAQ,GACRC,EAAQ,GAGRC,EAAqB,CACvB3D,GAAIA,EACJ4D,MAAO,EACPC,SAAU,CAAEC,EAAG,EAAGC,EAAG,GACrBjF,MAAO,IAET2E,EAAMzD,GAAM2D,EAGZ,IAAK,IAAIL,EAAI,EAAGA,EAAIf,EAAcI,SAASF,OAAQa,IAAK,CACtD,IAAIU,EAAiB,CACnBhE,GAAIuC,EAAcI,SAASW,GAAG3D,SAC9BiE,MAAO,EACPC,SAAU,CAAEC,EAAG,EAAGC,EAAG,GACrBjF,MAAO,IAET2E,EAAMlB,EAAcI,SAASW,GAAG3D,UAAYqE,EAC5C,IAAIC,EAAiB,CACnBC,KAAMlE,EACNN,GAAI6C,EAAcI,SAASW,GAAG3D,SAC9BwE,SAAU,UACVrF,MAAO,IAEL4E,EAAMnB,EAAcI,SAASW,GAAG3D,UAElCyE,QAAQC,IACN,mCACA9B,EAAcI,SAASW,GAAGgB,QAG5BZ,EAAMnB,EAAcI,SAASW,GAAG3D,UAAYsE,EAGhD,IAAK,IAAIX,EAAI,EAAGA,EAAIf,EAAcM,QAAQJ,OAAQa,IAAK,CACrD,IAAIU,EAAiB,CACnBhE,GAAIuC,EAAcM,QAAQS,GAAG3D,SAC7BiE,MAAO,EACPC,SAAU,CAAEC,EAAG,EAAGC,EAAG,GACrBjF,MAAO,IAET2E,EAAMlB,EAAcM,QAAQS,GAAG3D,UAAYqE,EAC3C,IAAIC,EAAiB,CACnBC,KAAMlE,EACNN,GAAI6C,EAAcM,QAAQS,GAAG3D,SAC7BwE,SAAU,SACVrF,MAAO,IAEL4E,EAAMnB,EAAcM,QAAQS,GAAG3D,UAEjCyE,QAAQC,IACN,kCACA9B,EAAcM,QAAQS,GAAGgB,QAG3BZ,EAAMnB,EAAcM,QAAQS,GAAG3D,UAAYsE,EAG/C,IAAK,IAAIX,EAAI,EAAGA,EAAIf,EAAcK,KAAKH,OAAQa,IAAK,CAClD,IAAIU,EAAiB,CACnBhE,GAAIuC,EAAcK,KAAKU,GAAG3D,SAC1BiE,MAAO,EACPC,SAAU,CAAEC,EAAG,EAAGC,EAAG,GACrBjF,MAAO,IAET2E,EAAMlB,EAAcK,KAAKU,GAAG3D,UAAYqE,EACxC,IAAIC,EAAiB,CACnBC,KAAMlE,EACNN,GAAI6C,EAAcK,KAAKU,GAAG3D,SAC1BwE,SAAU,OACVrF,MAAO,IAEL4E,EAAMnB,EAAcK,KAAKU,GAAG3D,UAE9ByE,QAAQC,IACN,gCACA9B,EAAcK,KAAKU,GAAGgB,QAGxBZ,EAAMnB,EAAcK,KAAKU,GAAG3D,UAAYsE,EAK5C,IAAK,IAAIX,EAAI,EAAGA,EAAIf,EAAcC,QAAQC,OAAQa,IAAK,CACrD,IAAIU,EAAiB,CACnBhE,GAAIuC,EAAcC,QAAQc,GAAG3D,SAC7BiE,OAAQ,EACRC,SAAU,CAAEC,EAAG,EAAGC,EAAG,GACrBjF,MAAO,IAET2E,EAAMlB,EAAcC,QAAQc,GAAG3D,UAAYqE,EAC3C,IAAIC,EAAiB,CACnBC,KAAM3B,EAAcC,QAAQc,GAAG3D,SAC/BD,GAAIM,EACJmE,SAAU,SACVrF,MAAO,IAEL4E,EAAMnB,EAAcC,QAAQc,GAAG3D,UAEjCyE,QAAQC,IACN,kCACA9B,EAAcC,QAAQc,GAAGgB,QAG3BZ,EAAMnB,EAAcC,QAAQc,GAAG3D,UAAYsE,EAG/C,IAAK,IAAIX,EAAI,EAAGA,EAAIf,EAAcG,QAAQD,OAAQa,IAAK,CACrD,IAAIU,EAAiB,CACnBhE,GAAIuC,EAAcG,QAAQY,GAAG3D,SAC7BiE,OAAQ,EACRC,SAAU,CAAEC,EAAG,EAAGC,EAAG,GACrBjF,MAAO,IAET2E,EAAMlB,EAAcG,QAAQY,GAAG3D,UAAYqE,EAC3C,IAAIC,EAAiB,CACnBC,KAAM3B,EAAcG,QAAQY,GAAG3D,SAC/BD,GAAIM,EACJmE,SAAU,UACVrF,MAAO,IAEL4E,EAAMnB,EAAcG,QAAQY,GAAG3D,UAEjCyE,QAAQC,IACN,mCACA9B,EAAcG,QAAQY,GAAGgB,QAG3BZ,EAAMnB,EAAcG,QAAQY,GAAG3D,UAAYsE,EAI/C,IAAK,IAAIX,EAAI,EAAGA,EAAIf,EAAcO,SAASL,OAAQa,IAAK,CAEtD,IAAK,IAAIiB,EAAI,EAAGA,EAAIhC,EAAcO,SAASQ,GAAGkB,MAAM/B,OAAQ8B,IAAK,CAC/D,IAAIP,EAAiB,CACnBhE,GAAIuC,EAAcO,SAASQ,GAAGkB,MAAMD,GAAG5E,SACvCiE,MAAO,EACPC,SAAU,CAAEC,EAAG,EAAGC,EAAG,GACrBjF,MAAO,IAET2E,EAAMlB,EAAcO,SAASQ,GAAGkB,MAAMD,GAAG5E,UAAYqE,EACrD,IAAIC,EAAiB,CACnBC,KAAMlE,EACNN,GAAI6C,EAAcO,SAASQ,GAAGkB,MAAMD,GAAG5E,SACvCwE,SAAU,QACVrF,MAAO,IAEL4E,EAAMnB,EAAcO,SAASQ,GAAGkB,MAAMD,GAAG5E,UAE3CyE,QAAQC,IACN,iCACA9B,EAAcO,SAASQ,GAAGkB,MAAMD,GAAGD,QAGrCZ,EAAMnB,EAAcO,SAASQ,GAAGkB,MAAMD,GAAG5E,UAAYsE,EAIzD,IAAK,IAAIM,EAAI,EAAGA,EAAIhC,EAAcO,SAASQ,GAAGmB,eAAehC,OAAQ8B,IAAK,CACxE,IAAIP,EAAiB,CACnBhE,GAAIuC,EAAcO,SAASQ,GAAGmB,eAAeF,GAC7CX,MAAO,EACPC,SAAU,CAAEC,EAAG,EAAGC,EAAG,GACrBjF,MAAO,IAET2E,EAAMlB,EAAcO,SAASQ,GAAGmB,eAAeF,IAAMP,EACrD,IAAIC,OAAc,EAEhBA,EADE1B,EAAcO,SAASQ,GAAGmB,eAAehC,OAAS,EAC7C,CACLyB,KAAMlE,EACNN,GAAI6C,EAAcO,SAASQ,GAAGmB,eAAeF,GAC7CJ,SAAU,YACVrF,MAAO,GACP4F,SAAU,aAGL,CACLR,KAAMlE,EACNN,GAAI6C,EAAcO,SAASQ,GAAGmB,eAAeF,GAC7CJ,SAAU,YACVrF,MAAO,IAGP4E,EAAMnB,EAAcO,SAASQ,GAAGmB,eAAeF,IAEjDH,QAAQC,IACN,wCACAlB,EAAQhD,EAASoC,EAAcO,SAASQ,GAAGmB,eAAeF,MAG5Db,EAAMnB,EAAcO,SAASQ,GAAGmB,eAAeF,IAAMN,GAK3D,MAAO,CAAER,QAAOC,WC6RHiB,E,YA7db,WAAYrF,GAAQ,IAAD,8BACjB,4CAAMA,KACDE,MAAQ,CACXoF,aAAc,CAAEC,iBAAiB,EAAOC,iBAAiB,GACzDC,UAAW,GACXC,WAAY,GACZC,sBAAuB,GACvBC,oBAAqB,IACrBC,eAAgB,KARD,E,kEAYd7F,GAAQ,IACH8F,EAAoB9F,EAApB8F,IAAKtB,EAAexE,EAAfwE,EAAGC,EAAYzE,EAAZyE,EAAGsB,EAAS/F,EAAT+F,KACN,YAATA,GACFD,EAAIE,YAAc,UAClBF,EAAIG,YAAY,CAAC,EAAG,IACpBH,EAAII,WAAW1B,EAAGC,EAAG9D,KAAKT,MAAMuF,UAAW9E,KAAKT,MAAMwF,YACtDI,EAAIK,SAASJ,EAAMvB,EAAI,GAAIC,EAAI,IAC/BqB,EAAIG,YAAY,IAChBH,EAAIE,YAAc,SAElBF,EAAII,WAAW1B,EAAGC,EAAG9D,KAAKT,MAAMuF,UAAW9E,KAAKT,MAAMwF,YACtDI,EAAIK,SAASJ,EAAMvB,EAAI,GAAIC,EAAI,O,2BAI9BzE,GAAQ,IACH8F,EAAgC9F,EAAhC8F,IAAKM,EAA2BpG,EAA3BoG,MAAOC,EAAoBrG,EAApBqG,MAAOC,EAAatG,EAAbsG,IAAKC,EAAQvG,EAARuG,IAChCT,EAAIU,YACJV,EAAIW,OAAOL,EAAOC,EAAQ1F,KAAKT,MAAMwF,WAAa,GAClDI,EAAIY,OAAOJ,EAAKC,EAAM5F,KAAKT,MAAMyF,sBAAwB,GACzDG,EAAIa,W,iCAGK3G,GAAQ,IAAD,OAEd8F,EAOE9F,EAPF8F,IACAc,EAME5G,EANF4G,cACAC,EAKE7G,EALF6G,QACAC,EAIE9G,EAJF8G,QACAC,EAGE/G,EAHF+G,SACAtC,EAEEzE,EAFFyE,EACAW,EACEpF,EADFoF,SAEE4B,EAAWJ,EAAcC,GAASI,GAAKtG,KAAKT,MAAMuF,UAAY,EAC9DyB,EAAWN,EAAcE,GAASG,GAAKtG,KAAKT,MAAMuF,UAAY,EAClEK,EAAIU,YACApB,IACFU,EAAIE,YAAc,QAEpBF,EAAIW,OAAOO,EAAUvC,EAAI9D,KAAKT,MAAMwF,YACpCI,EAAIY,OAAOM,EAAUvC,EAAI9D,KAAKT,MAAMwF,WAAa,IACjDI,EAAIY,OAAOQ,EAAUzC,EAAI9D,KAAKT,MAAMwF,WAAa,IACjDI,EAAIY,OAAOQ,EAAUzC,EAAI9D,KAAKT,MAAMwF,YACpCI,EAAIW,QAAQO,EAAWE,GAAY,EAAGzC,EAAI9D,KAAKT,MAAMwF,WAAa,IAClEI,EAAIY,QAAQM,EAAWE,GAAY,EAAGzC,EAAI9D,KAAKT,MAAMwF,WAAa,IAElE,IAAIyB,EAAc,CAChB3C,GAAIwC,EAAWE,GAAY,EAC3BzC,EAAGA,EAAI9D,KAAKT,MAAMwF,WAAa,IAEjCpD,OAAOC,OAAOwE,GAAUK,QAAQ,SAAAxD,GAC9BkC,EAAIW,OAAOU,EAAY3C,EAAG2C,EAAY1C,GACtCqB,EAAIY,OAAO9C,EAAEqD,GAAK,EAAK/G,MAAMuF,UAAY,EAAG0B,EAAY1C,GACxDqB,EAAIY,OAAO9C,EAAEqD,GAAK,EAAK/G,MAAMuF,UAAY,EAAG7B,EAAEyD,MAGhDvB,EAAIa,SACJb,EAAIE,YAAc,S,gCAGVhG,GAAQ,IACR8F,EAAuD9F,EAAvD8F,IAAKc,EAAkD5G,EAAlD4G,cAAeU,EAAmCtH,EAAnCsH,QAASC,EAA0BvH,EAA1BuH,SAAUC,EAAgBxH,EAAhBwH,YAC3CF,EAAQnE,OAAS,IAEnB2C,EAAIE,YAAc,QAEpB,IAAIyB,EAAiBD,EAEjBE,EAAe,CACjBlD,EAAGoC,EAAcjG,KAAKX,MAAMU,IAAIuG,GAAKtG,KAAKT,MAAMuF,UAAY,EAC5DhB,EAAGmC,EAAcjG,KAAKX,MAAMU,IAAI2G,GAAK1G,KAAKT,MAAMwF,YAG3B,IAAnB4B,EAAQnE,QAEVmE,EAAQK,KAAK,WAEf,IAAK,IAAI3D,EAAI,EAAGA,EAAIsD,EAAQnE,OAAQa,IAAK,CAEvC8B,EAAIU,YAEJV,EAAIW,OAAOiB,EAAalD,EAAGkD,EAAajD,GACxCqB,EAAIY,OAAOgB,EAAalD,EAAGkD,EAAajD,EAAIgD,GAC5C,IAAIG,EAAsB,CACxBpD,EAAGoC,EAAcU,EAAQtD,IAAIiD,GAAKtG,KAAKT,MAAMuF,UAAY,EACzDhB,EAAGmC,EAAcU,EAAQtD,IAAIqD,GAAK1G,KAAKT,MAAMwF,YAE/CI,EAAIY,OAAOkB,EAAoBpD,EAAGoD,EAAoBnD,EAAIgD,GAC1D3B,EAAIY,OAAOkB,EAAoBpD,EAAGoD,EAAoBnD,GAEtDqB,EAAIW,QACDmB,EAAoBpD,EAAIkD,EAAalD,GAAK,EAC3CoD,EAAoBnD,EAAIgD,GAE1B,IAAII,EAAS,CACXrD,GAAIoD,EAAoBpD,EAAIkD,EAAalD,GAAK,EAC9CC,EACEmD,EAAoBnD,EACpB9D,KAAKT,MAAM2F,eACX4B,EACA,IAEJ3B,EAAIY,OAAOmB,EAAOrD,EAAGqD,EAAOpD,GAE5B,IAAK,IAAIQ,EAAI,EAAGA,EAAIsC,EAASpE,OAAQ8B,IACnCa,EAAIW,OAAOoB,EAAOrD,EAAGqD,EAAOpD,GAC5BK,QAAQC,IACN,UACAwC,EAAStC,GAAGD,OACZ,OACAnB,EAAQhD,EAASyG,EAAQtD,MAE3B8B,EAAIY,OACFE,EAAcW,EAAStC,GAAG5E,UAAU4G,GAAKtG,KAAKT,MAAMuF,UAAY,EAChEoC,EAAOpD,GAETqB,EAAIY,OACFE,EAAcW,EAAStC,GAAG5E,UAAU4G,GAAKtG,KAAKT,MAAMuF,UAAY,EAChEmB,EAAcW,EAAStC,GAAG5E,UAAUgH,IAGxCvB,EAAIa,SACJc,GAAkB,GAGpB,OADA3B,EAAIE,YAAc,OACXyB,I,2CAGa,IAAD,OACfb,EAAgB,GAChBnB,EAAY9E,KAAKT,MAAMuF,UACvBC,EAAa/E,KAAKT,MAAMwF,WACxBC,EAAwBhF,KAAKT,MAAMyF,sBACnCC,EAAsBjF,KAAKT,MAAM0F,oBAGrC,IACG5C,EAAiB8E,KAAKC,MAAM9E,EAActC,KAAKX,MAAMU,KAAKuC,eAC3D,CACA,IAAI+E,EDtKc,SAACtH,GACvB,IAAIuC,EAAgB6E,KAAKC,MAAME,EAAiBvH,IAAKuC,cAErD,OADA6B,QAAQC,IAAI+C,KAAKC,MAAME,EAAiBvH,KACjCwD,EAAwBxD,EAAIuC,GCmKZiF,CAASvH,KAAKX,MAAMU,IACvCoE,QAAQC,IAAIiD,GAGIrH,KAAKwH,KAAKC,eAChBC,WAAa,KAGvB,IAAMvC,EAAMnF,KAAKwH,KAAKG,YAAYC,WAAW,MAOzCC,EAAgB7H,KAAKwH,KAAKG,YAAYxI,MAAQ,EAElDa,KAAK+D,KAAK,CACRoB,MACAtB,EAAGgE,EACH/D,EAJmB,IAKnBsB,KAAMlC,EAAQhD,EAASF,KAAKX,MAAMU,OAEpCkG,EAAcjG,KAAKX,MAAMU,IAAM,CAC7BuG,GAAIuB,EACJnB,GATmB,IAUnBoB,GAAID,EAAgB7H,KAAKT,MAAMuF,UAC/BiD,GAXmB,IAWE/H,KAAKT,MAAMwF,YAIlC,IAAIiD,EAAY,EACZC,EACFhC,EAAcjG,KAAKX,MAAMU,IAAI2G,GAAKzB,EAAsBF,EACtDmD,EAAUf,KAAKC,MAAM9E,EAActC,KAAKX,MAAMU,KAAKuC,cACpDG,QACC0F,EAAUhB,KAAKC,MAAM9E,EAActC,KAAKX,MAAMU,KAAKuC,cACpDC,SAEC2F,EAAQ1F,OAAS,GAAK2F,EAAQ3F,OAAS,IACzCb,OAAOC,OAAOyF,EAAa7D,OAAOiD,QAAQ,SAAA1C,GACxC,IAAoB,IAAhBA,EAAKJ,OAAgBI,EAAKhE,KAAO,EAAKV,MAAMU,GAAI,CAClD,GAAIiI,EAAY,IAAM,EAAG,CACvB,IAAII,EACFnC,EAAc,EAAK5G,MAAMU,IAAIuG,IAC5BtB,EAAwBF,GAAakD,EAAY,GAChDK,EAASJ,EACb,EAAKlE,KAAK,CACRoB,MACAtB,EAAGuE,EACHtE,EAAGuE,EACHjD,KAAMlC,EAAQhD,EAAS6D,EAAKhE,OAE9BkG,EAAclC,EAAKhE,IAAM,CACvBuG,GAAI8B,EACJ1B,GAAI2B,EACJP,GAAIM,EAAStD,EACbiD,GAAIM,EAAStD,OAEV,CACL,IAAIuD,EACFrC,EAAc,EAAK5G,MAAMU,IAAIuG,IAC5BtB,EAAwBF,IAAckD,EAAY,GAAK,GACtDO,EAAQN,EACZ,EAAKlE,KAAK,CACRoB,MACAtB,EAAGyE,EACHxE,EAAGyE,EACHnD,KAAMlC,EAAQhD,EAAS6D,EAAKhE,OAE9BkG,EAAclC,EAAKhE,IAAM,CACvBuG,GAAIgC,EACJ5B,GAAI6B,EACJT,GAAIQ,EAAQxD,EACZiD,GAAIQ,EAAQxD,GAGhBiD,OAQNA,EAAY,EAEZ,IAAIQ,EAAc,GAClB7G,OAAOC,OAAOyF,EAAa7D,OAAOiD,QAAQ,SAAA1C,GACrB,IAAfA,EAAKJ,OAAeI,EAAKhE,KAAO,EAAKV,MAAMU,IAC7CyI,EAAYxB,KAAKjD,KAOrB,IAJA,IAAI0E,EAAcC,KAAKC,MAAMH,EAAYhG,OAAS,GAAK,EACnDoG,EACF3C,EAAcjG,KAAKX,MAAMU,IAAIuG,IAC5BxB,EAAYE,IAA0ByD,EAAc,GAC9CpF,EAAI,EAAGA,EAAImF,EAAYhG,OAAQa,IACtCrD,KAAK+D,KAAK,CACRoB,MACAtB,EAAG+E,EACH9E,EAAGmC,EAAcjG,KAAKX,MAAMU,IAAI2G,GAChCtB,KAAMlC,EAAQhD,EAASsI,EAAYnF,GAAGtD,OAExCkG,EAAcuC,EAAYnF,GAAGtD,IAAM,CACjCuG,GAAIsC,EACJlC,GAAIT,EAAcjG,KAAKX,MAAMU,IAAI2G,GACjCoB,GAAIc,EAAY9D,EAChBiD,GAAI9B,EAAcjG,KAAKX,MAAMU,IAAMgF,GAEjC1B,IAAMoF,EACRG,GAA8D,GAArC9D,EAAYE,GAErC4D,EAAYA,EAAY9D,EAAYE,EAKxCgD,EAAY,EACZ,IAAI5B,EAAWe,KAAKC,MAAM9E,EAActC,KAAKX,MAAMU,KAAKuC,cACrDI,SACCkE,EAAWO,KAAKC,MAAM9E,EAActC,KAAKX,MAAMU,KAAKuC,cACrDO,SAECgG,EAAc,EACdC,EAAa,EACbC,GAAoB,EACxBnC,EAASH,QAAQ,SAAAuC,GACfH,GAAeG,EAAEzE,MAAM/B,OACvBsG,GAAcE,EAAExE,eAAehC,OACC,IAA5BwG,EAAExE,eAAehC,SACnBuG,GAAoB,KAGpBA,IACF/I,KAAK+D,KAAK,CACRoB,MACAtB,EACEoC,EAAcuC,EAAYA,EAAYhG,OAAS,GAAGzC,IAAI+H,GACtD9C,EACFlB,EAAGmC,EAAcjG,KAAKX,MAAMU,IAAI2G,GAChCtB,KAAM,YAERa,EAAa,QAAc,CACzBK,GACEL,EAAcuC,EAAYA,EAAYhG,OAAS,GAAGzC,IAAI+H,GACtD9C,EACF0B,GAAIT,EAAcjG,KAAKX,MAAMU,IAAI2G,GACjCoB,GACE7B,EAAcuC,EAAYA,EAAYhG,OAAS,GAAGzC,IAAI+H,GACtD9C,EACAF,EACFiD,GAAI9B,EAAcjG,KAAKX,MAAMU,IAAI2G,GAAK3B,IAG1C,IAAIkE,EACFhD,EAAcjG,KAAKX,MAAMU,IAAIuG,GAC5BuC,EAAc,GAAM/D,EAAYE,GAC/BkE,EACFjD,EAAcjG,KAAKX,MAAMU,IAAIgI,GAC7B/H,KAAKT,MAAM2F,eACE,GAAb4D,EACA,GAEFlC,EAASH,QAAQ,SAAApD,GACf,IAAK,IAAIiB,EAAI,EAAGA,EAAIjB,EAAEkB,MAAM/B,OAAQ8B,IAClC,EAAKP,KAAK,CACRoB,MACAtB,EAAGoF,EAAYjB,GAAalD,EAAYE,GACxClB,EAAGoF,EACH9D,KAAMlC,EAAQhD,EAASmD,EAAEkB,MAAMD,GAAG5E,aAEpCuG,EAAc5C,EAAEkB,MAAMD,GAAG5E,UAAY,CACnC4G,GAAI2C,EAAYjB,GAAalD,EAAYE,GACzC0B,GAAIwC,EACJpB,GACEmB,EACAjB,GAAalD,EAAYE,GACzBF,EACFiD,GAAImB,EAAYnE,GAElBiD,MAYJ,IAAImB,EAAoB,GACxBA,EAAkBnJ,KAAKX,MAAMU,IAAMkG,EAAcjG,KAAKX,MAAMU,IAE5DqG,EAASK,QAAQ,SAAAxD,GACfkG,EAAkBlG,EAAEvD,UAAYuG,EAAchD,EAAEvD,YAGlD,IAAI+E,EAAW0D,EAAQ3F,OAAS,GAAK0F,EAAQ1F,OAAS,EAClD4G,EAAkB,GAClBjB,EAAQ3F,OAAS,EACnB2F,EAAQ1B,QAAQ,SAAA4C,GACdnB,EAAQzB,QAAQ,SAAA6C,GACdF,EAAgBpC,KAAK,CACnBd,QAASmD,EAAE3J,SACXyG,QAASmD,EAAE5J,eAIRwI,EAAQ1F,OAAS,EAC1B0F,EAAQzB,QAAQ,SAAA6C,GACdnB,EAAQ1B,QAAQ,SAAA4C,GACdD,EAAgBpC,KAAK,CACnBd,QAASmD,EAAE3J,SACXyG,QAASmD,EAAE5J,eAOM,IAAnByI,EAAQ3F,QAAmC,IAAnB0F,EAAQ1F,QAClC4G,EAAgBpC,KAAK,CACnBd,QAASiC,EAAQ,GAAGzI,SACpByG,QAAS+B,EAAQ,GAAGxI,WAK1B0J,EAAgB3C,QAAQ,SAAA8C,GACtB,EAAKC,WAAW,CACdrE,MACAc,gBACAC,QAASqD,EAAErD,QACXC,QAASoD,EAAEpD,QACXrC,EAAGmE,EACH7B,SAAU+C,EACV1E,SAAUA,MAMd,IAAIoC,EAAc,GAClBD,EAASH,QAAQ,SAAApD,GACf,IAAIyD,EAAiB,EAAK2C,UAAU,CAClCtE,MACAc,gBACAU,QAAStD,EAAEmB,eACXoC,SAAUvD,EAAEkB,MACZsC,YAAaA,IAEfA,EAAcC,O,+BAOlB,OACE,yBAAKjI,MAAO,CAAEE,UAAW,WACvB,sDAA4BmE,EAAQhD,EAASF,KAAKX,MAAMU,MACxD,yBAAKlB,MAAO,CAAE6K,aAAc,SAC1B,uCACA,yBAAK7K,MAAO,CAAE6K,aAAc,OAAQC,UAAW,SAE7C,0BAAM5J,GAAG,uBAAT,cACA,0BAAMA,GAAG,yBAAT,oBAEF,yBAAKlB,MAAO,CAAE6K,aAAc,SAC1B,0BAAM3J,GAAG,uBAAT,2BACA,0BAAMA,GAAG,uBAAT,sBACA,0BAAMA,GAAG,sBAAT,sBACA,0BAAMA,GAAG,qBAAT,0BA6BJ,yBACE6J,IAAI,iBACJ/K,MAAO,CACLgL,SAAU,SACVC,OAAQ,oBACRC,SAAU,OACVrI,UAAW,OACX3C,UAAW,WAGb,4BACE6K,IAAI,cACJ7J,GAAG,oBACHZ,MAAO,IACP6K,OAAQ,Y,GAvdM9H,IAAMC,W,iBCkjBjB8H,E,YA/hBb,WAAY5K,GAAa,IAAD,8BACtB,4CAAMA,KAMDE,MAAQ,CACXQ,GAAI,UACJmK,KAAM,GACN5H,cAAe,CACbC,QAAS,GACTE,QAAS,GACTC,SAAU,GACVC,KAAM,GACNC,QAAS,GACTC,SAAU,IAEZsH,QAAS,CAAEC,IAAK,GAAIC,MAAO,IAC3BC,KAAM,GACNC,aAAa,EACbC,gBAAiB,CAAE9K,SAAU,GAAI+K,QAAS,KAM5C,EAAKC,kBAAoB,EAAKA,kBAAkB9K,KAAvB,gBA3BH,E,4EAoCT6K,GACb,IAAI1K,EAAK0K,EAAQE,QACbC,EAAiBC,EAAS9K,GAAI+K,OAC9BC,EAAgBF,EAAS9K,GAAIiL,MAC7BC,EAAgBJ,EAAS9K,GAAImL,QAC7BC,EAAcV,EAAQW,MAGtBC,EAAc,GACdC,EAAWT,EAAS9K,GAAI,WAAWa,MAAM,MAc7C,OAPAyK,EAAM,sCALJA,EADEC,EAAS9I,QAAU,EACf8I,EAAS,GAETT,EAAS9K,GAAI,YAIC,KAAlB0K,EAAQW,QAEVC,EAAMA,EAAM,KADZF,EAAMN,EAASM,GAAKD,UAGtBG,GAAY,uBAGV,8BACG,MACD,uBACEhH,OAAO,SACPkH,IAAI,sBACJC,KAAMH,EACNxM,MAAO,CACL4M,MAAO,OACPhK,SAAU,WAGXmJ,EAAS,KACV,0BAAM/L,MAAO,CAAE6M,UAAW,WAAaX,GAVzC,IAUwDE,EACrDA,IAAUE,GAAe,KAARA,EAAa,IAAMA,EAAM,IAE5C,O,wCAKWzL,GAChBU,IAAQC,MAAM,CACZC,SAAU,cACVC,OAAQ,gDAEVP,KAAKX,MAAMsM,QAAQ3E,KAAK,iBAAmBtH,K,oCAU/BkM,EAAsBC,GAAuB,IAAD,OAEpDC,EACe,YAAjBF,EACI5L,KAAKT,MAAM4K,QAAQE,MAHdrK,KAIAT,MAAM+C,cAAcsJ,GAC/B,OAAqB,IAAjBE,EAAMtJ,OAEN,yBAAK3D,MAAO,CAAEkN,MAAO,SACnB,yBACElN,MAAO,CACLmN,WAAY,OACZC,cAAe,YACfC,MAAO,OACPC,aAAc,OACdxC,UAAW,WAGZ3J,KAAKoM,iBAAiBR,IAEzB,yBAAK/M,MAAO,CAAEqN,MAAO,OAAQvC,UAAW,WACrCmC,EAAMjK,IAAI,SAAAC,GACT,OACE,yBAAKjD,MAAO,CAAEwC,OAAQ,MACnB,EAAKgL,yBACJvK,EACA8J,EACAC,QASP,O,uCAIMD,GACf,MAAqB,YAAjBA,EACKA,EAAe,KACI,YAAjBA,GAA+C,YAAjBA,EAChCU,IAAUC,SAASX,GAAgB,KAEY,IAAlD5L,KAAKT,MAAM+C,cAAcsJ,GAAcpJ,OAClC8J,IAAUC,SAASX,GAAgB,KAEnCA,EAAe,O,+CAM1B9J,EACA8J,EACAC,GACC,IAAD,OAGA,MACoB,YAAjBD,GAA8B9J,EAAO0K,wBACpB,YAAjBZ,GAA8B9J,EAAO2K,uBAGpC,8BACE,yBACExK,UAAU,gBACVD,QAAS,kBAAM,EAAK0I,kBAAkB5I,EAAOpC,YAE5CoC,IAZE9B,KAYcT,MAAM+C,cAAcsJ,GAAc,GACjD,qCAEA,GAEF,0BAAM/M,MAAO,CAAE6N,eAAgB,cAAgB5K,EAAOuC,SAExD,qDACCwH,EACG/J,EAAO2I,QAAQ5I,IAAI,SAAA4I,GACjB,OAAO,EAAKkC,eAAelC,KAE7B,IAGkB,YAAjBmB,GAA8B9J,EAAO8K,YAE5C,8BACG9K,IA9BI9B,KA8BYT,MAAM+C,cAAcsJ,GAAc,GACjD,qCAEA,GAEF,iDACCC,EACG/J,EAAO2I,QAAQ5I,IAAI,SAAA4I,GACjB,OAAO,EAAKkC,eAAelC,KAE7B,IAGkB,aAAjBmB,EAEP,yBAAK3J,UAAU,wBACb,yBAAKA,UAAU,yBA9CVjC,KA+CG6M,sBAAsB/K,IA/CzB9B,KAiDC8M,mBAAmBhL,EAAO0C,iBAKlC,8BACE,yBACEvC,UAAU,gBACVD,QAAS,kBAAM,EAAK0I,kBAAkB5I,EAAOpC,YAE3B,aAAjBkM,GACgB,aAAjBA,GACiB,YAAjBA,GACiB,YAAjBA,GACA9J,IA/DG9B,KA+DaT,MAAM+C,cAAcsJ,GAAc,GAChD,qCAEA,GAEF,0BAAM/M,MAAO,CAAE6N,eAAgB,cAAgB5K,EAAOuC,SAEvDwH,EACC/J,EAAO2I,QAAQ5I,IAAI,SAAA4I,GACjB,OAAO,EAAKkC,eAAelC,KAG7B,0BAAM5L,MAAO,CAAEsN,aAAc,c,4CAOjBY,GAAa,IAAD,OAChC,OAAOA,EAAMxI,MAAM1C,IAAI,SAAAmH,GACrB,OACE,yBACE/G,UAAU,sBACVD,QAAS,kBAAM,EAAK0I,kBAAkB1B,EAAEtJ,YAEvCsJ,EAAE3E,Y,yCAMQG,GAAwB,IAAD,OACxC,OAA8B,IAA1BA,EAAehC,OACV,yBAAKP,UAAU,2BAGpB,yBAAKA,UAAU,0BAAf,OACO,IACJuC,EAAe3C,IAAI,SAAAmL,GAClB,OACE,8BACE,0BACE/K,UAAU,sBACVpD,MAAO,CAAEwC,OAAQ,GACjBW,QAAS,kBAAM,EAAK0I,kBAAkBsC,KAErC9J,EAAQhD,EAAS8M,KAEnBxI,EAAeyI,QAAQD,KAASxI,EAAehC,OAAS,EACrD,GACA,a,6CASM,IAAD,OAErB,GAAsC,IAD3BxC,KACFT,MAAM4K,QAAQC,IAAI5H,OACzB,OACE,yBAAK3D,MAAO,CAAE8K,UAAW,OAAQ5K,UAAW,WAC1C,yBACEF,MAAO,CACLmN,WAAY,OACZC,cAAe,YACfS,eAAgB,YAChBhD,aAAc,SACdC,UAAW,SANf,YAJK3J,KAeCT,MAAM4K,QAAQC,IAAIvI,IAAI,SAAAqL,GAC1B,OACE,yBAAKrO,MAAO,CAAEwC,OAAQ,MACpB,0BACEY,UAAU,oBACVD,QAAS,kBAAM,EAAK0I,kBAAkBwC,EAAOxN,YAE5CwN,EAAO7I,QAET6I,EAAOzC,QAAQ5I,IAAI,SAAA4I,GAClB,OAAO,EAAKkC,eAAelC,W,8CAUnB1K,GACtB,IAAImE,EAA6B,WAAlB9B,EAAUrC,GAAmB,YAAc,OAEtD4G,EAAUzD,EACZhD,EAASA,EAASH,GAAI,0CAEpBG,EAASH,GAAI,gCACf4G,EACEA,EACA,QACAzD,EAAQhD,EAASA,EAASH,GAAI,iCAElC,IAAIoN,EAAgBjN,EAASH,GAAI,0CAC7B,MACAmD,EACEhD,EAASA,EAASH,GAAI,4CAExB,GA+BJ,OACE,yBAAKA,GAAG,4BAAR,OACOmE,EADP,OACqByC,EADrB,IAC+BwG,K,2CAKb,IAAD,OACnB,MAC0C,KAAxCnN,KAAKT,MAAMiL,gBAAgB9K,UAC3BM,KAAKT,MAAMiL,gBAAgBC,UAAY,GAGrC,yBACE1K,GAAG,2BACHkC,UAC0C,KAAxCjC,KAAKT,MAAMiL,gBAAgB9K,UAC3BM,KAAKT,MAAMiL,gBAAgBC,UAAY,GACnC,aACA,IANR,uBASuB,IACoB,KAAxCzK,KAAKT,MAAMiL,gBAAgB9K,SAC1B,GAEA,8BACE,0BACEuC,UAAU,oBACVD,QAAS,kBACP,EAAK0I,kBAAkB,EAAKnL,MAAMiL,gBAAgB9K,YAGnDwD,EAAQhD,EAASF,KAAKT,MAAMiL,gBAAgB9K,YAE9CM,KAAKT,MAAMiL,gBAAgBC,QAAQ5I,IAAI,SAAA4I,GACtC,OAAO,EAAKkC,eAAelC,OAO9B,O,0CAST,IAAM2C,EAASC,IAAYjG,MAAMpH,KAAKX,MAAMuE,SAAS0J,OAAOC,MAAM,IAC5DxN,EAAKqN,EAAOrN,GAClB,GAAKqN,EAAOrN,GAIL,CAEL,IAAIyN,EAAWrG,KAAKC,MAAM9E,EAAcvC,IACxCC,KAAKe,SAAS,CACZhB,GAAIyN,EAASzN,GACbuC,cAAekL,EAASlL,cACxB6H,QAASqD,EAASrD,QAClBD,KAAMsD,EAAStD,KACfI,KAAMkD,EAASlD,KACfC,YAAaiD,EAASjD,YACtBC,gBAAiBgD,EAAShD,uBAX5BxK,KAAKe,SAAS,CAAEwJ,aAAa,M,2CAiB/B,IAAM6C,EAASC,IAAYjG,MAAMpH,KAAKX,MAAMuE,SAAS0J,OAAOC,MAAM,IAC5DxN,EAAKqN,EAAOrN,GAClB,GAAKqN,EAAOrN,IAIL,GAAIC,KAAKT,MAAMQ,KAAOA,EAAI,CAE/B,IAAIyN,EAAWrG,KAAKC,MAAM9E,EAAcvC,IACxCC,KAAKe,SAAS,CACZhB,GAAIyN,EAASzN,GACbuC,cAAekL,EAASlL,cACxB6H,QAASqD,EAASrD,QAClBD,KAAMsD,EAAStD,KACfI,KAAMkD,EAASlD,KACfC,YAAaiD,EAASjD,YACtBC,gBAAiBgD,EAAShD,wBAX5BxK,KAAKe,SAAS,CAAEwJ,aAAa,M,+BAoBvB,IHwYkBxK,EGxYnB,OACP,OACE,kBAAC,IAAMqB,SAAP,KACE,yBACEa,UAAWjC,KAAKT,MAAMgL,YAAc,aAAe,GACnD1L,MAAO,CAAEE,UAAW,SAAU0O,QAAS,SAFzC,kEAMA,yBAAKxL,UAAWjC,KAAKT,MAAMgL,YAAc,GAAK,cAC5C,yBACE1L,MAAO,CACLwC,OAAQ,sBACRoM,QAAS,OACTC,QAAS,YACT5D,OAAQ,oBAGV,yBAAKjL,MAAO,CAAEE,UAAW,YHsXPgB,EGrXDC,KAAKT,MAAMQ,GHsXlCG,EAASH,GAC4B,0BAAnCG,EAASH,GAAI,kBACR,wBACqC,uBAAnCG,EAASH,GAAI,kBACf,6BACqC,8BAAnCG,EAASH,GAAI,kBACf,4BAEA,GAGF,KG/XC,yBAAKA,GAAG,oBAAoBC,KAAKT,MAAM2K,MACvC,yBAAKnK,GAAG,uBH0Te,SAACA,GAClC,IAAII,EAAuB,GAM3B,OALAA,GAAgB2C,EAAc,yBAA0B3C,EAAcJ,GACtEI,GAAgB2C,EAAc,mBAAoB3C,EAAcJ,GAChEI,GAAgB2C,EAAc,sBAAuB3C,EAAcJ,GAG9C,MAFrBI,GAAgB2C,EAAc,oBAAqB3C,EAAcJ,IAGxDI,EAEA,mBAAqBA,EAAe,IGnUhCwN,CAAoB3N,KAAKT,MAAMQ,KAElC,yBAAKA,GAAG,oBAAR,aAAsCC,KAAKT,MAAMQ,IACjD,yBACEA,GAAG,sBACHkC,UAAwC,KAA7BG,EAAUpC,KAAKT,MAAMQ,IAAa,aAAe,IAF9D,WAIWqC,EAAUpC,KAAKT,MAAMQ,KAGhC,yBACEkC,UACEI,EAAiBrC,KAAKT,MAAM+C,eAAiB,GAAK,eAItD,6BAAMtC,KAAK4N,sBAGX,8BADC1N,EAASF,KAAKT,MAAMQ,IAAI,kBAErBC,KAAK6N,wBAAwB7N,KAAKT,MAAMQ,IACxC4B,OAAOmM,KAAK9N,KAAKT,MAAM+C,eAAeT,IAAI,SAAAV,GACxC,MACU,YAARA,GACQ,YAARA,GACQ,YAARA,EAEO,yBAAKA,IAAKA,GAAM,EAAK4M,cAAc5M,GAAK,IAG7C,yBAAKA,IAAKA,GAAM,EAAK4M,cAAc5M,GAAK,MAIb,IAApCnB,KAAKT,MAAM4K,QAAQE,MAAM7H,OACxB,6BAAMxC,KAAK+N,cAAc,WAAW,IAEpC,GAEF,6BAAM/N,KAAKgO,0BAGf,yBACE/L,UACgD,UAA9C/B,EAASF,KAAKT,MAAMQ,IAAI,kBACpB,GACA,cAGN,kBAAC,EAAD,CACEA,GAAIC,KAAKT,MAAMQ,GACfkO,oBAAqBjO,KAAK0K,0B,GAvhBdxI,IAAMC,W,QCgBf+L,E,YAtCb,WAAY7O,GAAa,IAAD,8BACtB,4CAAMA,KACDE,MAAQ,CACX4O,UAAW,IAHS,E,0EAOXC,GACXpO,KAAKe,SAAS,CAAEoN,UAAWC,M,0CAI3BhO,IAAQiO,WAAW,kBACnBjO,IAAQkO,SAAS,e,+BAIjB,OACE,yBACEzP,MAAO,CAAE0P,gBAAiB,UAAWvE,OAAQ,OAAQ7K,MAAO,SAE5D,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAMM,GAAG,KACP,kBAAC,EAAD,OAEF,kBAAC,EAAD,MACA,kBAAC,IAAD,KAEE,kBAAC,IAAD,CAAO+O,KAAK,UAAUC,UAAWrP,IACjC,kBAAC,IAAD,CAAOoP,KAAK,aAAaC,UAAWxE,IACpC,kBAAC,IAAD,CAAOwE,UAAW,kBAAM,kBAAC,IAAD,CAAUhP,GAAG,gB,GA/B/ByC,IAAMC,WCFJuM,QACW,cAA7BC,OAAO/K,SAASgL,UAEe,UAA7BD,OAAO/K,SAASgL,UAEhBD,OAAO/K,SAASgL,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAAStO,SAASC,eAAe,SDmI3C,kBAAmBsO,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC,iB","file":"static/js/main.167db7e2.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/arrow.1cd80763.svg\";","module.exports = __webpack_public_path__ + \"static/media/logo.1740fffd.svg\";","import React from \"react\";\nimport \"./App.css\";\n\nconst Header: React.FC = () => {\n  return (\n    <div style={{ paddingTop: \"4rem\", textAlign: \"center\" }}>\n      <img\n        src={require(\"./images/logo.svg\")}\n        alt=\"Manto logo\"\n        style={{ width: \"20%\" }}\n      ></img>\n    </div>\n  );\n};\n\nexport default Header;\n","import React from \"react\";\nimport \"./App.css\";\nimport entities from \"./data/entities.json\";\nimport { Redirect } from \"react-router-dom\";\nimport arrow from \"./images/arrow.svg\";\nimport ReactGA from \"react-ga\";\n\ntype SearchProps = {};\ntype SearchState = {\n  redirect: boolean;\n  targetID: string;\n};\n\nclass Search extends React.Component<SearchProps, SearchState> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      redirect: false,\n      targetID: \"\"\n    };\n    // this.onSearchSubmit = this.onSearchSubmit.bind(this);\n    this.handleSearch = this.handleSearch.bind(this);\n    this.handleSearchKeyDown = this.handleSearchKeyDown.bind(this);\n    this.getDescriptors = this.getDescriptors.bind(this);\n  }\n\n  getDescriptors(id: string) {\n    if (this.hasKey(entities, id)) {\n      let alternatives: string = \"\";\n      if (entities[id][\"Name (transliteration)\"] !== \"\") {\n        alternatives =\n          alternatives + \", \" + entities[id][\"Name (transliteration)\"];\n      }\n      if (entities[id][\"Name (Latinized)\"] !== \"\") {\n        alternatives = alternatives + \", \" + entities[id][\"Name (Latinized)\"];\n      }\n      if (entities[id][\"Name in Latin texts\"] !== \"\") {\n        alternatives =\n          alternatives + \", \" + entities[id][\"Name in Latin texts\"];\n      }\n      if (entities[id][\"Alternative names\"] !== \"\") {\n        alternatives = alternatives + \", \" + entities[id][\"Alternative names\"];\n      }\n      let inputText =\n        entities[id][\"Name (Smith & Trzaskoma)\"] +\n        alternatives +\n        \": \" +\n        entities[id][\"Identifying information\"];\n      return inputText;\n    }\n  }\n\n  pageRedirect = () => {\n    if (this.state.redirect) {\n      return <Redirect to={\"/datacards?id=\" + this.state.targetID} />;\n    }\n  };\n\n  handleSearch() {\n    ReactGA.event({\n      category: \"Search\",\n      action: \"User searched for an entity using the search bar\"\n    });\n    let currentInput = document.getElementById(\"input\") as HTMLInputElement;\n    if (currentInput.value !== \"\") {\n      //Search based on name and identifying information - super inefficient. TODO: fix this\n      for (let id in entities) {\n        if (this.hasKey(entities, id)) {\n          if (\n            entities[id][\"Identifying information\"] ===\n            currentInput.value.split(\": \")[1]\n          ) {\n            let currentInputName = currentInput.value\n              .split(\": \")[0]\n              .split(\",\")[0]\n              .trim();\n\n            if (\n              currentInputName === entities[id][\"Name (Smith & Trzaskoma)\"] ||\n              currentInputName === entities[id][\"Name (transliteration)\"] ||\n              currentInputName === entities[id][\"Name (Latinized)\"] ||\n              currentInputName === entities[id][\"Name in Latin texts\"] ||\n              currentInputName === entities[id][\"Alternative names\"]\n            ) {\n              this.setState({\n                redirect: true,\n                targetID: id\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n\n  handleSearchKeyDown(event: any) {\n    if (event.which === 13 || event.keyCode === 13) {\n      this.handleSearch();\n    }\n  }\n\n  /* Addresses typescript indexing objects error */\n  hasKey<O>(obj: O, key: keyof any): key is keyof O {\n    return key in obj;\n  }\n\n  render() {\n    /* const entitiesArray = Object.values(entities).map(entity => {\n      return {\n        // what to show to the user\n        label: entity.ID + \": \" + this.getDescriptors(entity.ID),\n        // key to identify the item within the array\n        key: entity.ID\n      };\n    }); */\n    return (\n      <React.Fragment>\n        {/* <h3 style={{ textAlign: \"center\" }}>SEARCH</h3> */}\n        {this.pageRedirect()}\n        <div\n          style={{\n            margin: \"1rem 0 1rem 0\",\n            textAlign: \"center\"\n          }}\n        >\n          {/* <DataListInput\n          placeholder={\"Search by entity name...\"}\n          items={entitiesArray}\n          onSelect={this.pageRedirect}\n          match={this.matchCurrentInput}\n        /> */}\n          <input\n            // type=\"search\"\n            placeholder=\"Search by name\"\n            id=\"input\"\n            list=\"entities\"\n            onKeyDown={this.handleSearchKeyDown}\n            style={{ width: \"50%\", textAlign: \"center\", fontSize: \"1rem\" }}\n          ></input>\n          <datalist id=\"entities\" style={{ maxHeight: \"100px\" }}>\n            {Object.values(entities).map(entity => {\n              return (\n                <option value={this.getDescriptors(entity[\"ID\"])}></option>\n              );\n            })}\n          </datalist>\n          <div>\n            <img\n              alt=\"Submit search\"\n              src={arrow}\n              onClick={this.handleSearch}\n              className=\"search-arrow\"\n            ></img>\n          </div>\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default Search;\n","var ties = require(\"./data/ties.json\");\nvar entities = require(\"./data/entities.json\");\nvar relationships = require(\"./data/relationships.json\");\n\ntype passageInfo = {\n  start: string;\n  startID: string;\n  end: string;\n  endID: string;\n};\n\ntype entityInfo = {\n  target: string;\n  targetID: string;\n  passage: passageInfo[];\n  type: string;\n  autochthony?: boolean;\n  mother_parthenogenesis?: boolean;\n  father_parthenogenesis?: boolean;\n};\n\ntype childrenInfo = {\n  child: entityInfo[];\n  otherParentIDs: string[];\n  divineParentID?: string;\n};\n\nexport type relationshipInfo = {\n  MOTHERS: entityInfo[];\n  FATHERS: entityInfo[];\n  SIBLINGS: entityInfo[];\n  TWIN: entityInfo[];\n  SPOUSES: entityInfo[];\n  CHILDREN: childrenInfo[];\n};\n\ntype returningInfo = {\n  id: string;\n  relationships: relationshipInfo;\n  name: string;\n  members: { sub: any[]; super: any[] };\n  type: string;\n  validSearch: boolean;\n  alternativeName: { targetID: string; passage: passageInfo[] };\n};\n\nlet familyTies = [\n  /* Parent */\n  \"is father of\",\n  \"is mother of\",\n  \"is parent of\",\n  /* Child */\n  \"is child of\",\n  /* Sibling */\n  \"is sibling of\",\n  \"is twin of\",\n  \"is older than\",\n  /* Spouse */\n  \"is spouse of\",\n  \"marries\",\n  /* Ancestors - currently unused\n  \"is grandfather of\",\n  \"is grandmother of\",\n  \"is grandparent of\",\n  \"is grandson of\",\n  \"is granddaughter of\",\n  \"is grandchild of\",\n  */\n\n  /* Member of collective */\n  \"is part of\",\n  \"is member of\",\n\n  /* Unusual relationships */\n  \"is mother by parthenogenesis of\",\n  \"is father by parthenogenesis of\",\n  \"is born by autochthony [in/on/at]\"\n];\n\n/******************************************************************************************/\n/* Returns the data card geneology information, interfaces with DataCards.tsx                \n/******************************************************************************************/\nexport const updateComponent = (id: string) => {\n  let connections = getAllConnections(id);\n  if (\n    connections.length > 0 &&\n    connections[0].verb === \"is alternative name for\"\n  ) {\n    let empty: relationshipInfo = {\n      MOTHERS: [],\n      FATHERS: [],\n      SIBLINGS: [],\n      TWIN: [],\n      SPOUSES: [],\n      CHILDREN: []\n    };\n    let altNameConnection: returningInfo = {\n      id: id,\n      relationships: empty,\n      name: getName(entities[id]),\n      members: { sub: [], super: [] },\n      type: entities[id] ? entities[id][\"Type of entity\"] : \"\",\n      validSearch: true,\n      alternativeName: {\n        targetID: connections[0].targetID,\n        passage: connections[0].passage\n      }\n    };\n    return altNameConnection;\n  } else {\n    return sortConnectionsIntoRelationships(id, connections);\n  }\n};\n\n/******************************************************************************************/\n/* Find all relationships                                                                 */\n/* -------------------------------------------------------------------------------------- */\n/* This function changes all ties (X <verb> Y, Y <verb> X, Z <verb> Y X) to Y <verb> X. */\n/******************************************************************************************/\nconst getAllConnections = (id: string) => {\n  var connections: {\n    target: string;\n    targetID: string;\n    verb: string;\n    passage: passageInfo[];\n  }[] = [];\n\n  Object.values(ties).forEach(function(tieRow) {\n    // TODO: Fix this temporary solution for entities not existing in entities.csv\n    if (typeof tieRow !== \"object\" || tieRow === null) {\n    } else {\n      // The first if statement is to remove \"object is of type unknown\" error\n\n      if (entities[tieRow[\"Subject ID\"]]) {\n        //check if the entity is just an \"alternative name for\"\n        //if so, ignore all geneological data gathered so far and just return connections = [{target: \"\", targetID: \"\", verb: \"is alternative name for\", passage:[]}]\n\n        if (\n          tieRow[\"Subject ID\"] === id &&\n          tieRow[\"Verb\"] === \"is alternative name for\"\n        ) {\n          let passageInfo: passageInfo[] = [\n            {\n              start: tieRow[\"Passage: start\"],\n              startID: tieRow[\"Passage: start ID\"],\n              end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n              endID:\n                tieRow[\"Passage: end ID\"] === \"\"\n                  ? \"\"\n                  : tieRow[\"Passage: end ID\"]\n            }\n          ];\n          connections = [\n            {\n              target: \"\",\n              targetID: tieRow[\"Direct Object ID\"],\n              verb: \"is alternative name for\",\n              passage: passageInfo\n            }\n          ];\n          return connections;\n        }\n\n        /*********************************************************/\n        /* If you are the direct object X, e.g. (Y (verb) X)     */\n        /*********************************************************/\n        if (\n          tieRow[\"Direct Object ID\"] === id &&\n          familyTies.includes(tieRow[\"Verb\"])\n        ) {\n          let passageInfo: passageInfo[] = [\n            {\n              start: tieRow[\"Passage: start\"],\n              startID: tieRow[\"Passage: start ID\"],\n              end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n              endID:\n                tieRow[\"Passage: end ID\"] === \"\"\n                  ? \"\"\n                  : tieRow[\"Passage: end ID\"]\n            }\n          ];\n\n          // TODO: Fix this temporary solution for gender data not existing for entity\n          if (getGender(tieRow[\"Subject ID\"]) && tieRow[\"Verb\"] === \"marries\") {\n            tieRow[\"Verb\"] = \"is spouse of\";\n          }\n\n          // Push connections to the list of connections\n          connections.push({\n            target: getName(entities[tieRow[\"Subject ID\"]]),\n            targetID: tieRow[\"Subject ID\"],\n            verb:\n              tieRow[\"Verb\"] === \"is part of\" ||\n              tieRow[\"Verb\"] === \"is member of\"\n                ? \"has members\"\n                : tieRow[\"Verb\"],\n            passage: passageInfo\n          });\n        }\n\n        /*********************************************************/\n        /* If you are the subject X, e.g. (X (verb) Y)           */\n        /*********************************************************/\n        if (\n          tieRow[\"Subject ID\"] === id &&\n          familyTies.includes(tieRow[\"Verb\"])\n        ) {\n          let passageInfo: passageInfo[] = [\n            {\n              start: tieRow[\"Passage: start\"],\n              startID: tieRow[\"Passage: start ID\"],\n              end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n              endID: tieRow[\"Passage: end ID\"]\n            }\n          ];\n\n          // Push connections to the list of connections\n          if (tieRow[\"Verb\"] === \"is born by autochthony [in/on/at]\") {\n            connections.push({\n              target: \"\",\n              targetID: \"\",\n              verb: \"is born by autochthony [in/on/at]\",\n              passage: passageInfo\n            });\n          } else {\n            connections.push({\n              target: getName(entities[tieRow[\"Direct Object ID\"]]),\n              targetID: tieRow[\"Direct Object ID\"],\n              verb:\n                tieRow[\"Verb\"] === \"is part of\" ||\n                tieRow[\"Verb\"] === \"is member of\"\n                  ? \"is member of\"\n                  : reversedVerb(tieRow[\"Verb\"], tieRow[\"Direct Object ID\"]),\n              passage: passageInfo\n            });\n          }\n        }\n\n        /***********************************************************************/\n        /* For \"Gives in marriage:\" - parent gives child in marriage to person */\n        /*************************************************************************/\n\n        // If you are the indirect object X, e.g. (Z (verb) Y X)\n        if (\n          tieRow[\"Indirect Object (to/for) ID\"] &&\n          tieRow[\"Indirect Object (to/for) ID\"] === id &&\n          tieRow[\"Verb\"] === \"gives in marriage [dir. obj.] [ind. obj.]\"\n        ) {\n          let passageInfo: passageInfo[] = [\n            {\n              start: tieRow[\"Passage: start\"],\n              startID: tieRow[\"Passage: start ID\"],\n              end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n              endID: tieRow[\"Passage: end ID\"]\n            }\n          ];\n          connections.push({\n            target: getName(entities[tieRow[\"Direct Object ID\"]]),\n            targetID: tieRow[\"Direct Object ID\"],\n            verb: \"is spouse of\",\n            passage: passageInfo\n          });\n        }\n\n        // If you are the direct object X, e.g. (Z (verb) X Y)\n        else if (\n          tieRow[\"Direct Object ID\"] &&\n          tieRow[\"Direct Object ID\"] === id &&\n          tieRow[\"Verb\"] === \"gives in marriage [dir. obj.] [ind. obj.]\"\n        ) {\n          let passageInfo: passageInfo[] = [\n            {\n              start: tieRow[\"Passage: start\"],\n              startID: tieRow[\"Passage: start ID\"],\n              end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n              endID: tieRow[\"Passage: end ID\"]\n            }\n          ];\n          connections.push({\n            target: getName(entities[tieRow[\"Indirect Object (to/for) ID\"]]),\n            targetID: tieRow[\"Indirect Object (to/for) ID\"],\n            verb: \"is spouse of\",\n            passage: passageInfo\n          });\n        }\n      }\n    }\n  });\n\n  return connections;\n};\n\n/******************************************************************************************/\n/* Sort relationships                                                                     */\n/* -------------------------------------------------------------------------------------- */\n/* This function sorts all of the found connections into existing geneological categories */\n/******************************************************************************************/\nconst sortConnectionsIntoRelationships = (id: string, connections: any) => {\n  /* Preliminary info about the entity */\n  let name = getName(entities[id]);\n  let type = entities[id] ? entities[id][\"Type of entity\"] : \"\";\n  let members: { sub: any[]; super: any[] } = { sub: [], super: [] };\n  let relationships: relationshipInfo = {\n    MOTHERS: [],\n    FATHERS: [],\n    SIBLINGS: [],\n    TWIN: [],\n    SPOUSES: [],\n    CHILDREN: []\n  };\n\n  let childrenTemp: entityInfo[] = [];\n  connections.forEach(tie => {\n    // For each of the connections already found,\n    // build the associated entity object, and\n    // populate with existing information\n    let d: entityInfo = {\n      target: tie.target,\n      targetID: tie.targetID,\n      passage: tie.passage,\n      type:\n        tie.verb === \"is born by autochthony [in/on/at]\"\n          ? \"\"\n          : entities[tie.targetID]\n          ? entities[tie.targetID][\"Type of entity\"]\n          : \"\"\n    };\n\n    /* Categorising the connections, also checking for duplicates */\n\n    // X is your MOTHER\n    if (tie.verb === \"is mother of\") {\n      // If passage is a duplicate / already exists\n      // for this entity, or  in the list of connections\n      relationships.MOTHERS = checkAndRemoveDuplicates(\n        relationships.MOTHERS,\n        d\n      );\n    }\n\n    // X is your MOTHER by parthenogenesis\n    else if (tie.verb === \"is mother by parthenogenesis of\") {\n      let m: entityInfo = {\n        target: tie.target,\n        targetID: tie.targetID,\n        passage: tie.passage,\n        type: entities[tie.targetID]\n          ? entities[tie.targetID][\"Type of entity\"]\n          : \"\",\n        mother_parthenogenesis: true\n      };\n\n      relationships.MOTHERS = checkAndRemoveDuplicates(\n        relationships.MOTHERS,\n        m\n      );\n    }\n\n    // X is your FATHER\n    else if (tie.verb === \"is father of\") {\n      relationships.FATHERS = checkAndRemoveDuplicates(\n        relationships.FATHERS,\n        d\n      );\n    }\n\n    // X is your FATHER by parthenogenesis\n    else if (tie.verb === \"is father by parthenogenesis of\") {\n      let f: entityInfo = {\n        target: tie.target,\n        targetID: tie.targetID,\n        passage: tie.passage,\n        type: entities[tie.targetID]\n          ? entities[tie.targetID][\"Type of entity\"]\n          : \"\",\n        father_parthenogenesis: true\n      };\n      relationships.FATHERS = checkAndRemoveDuplicates(\n        relationships.FATHERS,\n        f\n      );\n    }\n\n    // X is your CHILD\n    else if (tie.verb === \"is child of\") {\n      childrenTemp = checkAndRemoveDuplicates(childrenTemp, d);\n    }\n\n    // X is your SIBLING\n    else if (tie.verb === \"is sibling of\" || tie.verb === \"is older than\") {\n      relationships.SIBLINGS = checkAndRemoveDuplicates(\n        relationships.SIBLINGS,\n        d\n      );\n    }\n\n    // X is your TWIN\n    else if (tie.verb === \"is twin of\") {\n      relationships.TWIN = checkAndRemoveDuplicates(relationships.TWIN, d);\n    }\n    // X is your WIFE / HUSBAND\n    else if (tie.verb === \"is spouse of\" || tie.verb === \"marries\") {\n      relationships.SPOUSES = checkAndRemoveDuplicates(\n        relationships.SPOUSES,\n        d\n      );\n    }\n    // X is a MEMBER of a collective but the main ID\n    else if (tie.verb === \"is member of\") {\n      members.super = checkAndRemoveDuplicates(members.super, d);\n    } else if (tie.verb === \"has members\") {\n      members.sub = checkAndRemoveDuplicates(members.sub, d);\n    }\n    // X is born by autochthony\n    else if (tie.verb === \"is born by autochthony [in/on/at]\") {\n      let a: entityInfo = {\n        target: \"\",\n        targetID: \"\",\n        passage: tie.passage,\n        type: entities[id] ? entities[id][\"Type of entity\"] : \"\",\n        autochthony: true\n      };\n      relationships.FATHERS = checkAndRemoveDuplicates(\n        relationships.FATHERS,\n        a\n      );\n    }\n  });\n\n  /* TODO: Check for any indirect siblings in the ties */\n  relationships.SIBLINGS = getIndirectSiblings(\n    id,\n    relationships.MOTHERS,\n    relationships.FATHERS,\n    relationships.SIBLINGS\n  );\n\n  /* Alphabetize the relationships */\n  relationships.MOTHERS = alphabetize(relationships.MOTHERS);\n  relationships.FATHERS = alphabetize(relationships.FATHERS);\n  relationships.SIBLINGS = alphabetize(relationships.SIBLINGS);\n  relationships.TWIN = alphabetize(relationships.TWIN);\n  relationships.SPOUSES = alphabetize(relationships.SPOUSES);\n  members.super = alphabetize(members.super);\n  members.sub = alphabetize(members.sub);\n\n  // Currently very inefficient, but finds the other parent of the child\n  relationships.CHILDREN = getOtherParents(id, childrenTemp);\n  // relationships.CHILDREN = alphabetizeChildren(relationships.CHILDREN);\n\n  /* Return alphabetized, complete list of relationships */\n  let connection: returningInfo = {\n    id: id,\n    relationships: relationships,\n    name: name,\n    members: members,\n    type: type,\n    validSearch: true,\n    alternativeName: { targetID: \"\", passage: [] }\n  };\n  return connection;\n};\n\n/******************************************************************************************/\n/* Check passage and entity duplicates                                                    */\n/* -------------------------------------------------------------------------------------- */\n/* This function removes duplicate ties (incl. after reversal) and duplicate passages   */\n/* for the same connected entity                                                          */\n/******************************************************************************************/\nconst checkAndRemoveDuplicates = (entities: any[], d: entityInfo) => {\n  let duplicate = false;\n  entities.forEach(e => {\n    if (e.targetID === d.targetID) {\n      duplicate = true;\n      let passageDuplicate = false;\n      e.passage.forEach(p => {\n        if (\n          p.startID === d.passage[0].startID &&\n          p.endID === d.passage[0].endID\n        ) {\n          passageDuplicate = true;\n        }\n      });\n      if (!passageDuplicate) {\n        e.passage.push(d.passage[0]);\n      }\n    }\n  });\n  if (!duplicate) {\n    entities.push(d);\n  }\n  return entities;\n};\n\nconst checkAndRemoveParentDuplicates = (\n  child: entityInfo, //child to add\n  parentsList: string[], //list of child's parents\n  parentsGrouped: childrenInfo[] //existing parents list to update\n) => {\n  // This function removes duplicates but also groups children by the \"other\" parent\n  // returns childrenInfo object: {child: <list of associated children>, otherParentIDs}\n\n  // If the same child appears under two different \"otherParent\"s, then dispute is expressed\n  // The child will be under {child: <list of children>, otherParents: <list of all parents + disputed>}\n  let parentDuplicate = false;\n  let childDuplicate = false;\n\n  for (let i = 0; i < parentsGrouped.length; i++) {\n    if (isEqual(parentsList, parentsGrouped[i])) {\n      // Is parent duplicate. Now check if child is already in list.\n      parentDuplicate = true;\n      for (let j = 0; j < parentsGrouped[i].child.length; j++) {\n        if (parentsGrouped[i].child[j].targetID === child.targetID) {\n          childDuplicate = true;\n        }\n      }\n      if (!childDuplicate) {\n        parentsGrouped[i].child.push(child);\n      }\n    }\n  }\n\n  if (!childDuplicate && !parentDuplicate) {\n    let newChild: childrenInfo = {\n      child: [child],\n      otherParentIDs: parentsList\n    };\n    parentsGrouped.push(newChild);\n  }\n\n  return parentsGrouped;\n};\n\n/******************************************************************************************/\n/* Alphabetize the list of names in each category                                         */\n/******************************************************************************************/\nconst alphabetize = (relation: any[]) => {\n  if (relation.length === 0) {\n    return [];\n  } else {\n    relation.sort(function(a, b) {\n      var relationA = a.target.toUpperCase();\n      var relationB = b.target.toUpperCase();\n      return relationA < relationB ? -1 : relationA > relationB ? 1 : 0;\n    });\n  }\n  return relation;\n};\n\nconst alphabetizeIDs = (relation: any[]) => {\n  if (relation.length === 0) {\n    return [];\n  } else {\n    relation.sort(function(a, b) {\n      var relationA = a.targetID;\n      var relationB = b.targetID;\n      return relationA < relationB ? -1 : relationA > relationB ? 1 : 0;\n    });\n  }\n  return relation;\n};\n\n/******************************************************************************************/\n/* Check if two arrays are equal                                                          */\n/******************************************************************************************/\nconst isEqual = (parentsList: any[], child: childrenInfo) => {\n  if (parentsList.length !== child.otherParentIDs.length) {\n    return false;\n  } else {\n    for (let i = 0; i < parentsList.length; i++) {\n      if (parentsList[i] !== child.otherParentIDs[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\n/******************************************************************************************/\n/* TODO: Fix this very VERY inefficient method of finding the other parent.               */\n/* Swap for shared NodegoatID                                                             */\n/******************************************************************************************/\nconst getOtherParents = (id: string, children: entityInfo[]) => {\n  let mainGender = getGender(id);\n  let parentsGrouped: childrenInfo[] = [];\n  children.forEach(c => {\n    if (relationships[c.targetID] !== undefined) {\n      var parentsList;\n      if (mainGender === \"Female\") {\n        parentsList = JSON.parse(relationships[c.targetID]).relationships\n          .FATHERS;\n      } else {\n        //temporary solution to undefined gender\n        parentsList = JSON.parse(relationships[c.targetID]).relationships\n          .MOTHERS;\n      }\n      // Convert list of entityInfo to a list of IDs\n      for (let i = 0; i < parentsList.length; i++) {\n        parentsList[i] = parentsList[i].targetID;\n      }\n      parentsList = alphabetizeIDs(parentsList);\n      parentsGrouped = checkAndRemoveParentDuplicates(\n        c,\n        parentsList,\n        parentsGrouped\n      );\n    }\n  });\n  return parentsGrouped;\n};\n\n/******************************************************************************************/\n/* Get the gender of the entity                                                           */\n/******************************************************************************************/\nexport const getGender = (id: string) => {\n  return entities[id] ? entities[id][\"Agent/Coll.: gender\"] : \"\";\n};\n\n/******************************************************************************************/\n/* Tie reversals                                                   */\n/* -------------------------------------------------------------------------------------- */\n/* This function flips the verb so that X can become the direct object,                   */\n/* without compromising the validity of the tie                                         */\n/*                                                                                        */\n/* e.g. X <is mother of> Y, where Y is <male>                                             */\n/* => returns verb <is son of>, to let X become the direct object (Y is son of X)         */\n/******************************************************************************************/\nconst reversedVerb = (verb: string, dirObject: string) => {\n  // TODO: Fix this temporary solution for gender data not existing for entity\n  // PARENT -> CHILD\n  if (verb === \"is parent of\") {\n    // Uses generic \"is child of\" since data cards do not show gender specificity for children\n    return \"is child of\";\n  }\n\n  // CHILD -> PARENT\n  else if (verb === \"is child of\") {\n    if (getGender(dirObject) === \"Female\") {\n      return \"is mother of\";\n    } else if (getGender(dirObject) === \"Male\") {\n      return \"is father of\";\n    } else {\n      // Placeholder since \"is parent of\" is not currently used in data cards\n      return \"\";\n    }\n  }\n\n  // TWIN -> TWIN\n  else if (verb === \"is twin of\") {\n    return \"is twin of\";\n  }\n\n  // SIBLING -> SIBLING\n  else if (verb === \"is sibling of\" || verb === \"is older than\") {\n    return \"is sibling of\";\n  }\n\n  // WIFE -> HUSBAND\n  // HUSBAND -> WIFE\n  // No cases of homosexual relationships in the mythology\n  else if (verb === \"is spouse of\" || verb === \"marries\") {\n    return \"is spouse of\";\n  } else if (verb === \"is member of\" || verb === \"is part of\") {\n    return \"\";\n  } else {\n    console.log(\n      \"Unsure of \" +\n        verb +\n        \" \" +\n        dirObject +\n        \" connection, or connection is not relevant for the datacards.\",\n      verb,\n      dirObject\n    );\n    return \"\";\n  }\n};\n\n/******************************************************************************************/\n/* Populate an array of siblings based on matching parents                                */\n/* -------------------------------------------------------------------------------------- */\n/* This function checks through the list of ties and pushes to the list of siblings:    */\n/*                                                                                        */\n/* e.g. X is <child> of A, X is <child> of B, Y is <child> of A, Y is <child> of B        */\n/******************************************************************************************/\nconst getIndirectSiblings = (\n  id: string,\n  mothers: any[],\n  fathers: any[],\n  siblings: any[]\n) => {\n  // CURRENTLY A VERY SLOW SOLUTION - OPTIMIZE IT LATER\n  // CHANGE TO POPULATING A DATABASE OF RELATIONS AND READING OFF THAT DATABASE\n  // RATHER THAN DYNAMICALLY GENERATING IT HERE (CHANGE TO O(N) NOT LEAVE AS O(N^3))\n  // ALTERNATIVELY: Use Nodegoat ID to determine those in the same datum ID, and then match those\n\n  let newsiblings: {} = {};\n  Object.values(ties).forEach(function(tieRow) {\n    if (typeof tieRow !== \"object\" || tieRow === null) {\n    } else {\n      let testsibling = {\n        motherMatch: false,\n        fatherMatch: false,\n        info: {}\n      };\n      let passageInfo: passageInfo[] = [\n        {\n          start: tieRow[\"Passage: start\"],\n          startID: tieRow[\"Passage: start ID\"],\n          end: tieRow[\"Passage: end\"] === \"\" ? \"\" : tieRow[\"Passage: end\"],\n          endID: tieRow[\"Passage: end ID\"]\n        }\n      ];\n      let testinfo: entityInfo = {\n        target: \"\",\n        targetID: \"\",\n        passage: passageInfo,\n        type: entities[id] ? entities[id][\"Type of entity\"] : \"\"\n      };\n      // Firstly, determine where Y is <child> of A,B\n      if (\n        tieRow[\"Verb\"] === \"is daughter of\" ||\n        tieRow[\"Verb\"] === \"is son of\" ||\n        tieRow[\"Verb\"] === \"is child of\"\n      ) {\n        mothers.forEach(m => {\n          if (m.targetID === tieRow[\"Direct Object ID\"]) {\n            testsibling.motherMatch = true;\n            testinfo.target = getName(entities[tieRow[\"Subject ID\"]]);\n            testinfo.targetID = tieRow[\"Subject ID\"];\n            testsibling.info = testinfo;\n            if (!(tieRow[\"Subject ID\"] in newsiblings)) {\n              newsiblings[tieRow[\"Subject ID\"]] = testsibling;\n            } else {\n              newsiblings[tieRow[\"Subject ID\"]].motherMatch = true;\n            }\n          }\n        });\n        fathers.forEach(f => {\n          if (f.targetID === tieRow[\"Direct Object ID\"]) {\n            testsibling.fatherMatch = true;\n            testinfo.target = getName(entities[tieRow[\"Subject ID\"]]);\n            testinfo.targetID = tieRow[\"Subject ID\"];\n            testsibling.info = testinfo;\n            if (!(tieRow[\"Subject ID\"] in newsiblings)) {\n              newsiblings[tieRow[\"Subject ID\"]] = testsibling;\n            } else {\n              newsiblings[tieRow[\"Subject ID\"]].fatherMatch = true;\n            }\n          }\n        });\n      }\n      // Then, determine where A is mother of Y, or if parent of Y where A is female\n      if (\n        tieRow[\"Verb\"] === \"is mother of\" ||\n        tieRow[\"Verb\"] === \"is divine mother of\" ||\n        (tieRow[\"Verb\"] === \"is parent of\" &&\n          entities[tieRow[\"Subject ID\"]] &&\n          entities[tieRow[\"Subject ID\"]][\"Agent/Coll.: gender\"] === \"Female\")\n      ) {\n        mothers.forEach(m => {\n          if (m.targetID === tieRow[\"Subject ID\"]) {\n            testsibling.motherMatch = true;\n            testinfo.target = getName(entities[tieRow[\"Direct Object ID\"]]);\n            testinfo.targetID = tieRow[\"Direct Object ID\"];\n            testsibling.info = testinfo;\n            if (!(tieRow[\"Direct Object ID\"] in newsiblings)) {\n              newsiblings[tieRow[\"Direct Object ID\"]] = testsibling;\n            } else {\n              newsiblings[tieRow[\"Direct Object ID\"]].motherMatch = true;\n            }\n          }\n        });\n      }\n      // Then, determine where A is father of Y, or if parent of Y where A is male\n      if (\n        tieRow[\"Verb\"] === \"is father of\" ||\n        tieRow[\"Verb\"] === \"is divine father of\" ||\n        (tieRow[\"Verb\"] === \"is parent of\" &&\n          entities[tieRow[\"Subject ID\"]] &&\n          entities[tieRow[\"Subject ID\"]][\"Agent/Coll.: gender\"] === \"Male\")\n      ) {\n        fathers.forEach(f => {\n          if (f.targetID === tieRow[\"Subject ID\"]) {\n            testsibling.fatherMatch = true;\n            testinfo.target = getName(entities[tieRow[\"Direct Object ID\"]]);\n            testinfo.targetID = tieRow[\"Direct Object ID\"];\n            testsibling.info = testinfo;\n            if (!(tieRow[\"Direct Object ID\"] in newsiblings)) {\n              newsiblings[tieRow[\"Direct Object ID\"]] = testsibling;\n            } else {\n              newsiblings[tieRow[\"Direct Object ID\"]].fatherMatch = true;\n            }\n          }\n        });\n      }\n    }\n  });\n  let keys: any[] = Object.keys(newsiblings);\n  keys.forEach(k => {\n    if (\n      !newsiblings[k].motherMatch ||\n      !newsiblings[k].fatherMatch ||\n      k === id\n    ) {\n      delete newsiblings[k];\n    } else {\n      siblings = checkAndRemoveDuplicates(siblings, newsiblings[k].info);\n    }\n  });\n  return siblings;\n};\n\n/******************************************************************************************/\n/* Check if no relations exist for this entity (used in DataCards.tsx)                    */\n/******************************************************************************************/\nexport const checkNoRelations = (relationships: any) => {\n  return (\n    relationships.MOTHERS.length === 0 &&\n    relationships.FATHERS.length === 0 &&\n    relationships.SIBLINGS.length === 0 &&\n    relationships.TWIN.length === 0 &&\n    relationships.SPOUSES.length === 0 &&\n    relationships.CHILDREN.length === 0\n  );\n};\n\nexport const checkNoMembers = (members: any) => {\n  return !members || members.length === 0;\n};\n\n/******************************************************************************************/\n/* Return all alternative names for entity (used in DataCards.tsx)                        */\n/******************************************************************************************/\nexport const getAlternativeNames = (id: string) => {\n  let alternatives: string = \"\";\n  alternatives += getNameString(\"Name (transliteration)\", alternatives, id);\n  alternatives += getNameString(\"Name (Latinized)\", alternatives, id);\n  alternatives += getNameString(\"Name in Latin texts\", alternatives, id);\n  alternatives += getNameString(\"Alternative names\", alternatives, id);\n\n  if (alternatives === \"\") {\n    return alternatives;\n  } else {\n    return \"(Also known as: \" + alternatives + \")\";\n  }\n};\n\nconst getNameString = (parameter: string, stringSoFar: string, id: string) => {\n  let s = \"\";\n  if (entities[id][parameter] !== \"\") {\n    if (stringSoFar === \"\") {\n      s = entities[id][parameter];\n    } else {\n      s = stringSoFar + \", \" + entities[id][parameter];\n    }\n  }\n  return s;\n};\n\n/******************************************************************************************/\n/* Get the entity's name                                                                  */\n/******************************************************************************************/\nexport const getName = (entityRow: any) => {\n  let possibleNames = [\n    \"Name (Smith & Trzaskoma)\",\n    \"Name (transliteration)\",\n    \"Name (Latinized)\",\n    \"Name in Latin texts\",\n    \"Alternative names\"\n  ];\n  if (entityRow) {\n    for (let i = 0; i < possibleNames.length; i++) {\n      if (\n        entityRow[possibleNames[i]] &&\n        entityRow[possibleNames[i]] !== \"\" &&\n        entityRow[possibleNames[i]] !== undefined\n      ) {\n        return entityRow[possibleNames[i]];\n      }\n      return \"\";\n    }\n  } else {\n    return \"\";\n  }\n};\n\n/******************************************************************************************/\n/* Get the entity type                                                                    */\n/******************************************************************************************/\nexport const getEntityType = (id: string) => {\n  if (entities[id]) {\n    if (entities[id][\"Type of entity\"] === \"Collective (Episodic)\") {\n      return \"Collective (Episodic)\";\n    } else if (entities[id][\"Type of entity\"] === \"Collective (misc.)\") {\n      return \"Collective (Miscellaneous)\";\n    } else if (entities[id][\"Type of entity\"] === \"Collective (genealogical)\") {\n      return \"Collective (Genealogical)\";\n    } else {\n      return \"\";\n    }\n  } else {\n    return \"\";\n  }\n};\n","import { nodeType, edgeType } from \"./GraphTypes\";\nimport { getName } from \"./DataCardHandler\";\nimport entities from \"./data/entities.json\";\nimport allRelationships from \"./data/relationships.json\";\nimport \"./EntityGraph.scss\";\n\nexport const getGraph = (id: string) => {\n  let relationships = JSON.parse(allRelationships[id]).relationships;\n  console.log(JSON.parse(allRelationships[id]));\n  return getAllRelationshipLinks(id, relationships);\n};\n\nconst getAllRelationshipLinks = (id: string, relationships: any) => {\n  let nodes = {};\n  let edges = {};\n\n  //The main node is at depth 0 /\n  let mainnode: nodeType = {\n    id: id,\n    depth: 0,\n    location: { x: 0, y: 0 },\n    style: \"\"\n  };\n  nodes[id] = mainnode;\n\n  //All spouses and siblings are at same depth\n  for (let i = 0; i < relationships.SIBLINGS.length; i++) {\n    let node: nodeType = {\n      id: relationships.SIBLINGS[i].targetID,\n      depth: 0,\n      location: { x: 0, y: 0 },\n      style: \"\"\n    };\n    nodes[relationships.SIBLINGS[i].targetID] = node;\n    let edge: edgeType = {\n      from: id,\n      to: relationships.SIBLINGS[i].targetID,\n      relation: \"sibling\",\n      style: \"\"\n    };\n    if (edges[relationships.SIBLINGS[i].targetID]) {\n      // Duplicated edge\n      console.log(\n        \"Sibling suspicious - TODO handle\",\n        relationships.SIBLINGS[i].target\n      );\n    } else {\n      edges[relationships.SIBLINGS[i].targetID] = edge;\n    }\n  }\n  for (let i = 0; i < relationships.SPOUSES.length; i++) {\n    let node: nodeType = {\n      id: relationships.SPOUSES[i].targetID,\n      depth: 0,\n      location: { x: 0, y: 0 },\n      style: \"\"\n    };\n    nodes[relationships.SPOUSES[i].targetID] = node;\n    let edge: edgeType = {\n      from: id,\n      to: relationships.SPOUSES[i].targetID,\n      relation: \"spouse\",\n      style: \"\"\n    };\n    if (edges[relationships.SPOUSES[i].targetID]) {\n      // Duplicated edge\n      console.log(\n        \"Spouse suspicious - TODO handle\",\n        relationships.SPOUSES[i].target\n      );\n    } else {\n      edges[relationships.SPOUSES[i].targetID] = edge;\n    }\n  }\n  for (let i = 0; i < relationships.TWIN.length; i++) {\n    let node: nodeType = {\n      id: relationships.TWIN[i].targetID,\n      depth: 0,\n      location: { x: 0, y: 0 },\n      style: \"\"\n    };\n    nodes[relationships.TWIN[i].targetID] = node;\n    let edge: edgeType = {\n      from: id,\n      to: relationships.TWIN[i].targetID,\n      relation: \"twin\",\n      style: \"\"\n    };\n    if (edges[relationships.TWIN[i].targetID]) {\n      // Duplicated edge\n      console.log(\n        \"Twin suspicious - TODO handle\",\n        relationships.TWIN[i].target\n      );\n    } else {\n      edges[relationships.TWIN[i].targetID] = edge;\n    }\n  }\n\n  //All ancestors are at relative -1\n  for (let i = 0; i < relationships.MOTHERS.length; i++) {\n    let node: nodeType = {\n      id: relationships.MOTHERS[i].targetID,\n      depth: -1,\n      location: { x: 0, y: 0 },\n      style: \"\"\n    };\n    nodes[relationships.MOTHERS[i].targetID] = node;\n    let edge: edgeType = {\n      from: relationships.MOTHERS[i].targetID,\n      to: id,\n      relation: \"mother\",\n      style: \"\"\n    };\n    if (edges[relationships.MOTHERS[i].targetID]) {\n      // Duplicated edge\n      console.log(\n        \"Mother suspicious - TODO handle\",\n        relationships.MOTHERS[i].target\n      );\n    } else {\n      edges[relationships.MOTHERS[i].targetID] = edge;\n    }\n  }\n  for (let i = 0; i < relationships.FATHERS.length; i++) {\n    let node: nodeType = {\n      id: relationships.FATHERS[i].targetID,\n      depth: -1,\n      location: { x: 0, y: 0 },\n      style: \"\"\n    };\n    nodes[relationships.FATHERS[i].targetID] = node;\n    let edge: edgeType = {\n      from: relationships.FATHERS[i].targetID,\n      to: id,\n      relation: \"fathers\",\n      style: \"\"\n    };\n    if (edges[relationships.FATHERS[i].targetID]) {\n      // Duplicated edge\n      console.log(\n        \"Fathers suspicious - TODO handle\",\n        relationships.FATHERS[i].target\n      );\n    } else {\n      edges[relationships.FATHERS[i].targetID] = edge;\n    }\n  }\n\n  for (let i = 0; i < relationships.CHILDREN.length; i++) {\n    //All descendants are at relative +1\n    for (let j = 0; j < relationships.CHILDREN[i].child.length; j++) {\n      let node: nodeType = {\n        id: relationships.CHILDREN[i].child[j].targetID,\n        depth: 1,\n        location: { x: 0, y: 0 },\n        style: \"\"\n      };\n      nodes[relationships.CHILDREN[i].child[j].targetID] = node;\n      let edge: edgeType = {\n        from: id,\n        to: relationships.CHILDREN[i].child[j].targetID,\n        relation: \"child\",\n        style: \"\"\n      };\n      if (edges[relationships.CHILDREN[i].child[j].targetID]) {\n        // Duplicated edge\n        console.log(\n          \"Child suspicious - TODO handle\",\n          relationships.CHILDREN[i].child[j].target\n        );\n      } else {\n        edges[relationships.CHILDREN[i].child[j].targetID] = edge;\n      }\n    }\n    //All other parents (co-parents) are at depth 0\n    for (let j = 0; j < relationships.CHILDREN[i].otherParentIDs.length; j++) {\n      let node: nodeType = {\n        id: relationships.CHILDREN[i].otherParentIDs[j],\n        depth: 0,\n        location: { x: 0, y: 0 },\n        style: \"\"\n      };\n      nodes[relationships.CHILDREN[i].otherParentIDs[j]] = node;\n      let edge: edgeType;\n      if (relationships.CHILDREN[i].otherParentIDs.length > 1) {\n        edge = {\n          from: id,\n          to: relationships.CHILDREN[i].otherParentIDs[j],\n          relation: \"co-parent\",\n          style: \"\",\n          disputed: \"co-parent\"\n        };\n      } else {\n        edge = {\n          from: id,\n          to: relationships.CHILDREN[i].otherParentIDs[j],\n          relation: \"co-parent\",\n          style: \"\"\n        };\n      }\n      if (edges[relationships.CHILDREN[i].otherParentIDs[j]]) {\n        // Duplicated edge\n        console.log(\n          \"Other parent suspicious - TODO handle\",\n          getName(entities[relationships.CHILDREN[i].otherParentIDs[j]])\n        );\n      } else {\n        edges[relationships.CHILDREN[i].otherParentIDs[j]] = edge;\n      }\n    }\n  }\n\n  return { nodes, edges };\n};\n\n/* let edges = g.edges();\n  // if (depth > 1) {\n    for (let i = 0; i < edges.length; i++) {\n      // Does this actually update g?\n      // Recursive call to getAllLinks()\n      getAllRelationshipLinks(\n        g,\n        depth - 1,\n        edges[i].v,\n        JSON.parse(relationships[edges[i].v]).relationships\n      );\n    }\n  } \n}; */\n","import React from \"react\";\nimport \"./App.css\";\nimport { getGraph } from \"./GraphHandler\";\nimport { checkNoRelations, getName } from \"./DataCardHandler\";\nimport entities from \"./data/entities.json\";\nimport relationships from \"./data/relationships.json\";\n// import Konva from \"konva\";\n/* import {\n  Stage,\n  Layer,\n  Label,\n  Tag,\n  Line,\n  Text,\n  Group,\n  Rect,\n  Circle\n} from \"react-konva\"; */\n\nclass EntityGraph extends React.Component {\n  // Combining canvas tag with konva-react: https://lavrton.com/using-react-with-html5-canvas-871d07d8d753/\n  constructor(props) {\n    super(props);\n    this.state = {\n      openInfoPage: { showDisputePage: false, showUnusualPage: false },\n      nodeWidth: 80,\n      nodeHeight: 30,\n      nodeHorizontalSpacing: 60,\n      nodeVerticalSpacing: 100,\n      verticalOffset: 250\n    };\n  }\n\n  node(props) {\n    const { ctx, x, y, text } = props;\n    if (text === \"Unknown\") {\n      ctx.strokeStyle = \"#848484\";\n      ctx.setLineDash([5, 4]);\n      ctx.strokeRect(x, y, this.state.nodeWidth, this.state.nodeHeight);\n      ctx.fillText(text, x + 10, y + 20);\n      ctx.setLineDash([]);\n      ctx.strokeStyle = \"#000\";\n    } else {\n      ctx.strokeRect(x, y, this.state.nodeWidth, this.state.nodeHeight);\n      ctx.fillText(text, x + 10, y + 20);\n    }\n  }\n\n  edge(props) {\n    const { ctx, fromX, fromY, toX, toY } = props;\n    ctx.beginPath();\n    ctx.moveTo(fromX, fromY + this.state.nodeHeight / 2);\n    ctx.lineTo(toX, toY + this.state.nodeHorizontalSpacing / 2);\n    ctx.stroke();\n  }\n\n  parentEdge(props) {\n    const {\n      ctx,\n      nodePositions,\n      parent1,\n      parent2,\n      siblings,\n      y,\n      disputed\n    } = props;\n    let parent1X = nodePositions[parent1].x1 + this.state.nodeWidth / 2;\n    let parent2X = nodePositions[parent2].x1 + this.state.nodeWidth / 2;\n    ctx.beginPath();\n    if (disputed) {\n      ctx.strokeStyle = \"#f00\";\n    }\n    ctx.moveTo(parent1X, y + this.state.nodeHeight);\n    ctx.lineTo(parent1X, y + this.state.nodeHeight + 20);\n    ctx.lineTo(parent2X, y + this.state.nodeHeight + 20);\n    ctx.lineTo(parent2X, y + this.state.nodeHeight);\n    ctx.moveTo((parent1X + parent2X) / 2, y + this.state.nodeHeight + 20);\n    ctx.lineTo((parent1X + parent2X) / 2, y + this.state.nodeHeight + 70);\n\n    let centrePoint = {\n      x: (parent1X + parent2X) / 2,\n      y: y + this.state.nodeHeight + 70\n    };\n    Object.values(siblings).forEach(s => {\n      ctx.moveTo(centrePoint.x, centrePoint.y);\n      ctx.lineTo(s.x1 + this.state.nodeWidth / 2, centrePoint.y);\n      ctx.lineTo(s.x1 + this.state.nodeWidth / 2, s.y1);\n    });\n\n    ctx.stroke();\n    ctx.strokeStyle = \"#000\";\n  }\n\n  childEdge(props) {\n    const { ctx, nodePositions, parents, children, nodeYOffset } = props;\n    if (parents.length > 1) {\n      // disputed parentage\n      ctx.strokeStyle = \"#f00\";\n    }\n    let newNodeYOffset = nodeYOffset;\n\n    let mainLocation = {\n      x: nodePositions[this.props.id].x1 + this.state.nodeWidth / 2,\n      y: nodePositions[this.props.id].y1 + this.state.nodeHeight\n    };\n\n    if (parents.length === 0) {\n      // Other parent is unknown\n      parents.push(\"Unknown\");\n    }\n    for (let i = 0; i < parents.length; i++) {\n      //Start line at halfway point between coparents, and draw line between coparents\n      ctx.beginPath();\n      //Draw parent to parent half-rectangle\n      ctx.moveTo(mainLocation.x, mainLocation.y);\n      ctx.lineTo(mainLocation.x, mainLocation.y + newNodeYOffset);\n      let otherParentLocation = {\n        x: nodePositions[parents[i]].x1 + this.state.nodeWidth / 2,\n        y: nodePositions[parents[i]].y1 + this.state.nodeHeight\n      };\n      ctx.lineTo(otherParentLocation.x, otherParentLocation.y + newNodeYOffset);\n      ctx.lineTo(otherParentLocation.x, otherParentLocation.y);\n      //Draw from middle of parent half-rectangle to child middle point\n      ctx.moveTo(\n        (otherParentLocation.x + mainLocation.x) / 2,\n        otherParentLocation.y + newNodeYOffset\n      );\n      let middle = {\n        x: (otherParentLocation.x + mainLocation.x) / 2,\n        y:\n          otherParentLocation.y +\n          this.state.verticalOffset +\n          newNodeYOffset +\n          20\n      };\n      ctx.lineTo(middle.x, middle.y);\n      //Start drawing child half-rectangles\n      for (let j = 0; j < children.length; j++) {\n        ctx.moveTo(middle.x, middle.y);\n        console.log(\n          \"Move to\",\n          children[j].target,\n          \"from\",\n          getName(entities[parents[i]])\n        );\n        ctx.lineTo(\n          nodePositions[children[j].targetID].x1 + this.state.nodeWidth / 2, //This is probably the area of change\n          middle.y\n        );\n        ctx.lineTo(\n          nodePositions[children[j].targetID].x1 + this.state.nodeWidth / 2,\n          nodePositions[children[j].targetID].y1\n        );\n      }\n      ctx.stroke();\n      newNodeYOffset += 10;\n    }\n    ctx.strokeStyle = \"#000\";\n    return newNodeYOffset;\n  }\n\n  componentDidUpdate() {\n    let nodePositions = {};\n    let nodeWidth = this.state.nodeWidth;\n    let nodeHeight = this.state.nodeHeight;\n    let nodeHorizontalSpacing = this.state.nodeHorizontalSpacing;\n    let nodeVerticalSpacing = this.state.nodeVerticalSpacing;\n\n    // Return the graph with populated nodes\n    if (\n      !checkNoRelations(JSON.parse(relationships[this.props.id]).relationships)\n    ) {\n      let graphContent = getGraph(this.props.id);\n      console.log(graphContent);\n\n      //Set the scrollbar for the canvas to start in the centre\n      let canvasDiv = this.refs.canvasOuterDiv;\n      canvasDiv.scrollLeft = 4500;\n      // Provide context for graph - render graph on canvas\n      // Uses HTML CanvasRenderingContext2D functions: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D\n      const ctx = this.refs.graphCanvas.getContext(\"2d\");\n\n      /************************************************************************/\n      /*    ~~~~~~    NODES   ~~~~~~~                                         */\n      /************************************************************************/\n\n      //Add in main node:\n      let mainNodeWidth = this.refs.graphCanvas.width / 2;\n      let mainNodeHeight = 200;\n      this.node({\n        ctx,\n        x: mainNodeWidth,\n        y: mainNodeHeight,\n        text: getName(entities[this.props.id])\n      });\n      nodePositions[this.props.id] = {\n        x1: mainNodeWidth,\n        y1: mainNodeHeight,\n        x2: mainNodeWidth + this.state.nodeWidth,\n        y2: mainNodeHeight + this.state.nodeHeight\n      };\n\n      /*  DEPTH -1 - MOTHERS, FATHERS & DIVINE PARENTS  */\n      let extension = 1;\n      let level =\n        nodePositions[this.props.id].y1 - nodeVerticalSpacing - nodeHeight;\n      let fathers = JSON.parse(relationships[this.props.id]).relationships\n        .FATHERS;\n      let mothers = JSON.parse(relationships[this.props.id]).relationships\n        .MOTHERS;\n\n      if (fathers.length > 0 || mothers.length > 0) {\n        Object.values(graphContent.nodes).forEach(node => {\n          if (node.depth === -1 && node.id !== this.props.id) {\n            if (extension % 2 === 0) {\n              let rightX =\n                nodePositions[this.props.id].x1 +\n                (nodeHorizontalSpacing + nodeWidth) * extension * 0.5;\n              let rightY = level;\n              this.node({\n                ctx,\n                x: rightX,\n                y: rightY,\n                text: getName(entities[node.id])\n              });\n              nodePositions[node.id] = {\n                x1: rightX,\n                y1: rightY,\n                x2: rightX + nodeWidth,\n                y2: rightY + nodeHeight\n              };\n            } else {\n              let leftX =\n                nodePositions[this.props.id].x1 -\n                (nodeHorizontalSpacing + nodeWidth) * (extension - 1) * 0.5;\n              let leftY = level;\n              this.node({\n                ctx,\n                x: leftX,\n                y: leftY,\n                text: getName(entities[node.id])\n              });\n              nodePositions[node.id] = {\n                x1: leftX,\n                y1: leftY,\n                x2: leftX + nodeWidth,\n                y2: leftY + nodeHeight\n              };\n            }\n            extension++;\n          }\n        });\n      }\n\n      /*  DEPTH 0 - SIBLINGS AND SPOUSES */\n      //Loop through all depth 0 nodes and add them into the graph\n\n      extension = 0;\n\n      let depth0Nodes = [];\n      Object.values(graphContent.nodes).forEach(node => {\n        if (node.depth === 0 && node.id !== this.props.id) {\n          depth0Nodes.push(node);\n        }\n      });\n      let middleIndex = Math.floor(depth0Nodes.length / 2) - 1;\n      let xPosition =\n        nodePositions[this.props.id].x1 -\n        (nodeWidth + nodeHorizontalSpacing) * (middleIndex + 1);\n      for (let i = 0; i < depth0Nodes.length; i++) {\n        this.node({\n          ctx,\n          x: xPosition,\n          y: nodePositions[this.props.id].y1,\n          text: getName(entities[depth0Nodes[i].id])\n        });\n        nodePositions[depth0Nodes[i].id] = {\n          x1: xPosition,\n          y1: nodePositions[this.props.id].y1,\n          x2: xPosition + nodeWidth,\n          y2: nodePositions[this.props.id] + nodeHeight\n        };\n        if (i === middleIndex) {\n          xPosition = xPosition + (nodeWidth + nodeHorizontalSpacing) * 2;\n        } else {\n          xPosition = xPosition + nodeWidth + nodeHorizontalSpacing;\n        }\n      }\n\n      /*  DEPTH 1 - CHILDREN */\n      extension = 0;\n      let siblings = JSON.parse(relationships[this.props.id]).relationships\n        .SIBLINGS;\n      let children = JSON.parse(relationships[this.props.id]).relationships\n        .CHILDREN;\n      // Get the depth of parents to place children nodes\n      let numChildren = 0;\n      let numParents = 0;\n      let createUnknownNode = false;\n      children.forEach(c => {\n        numChildren += c.child.length;\n        numParents += c.otherParentIDs.length; // Not the same number of actual parents, but more rather than less.\n        if (c.otherParentIDs.length === 0) {\n          createUnknownNode = true;\n        }\n      });\n      if (createUnknownNode) {\n        this.node({\n          ctx,\n          x:\n            nodePositions[depth0Nodes[depth0Nodes.length - 1].id].x2 +\n            nodeHorizontalSpacing,\n          y: nodePositions[this.props.id].y1,\n          text: \"Unknown\"\n        });\n        nodePositions[\"Unknown\"] = {\n          x1:\n            nodePositions[depth0Nodes[depth0Nodes.length - 1].id].x2 +\n            nodeHorizontalSpacing,\n          y1: nodePositions[this.props.id].y1,\n          x2:\n            nodePositions[depth0Nodes[depth0Nodes.length - 1].id].x2 +\n            nodeHorizontalSpacing +\n            nodeWidth,\n          y2: nodePositions[this.props.id].y1 + nodeHeight\n        };\n      }\n      let startingX =\n        nodePositions[this.props.id].x1 -\n        (numChildren / 2) * (nodeWidth + nodeHorizontalSpacing);\n      let startingY =\n        nodePositions[this.props.id].y2 +\n        this.state.verticalOffset +\n        numParents * 10 +\n        80;\n\n      children.forEach(i => {\n        for (let j = 0; j < i.child.length; j++) {\n          this.node({\n            ctx,\n            x: startingX + extension * (nodeWidth + nodeHorizontalSpacing),\n            y: startingY,\n            text: getName(entities[i.child[j].targetID])\n          });\n          nodePositions[i.child[j].targetID] = {\n            x1: startingX + extension * (nodeWidth + nodeHorizontalSpacing),\n            y1: startingY,\n            x2:\n              startingX +\n              extension * (nodeWidth + nodeHorizontalSpacing) +\n              nodeWidth,\n            y2: startingY + nodeHeight\n          };\n          extension++;\n        }\n      });\n\n      /***************************************/\n      /*      ~~~ EDGES ~~~~~                */\n      /***************************************/\n\n      /* PARENT EDGES LINKING TO SIBLING NODES (DEPTH 1 -> DEPTH 0)*/\n\n      // Get location of all siblings\n      // Add all siblings and pre-add the main node\n      let connectedSiblings = {};\n      connectedSiblings[this.props.id] = nodePositions[this.props.id];\n\n      siblings.forEach(s => {\n        connectedSiblings[s.targetID] = nodePositions[s.targetID];\n      });\n      // Get parents\n      let disputed = mothers.length > 1 || fathers.length > 1;\n      let parentGroupings = [];\n      if (mothers.length > 1) {\n        mothers.forEach(m => {\n          fathers.forEach(f => {\n            parentGroupings.push({\n              parent1: m.targetID,\n              parent2: f.targetID\n            });\n          });\n        });\n      } else if (fathers.length > 1) {\n        fathers.forEach(f => {\n          mothers.forEach(m => {\n            parentGroupings.push({\n              parent1: m.targetID,\n              parent2: f.targetID\n            });\n          });\n        });\n      } else {\n        // No disputed connections\n        // TODO: Add when only one parent is known\n        if (mothers.length !== 0 && fathers.length !== 0) {\n          parentGroupings.push({\n            parent1: mothers[0].targetID,\n            parent2: fathers[0].targetID\n          });\n        }\n      }\n\n      parentGroupings.forEach(p => {\n        this.parentEdge({\n          ctx,\n          nodePositions,\n          parent1: p.parent1,\n          parent2: p.parent2,\n          y: level,\n          siblings: connectedSiblings,\n          disputed: disputed\n        });\n      });\n\n      /* SPOUSES/COPARENTS LINKING TO CHILDREN EDGES */\n\n      let nodeYOffset = 20;\n      children.forEach(i => {\n        let newNodeYOffset = this.childEdge({\n          ctx,\n          nodePositions,\n          parents: i.otherParentIDs,\n          children: i.child,\n          nodeYOffset: nodeYOffset\n        });\n        nodeYOffset = newNodeYOffset;\n      });\n    }\n  }\n\n  // To add a scrollbar: https://stackoverflow.com/questions/56645156/how-to-add-a-scrollable-area-in-a-konva-stage\n  render() {\n    return (\n      <div style={{ textAlign: \"center\" }}>\n        <h1>Relationship Graph for {getName(entities[this.props.id])}</h1>\n        <div style={{ marginBottom: \"2rem\" }}>\n          <h2>Legend:</h2>\n          <div style={{ marginBottom: \"2rem\", marginTop: \"2rem\" }}>\n            {/* <span id=\"legend-mainnode\">Main node</span> */}\n            <span id=\"legend-relationnode\">Agent node</span>\n            <span id=\"legend-collectivenode\">Collective node</span>\n          </div>\n          <div style={{ marginBottom: \"2rem\" }}>\n            <span id=\"legend-relationedge\">Genealogical connection</span>\n            <span id=\"legend-disputededge\">Disputed tradition</span>\n            <span id=\"legend-unusualedge\">Unusual connection</span>\n            <span id=\"legend-memberedge\">Member of collective</span>\n          </div>\n        </div>\n        {/*<Stage width={window.innerWidth} height={window.innerHeight}>\n          <Layer>\n            <Label x={window.innerWidth / 2} y={window.innerHeight / 2}>\n              <Tag stroke=\"#333\"></Tag>\n              <Text\n                text={getName(entities[this.props.id])}\n                height={50}\n                width={200}\n                padding={20}\n                fontSize={20}\n                align={\"center\"}\n              ></Text>\n            </Label>\n            <Line\n              x={20}\n              y={200}\n              points={[0, 0, 100, 0, 100, 100]}\n              tension={0.5}\n              closed\n              stroke=\"black\"\n              fillLinearGradientStartPoint={{ x: -50, y: -50 }}\n              fillLinearGradientEndPoint={{ x: 50, y: 50 }}\n              fillLinearGradientColorStops={[0, \"red\", 1, \"yellow\"]}\n            />\n          </Layer>\n    </Stage>*/}\n        <div\n          ref=\"canvasOuterDiv\"\n          style={{\n            overflow: \"scroll\",\n            border: \"1px solid #000000\",\n            maxWidth: \"100%\",\n            maxHeight: \"100%\",\n            textAlign: \"center\"\n          }}\n        >\n          <canvas\n            ref=\"graphCanvas\"\n            id=\"responsive-canvas\"\n            width={10000}\n            height={1000}\n          ></canvas>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default EntityGraph;\n","import React from \"react\";\nimport \"./App.css\";\nimport \"./DataCards.scss\";\nimport queryString from \"querystring\";\nimport passages from \"./data/passages.json\";\nimport relationships from \"./data/relationships.json\";\nimport EntityGraph from \"./EntityGraph.jsx\";\nimport ReactGA from \"react-ga\";\nimport entities from \"./data/entities.json\";\nimport {\n  relationshipInfo,\n  checkNoRelations,\n  getAlternativeNames,\n  getGender,\n  getName,\n  getEntityType\n} from \"./DataCardHandler\";\nimport Pluralize from \"pluralize\";\n\ntype DatumProps = {\n  location: {\n    search: string;\n  };\n  history: {\n    push: ({}) => null;\n  };\n};\ntype DatumState = {\n  id: string;\n  name: string;\n  relationships: relationshipInfo;\n  members: { sub: any[]; super: any[] };\n  type: string;\n  validSearch: boolean;\n  alternativeName: { targetID: string; passage: any[] };\n};\n\nclass DataCards extends React.Component<DatumProps, DatumState> {\n  constructor(props: any) {\n    super(props);\n    // Dionysus is 8188175, use to test multiple names\n    // Atreus is 8187873\n    // Theseus is 8188822\n    // Agamemnon is 8182035\n    // Use Clytaimnestra example, 8188055\n    this.state = {\n      id: \"8182035\", // placeholder\n      name: \"\",\n      relationships: {\n        MOTHERS: [],\n        FATHERS: [],\n        SIBLINGS: [],\n        TWIN: [],\n        SPOUSES: [],\n        CHILDREN: []\n      },\n      members: { sub: [], super: [] },\n      type: \"\",\n      validSearch: false,\n      alternativeName: { targetID: \"\", passage: [] }\n    };\n    /* this.getNameFromID = this.getNameFromID.bind(this);\n    this.checkNoRelations = this.checkNoRelations.bind(this);\n    this.reversedVerb = this.reversedVerb.bind(this);\n    this.getDataPoints = this.getDataPoints.bind(this); */\n    this.handleNameClicked = this.handleNameClicked.bind(this);\n    // this.handleDisputeClicked = this.handleDisputeClicked.bind(this);\n    /* this.getAlternativeNames = this.getAlternativeNames.bind(this); */\n  }\n\n  /*******************/\n  /* HELPER FUNCTIONS */\n  /*******************/\n\n  getPassageLink(passage: any) {\n    let id = passage.startID;\n    let author: string = passages[id].Author;\n    let title: string = passages[id].Title;\n    let start: string = passages[id].Passage;\n    let end: string = passage.endID;\n\n    // Dealing with multiple URNs\n    let URN: string = \"\";\n    let URNsplit = passages[id][\"CTS URN\"].split(\", \");\n    if (URNsplit.length >= 2) {\n      URN = URNsplit[1];\n    } else {\n      URN = passages[id][\"CTS URN\"];\n    }\n\n    URN = \"https://scaife.perseus.org/reader/\" + URN;\n    if (passage.endID !== \"\") {\n      end = passages[end].Passage;\n      URN = URN + \"-\" + end;\n    }\n    URN = URN + \"/?right=perseus-eng2\";\n\n    return (\n      <span>\n        {\"  (\"}\n        <a\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          href={URN}\n          style={{\n            color: \"grey\",\n            fontSize: \"0.8rem\"\n          }}\n        >\n          {author + \", \"}\n          <span style={{ fontStyle: \"italic\" }}>{title}</span> {start}\n          {start !== end && end !== \"\" ? \"-\" + end : \"\"}\n        </a>\n        {\")\"}\n      </span>\n    );\n  }\n\n  handleNameClicked(targetID: string) {\n    ReactGA.event({\n      category: \"NameClicked\",\n      action: \"User clicked on a name within the data card\"\n    });\n    this.props.history.push(\"/datacards?id=\" + targetID);\n  }\n\n  /* handleDisputeClicked(edge: any, id: string) {\n    console.log(\"edge\", edge, \"id\", id);\n    this.setState({\n      openInfoPage: { showDisputePage: true, showUnusualPage: false }\n    });\n  } */\n\n  getDataPoints(relationship: string, showPassage: boolean) {\n    let that = this;\n    let focus =\n      relationship === \"PART OF\"\n        ? this.state.members.super\n        : that.state.relationships[relationship];\n    if (focus.length !== 0) {\n      return (\n        <div style={{ clear: \"both\" }}>\n          <div\n            style={{\n              fontWeight: \"bold\",\n              textTransform: \"uppercase\",\n              float: \"left\",\n              paddingRight: \"1rem\",\n              marginTop: \"0.5rem\"\n            }}\n          >\n            {this.getPluralization(relationship)}\n          </div>\n          <div style={{ float: \"left\", marginTop: \"0.5rem\" }}>\n            {focus.map(entity => {\n              return (\n                <div style={{ margin: \"0\" }}>\n                  {this.checkUnusualRelationship(\n                    entity,\n                    relationship,\n                    showPassage\n                  )}\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  getPluralization(relationship: string) {\n    if (relationship === \"PART OF\") {\n      return relationship + \": \";\n    } else if (relationship === \"MOTHERS\" || relationship === \"FATHERS\") {\n      return Pluralize.singular(relationship) + \": \";\n    } else {\n      if (this.state.relationships[relationship].length === 1) {\n        return Pluralize.singular(relationship) + \": \";\n      } else {\n        return relationship + \": \";\n      }\n    }\n  }\n\n  checkUnusualRelationship(\n    entity: any,\n    relationship: any,\n    showPassage: boolean\n  ) {\n    let that = this;\n\n    if (\n      (relationship === \"MOTHERS\" && entity.mother_parthenogenesis) ||\n      (relationship === \"FATHERS\" && entity.father_parthenogenesis)\n    ) {\n      return (\n        <span>\n          <div\n            className=\"entity-button\"\n            onClick={() => this.handleNameClicked(entity.targetID)}\n          >\n            {entity !== that.state.relationships[relationship][0] ? (\n              <span>OR </span>\n            ) : (\n              \"\"\n            )}\n            <span style={{ textDecoration: \"underline\" }}>{entity.target}</span>\n          </div>\n          <span> by pathenogenesis </span>\n          {showPassage\n            ? entity.passage.map(passage => {\n                return this.getPassageLink(passage);\n              })\n            : \"\"}\n        </span>\n      );\n    } else if (relationship === \"FATHERS\" && entity.autochthony) {\n      return (\n        <span>\n          {entity !== that.state.relationships[relationship][0] ? (\n            <span>OR </span>\n          ) : (\n            \"\"\n          )}\n          <span>By autochthony </span>\n          {showPassage\n            ? entity.passage.map(passage => {\n                return this.getPassageLink(passage);\n              })\n            : \"\"}\n        </span>\n      );\n    } else if (relationship === \"CHILDREN\") {\n      return (\n        <div className=\"entity-child-wrapper\">\n          <div className=\"entity-child-grouping\">\n            {that.getChildParentGrouped(entity)}\n          </div>\n          {that.getOtherParentText(entity.otherParentIDs)}\n        </div>\n      );\n    } else {\n      return (\n        <span>\n          <div\n            className=\"entity-button\"\n            onClick={() => this.handleNameClicked(entity.targetID)}\n          >\n            {relationship !== \"CHILDREN\" &&\n            relationship !== \"SIBLINGS\" &&\n            relationship !== \"SPOUSES\" &&\n            relationship !== \"PART OF\" &&\n            entity !== that.state.relationships[relationship][0] ? (\n              <span>OR </span>\n            ) : (\n              \"\"\n            )}\n            <span style={{ textDecoration: \"underline\" }}>{entity.target}</span>\n          </div>\n          {showPassage ? (\n            entity.passage.map(passage => {\n              return this.getPassageLink(passage);\n            })\n          ) : (\n            <span style={{ paddingRight: \"10rem\" }}></span>\n          )}\n        </span>\n      );\n    }\n  }\n\n  getChildParentGrouped(group: any) {\n    return group.child.map(c => {\n      return (\n        <div\n          className=\"entity-child-button\"\n          onClick={() => this.handleNameClicked(c.targetID)}\n        >\n          {c.target}\n        </div>\n      );\n    });\n  }\n\n  getOtherParentText(otherParentIDs: any[]) {\n    if (otherParentIDs.length === 0) {\n      return <div className=\"entity-parent-grouping\"></div>;\n    } else {\n      return (\n        <div className=\"entity-parent-grouping\">\n          with{\" \"}\n          {otherParentIDs.map(pID => {\n            return (\n              <span>\n                <span\n                  className=\"entity-child-button\"\n                  style={{ margin: 0 }}\n                  onClick={() => this.handleNameClicked(pID)}\n                >\n                  {getName(entities[pID])}\n                </span>\n                {otherParentIDs.indexOf(pID) === otherParentIDs.length - 1\n                  ? \"\"\n                  : \" OR \"}\n              </span>\n            );\n          })}\n        </div>\n      );\n    }\n  }\n\n  getCollectiveMembers() {\n    let that = this;\n    if (that.state.members.sub.length !== 0) {\n      return (\n        <div style={{ marginTop: \"3rem\", textAlign: \"center\" }}>\n          <div\n            style={{\n              fontWeight: \"bold\",\n              textTransform: \"uppercase\",\n              textDecoration: \"underline\",\n              marginBottom: \"0.5rem\",\n              marginTop: \"5rem\"\n            }}\n          >\n            MEMBERS:\n          </div>\n          {that.state.members.sub.map(member => {\n            return (\n              <div style={{ margin: \"0\" }}>\n                <span\n                  className=\"collective-button\"\n                  onClick={() => this.handleNameClicked(member.targetID)}\n                >\n                  {member.target}\n                </span>\n                {member.passage.map(passage => {\n                  return this.getPassageLink(passage);\n                })}\n              </div>\n            );\n          })}\n        </div>\n      );\n    }\n  }\n\n  getCollectiveSubheading(id: string) {\n    let relation = getGender(id) === \"Female\" ? \"daughters\" : \"sons\";\n    // How to deal with multiple of the same ID in the entities?\n    let parents = getName(\n      entities[entities[id][\"Collective (geneal.): children of ID\"]]\n    );\n    if (entities[id][\"Other collective parent ID\"]) {\n      parents =\n        parents +\n        \" and \" +\n        getName(entities[entities[id][\"Other collective parent ID\"]]);\n    }\n    let divineParents = entities[id][\"Collective (geneal.): divine father ID\"]\n      ? \"OR \" +\n        getName(\n          entities[entities[id][\"Collective (geneal.): divine father ID\"]]\n        )\n      : \"\";\n    /* let parents: { mothers: string; fathers: string } = {\n      mothers: \"\",\n      fathers: \"\"\n    };\n    for (let i = 0; i < this.state.relationships.MOTHERS.length; i++) {\n      if (parents.mothers === \"\") {\n        parents.mothers = this.state.relationships.MOTHERS[i].target;\n      } else {\n        parents.mothers =\n          parents.mothers + \" OR \" + this.state.relationships.MOTHERS[i].target;\n      }\n    }\n    for (let i = 0; i < this.state.relationships.FATHERS.length; i++) {\n      if (parents.fathers === \"\") {\n        parents.fathers = this.state.relationships.FATHERS[i].target;\n      } else {\n        parents.fathers =\n          parents.fathers + \" OR \" + this.state.relationships.FATHERS[i].target;\n      }\n    }\n    let finalString = \"\";\n    if (parents.mothers !== \"\" && parents.fathers !== \"\") {\n      finalString = parents.mothers + \" and \" + parents.fathers;\n    } else if (parents.mothers !== \"\" && parents.fathers === \"\") {\n      finalString = parents.mothers;\n    } else if (parents.mothers === \"\" && parents.fathers !== \"\") {\n      finalString = parents.fathers;\n    } else {\n    } */\n\n    return (\n      <div id=\"datacard-alternativename\">\n        The {relation} of {parents} {divineParents}\n      </div>\n    );\n  }\n\n  getAlternativePage() {\n    if (\n      this.state.alternativeName.targetID !== \"\" &&\n      this.state.alternativeName.passage !== []\n    ) {\n      return (\n        <div\n          id=\"datacard-alternativename\"\n          className={\n            this.state.alternativeName.targetID === \"\" ||\n            this.state.alternativeName.passage === []\n              ? \"no-display\"\n              : \"\"\n          }\n        >\n          Alternative name for{\" \"}\n          {this.state.alternativeName.targetID === \"\" ? (\n            \"\"\n          ) : (\n            <span>\n              <span\n                className=\"entity-alt-button\"\n                onClick={() =>\n                  this.handleNameClicked(this.state.alternativeName.targetID)\n                }\n              >\n                {getName(entities[this.state.alternativeName.targetID])}\n              </span>\n              {this.state.alternativeName.passage.map(passage => {\n                return this.getPassageLink(passage);\n              })}\n            </span>\n          )}\n        </div>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  /*******************/\n  /* SETUP FUNCTIONS */\n  /*******************/\n\n  componentDidMount() {\n    const params = queryString.parse(this.props.location.search.slice(1));\n    const id = params.id as string;\n    if (!params.id) {\n      // Handle bad url\n      //@ts-ignore\n      this.setState({ validSearch: false });\n    } else {\n      //Substitute with ID\n      let newState = JSON.parse(relationships[id]);\n      this.setState({\n        id: newState.id,\n        relationships: newState.relationships,\n        members: newState.members,\n        name: newState.name,\n        type: newState.type,\n        validSearch: newState.validSearch,\n        alternativeName: newState.alternativeName\n      });\n    }\n  }\n\n  componentDidUpdate() {\n    const params = queryString.parse(this.props.location.search.slice(1));\n    const id = params.id as string;\n    if (!params.id) {\n      // Handle bad url\n      //@ts-ignore\n      this.setState({ validSearch: false });\n    } else if (this.state.id !== id) {\n      //Substitute with ID\n      let newState = JSON.parse(relationships[id]);\n      this.setState({\n        id: newState.id,\n        relationships: newState.relationships,\n        members: newState.members,\n        name: newState.name,\n        type: newState.type,\n        validSearch: newState.validSearch,\n        alternativeName: newState.alternativeName\n      });\n    }\n  }\n\n  /*************/\n  /* RENDERING */\n  /*************/\n\n  render() {\n    return (\n      <React.Fragment>\n        <div\n          className={this.state.validSearch ? \"no-display\" : \"\"}\n          style={{ textAlign: \"center\", padding: \"3rem\" }}\n        >\n          No profiles have been selected. Try using the Search function.\n        </div>\n        <div className={this.state.validSearch ? \"\" : \"no-display\"}>\n          <div\n            style={{\n              margin: \"1rem 6rem 3rem 6rem\",\n              padding: \"3rem\",\n              display: \"flow-root\",\n              border: \"solid 1px black\"\n            }}\n          >\n            <div style={{ textAlign: \"center\" }}>\n              {getEntityType(this.state.id)}\n            </div>\n            <div id=\"datacard-heading\">{this.state.name}</div>\n            <div id=\"datacard-othernames\">\n              {getAlternativeNames(this.state.id)}\n            </div>\n            <div id=\"datacard-mantoID\">MANTO ID: {this.state.id}</div>\n            <div\n              id=\"datacard-othernames\"\n              className={getGender(this.state.id) === \"\" ? \"no-display\" : \"\"}\n            >\n              Gender: {getGender(this.state.id)}\n            </div>\n            {/* If no data is available for the subject */}\n            <div\n              className={\n                checkNoRelations(this.state.relationships) ? \"\" : \"no-display\"\n              }\n            ></div>\n            {/* If current entity is an alternative name for an existing entity */}\n            <div>{this.getAlternativePage()}</div>\n            {/* If data is available for the subject */}\n            {entities[this.state.id][\"Type of entity\"] ===\n            \"Collective (genealogical)\"\n              ? this.getCollectiveSubheading(this.state.id)\n              : Object.keys(this.state.relationships).map(key => {\n                  if (\n                    key === \"MOTHERS\" ||\n                    key === \"FATHERS\" ||\n                    key === \"SPOUSES\"\n                  ) {\n                    return <div key={key}>{this.getDataPoints(key, true)}</div>;\n                  } else {\n                    return (\n                      <div key={key}>{this.getDataPoints(key, false)}</div>\n                    );\n                  }\n                })}\n            {this.state.members.super.length !== 0 ? (\n              <div>{this.getDataPoints(\"PART OF\", true)}</div>\n            ) : (\n              \"\"\n            )}\n            <div>{this.getCollectiveMembers()}</div>\n          </div>\n        </div>\n        <div\n          className={\n            entities[this.state.id][\"Type of entity\"] === \"Agent\"\n              ? \"\"\n              : \"no-display\"\n          }\n        >\n          <EntityGraph\n            id={this.state.id}\n            relationshipClicked={this.handleNameClicked}\n            // disputeClicked={this.handleDisputeClicked}\n          ></EntityGraph>\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default DataCards;\n","import React from \"react\";\nimport \"./App.css\";\nimport Header from \"./Header\";\nimport Search from \"./Search\";\nimport DataCards from \"./DataCards\";\nimport ReactGA from \"react-ga\";\nimport {\n  HashRouter as Router,\n  Route,\n  Link,\n  Switch,\n  Redirect\n} from \"react-router-dom\";\n\nclass App extends React.Component<{}, {}> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      subjectID: \"\"\n    };\n  }\n\n  changeEntity(ID: string) {\n    this.setState({ subjectID: ID });\n  }\n\n  initializeReactGA() {\n    ReactGA.initialize(\"UA-151993194-1\");\n    ReactGA.pageview(\"/homepage\");\n  }\n\n  render() {\n    return (\n      <div\n        style={{ backgroundColor: \"#eeeeee\", height: \"100%\", width: \"100%\" }}\n      >\n        <Router>\n          <Link to=\"/\">\n            <Header></Header>\n          </Link>\n          <Search></Search>\n          <Switch>\n            {/* <Route exact path=\"/\" component={Home} /> */}\n            <Route path=\"/search\" component={Search} />\n            <Route path=\"/datacards\" component={DataCards} />\n            <Route component={() => <Redirect to=\"/\" />} />\n          </Switch>\n        </Router>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}